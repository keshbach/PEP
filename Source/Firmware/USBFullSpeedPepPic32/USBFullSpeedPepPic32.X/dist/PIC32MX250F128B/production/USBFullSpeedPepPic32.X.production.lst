
dist\PIC32MX250F128B\production\USBFullSpeedPepPic32.X.production.elf:     file format elf32-tradlittlemips


Disassembly of section .config_BFC00BF0:

bfc00bf0 <__config_BFC00BF0>:
bfc00bf0:	ff ff ff af                                         ....

Disassembly of section .config_BFC00BF4:

bfc00bf4 <__config_BFC00BF4>:
bfc00bf4:	d9 79 f9 ff                                         .y..

Disassembly of section .config_BFC00BF8:

bfc00bf8 <__config_BFC00BF8>:
bfc00bf8:	5b ce 74 ff                                         [.t.

Disassembly of section .config_BFC00BFC:

bfc00bfc <__config_BFC00BFC>:
bfc00bfc:	fb ff ff 7f                                         ....

Disassembly of section .reset:

bfc00000 <_reset>:
bfc00000:	3c1abfc0 	lui	k0,0xbfc0
bfc00004:	275a0010 	addiu	k0,k0,16
bfc00008:	03400008 	jr	k0
bfc0000c:	00000000 	nop

bfc00010 <_startup>:
bfc00010:	401a6000 	mfc0	k0,c0_status
bfc00014:	7f5a04c0 	ext	k0,k0,0x13,0x1
bfc00018:	13400005 	beqz	k0,bfc00030 <_no_nmi>
bfc0001c:	00000000 	nop
bfc00020:	3c1a9d00 	lui	k0,0x9d00
bfc00024:	275a72f8 	addiu	k0,k0,29432
bfc00028:	03400008 	jr	k0
bfc0002c:	00000000 	nop

bfc00030 <_no_nmi>:
bfc00030:	3c1da000 	lui	sp,0xa000
bfc00034:	27bd7ff0 	addiu	sp,sp,32752
bfc00038:	3c1ca000 	lui	gp,0xa000
bfc0003c:	279c7ff0 	addiu	gp,gp,32752
bfc00040:	40096002 	mfc0	t1,c0_srsctl
bfc00044:	01205820 	add	t3,t1,zero
bfc00048:	7d2a1e80 	ext	t2,t1,0x1a,0x4
bfc0004c:	7d494984 	ins	t1,t2,0x6,0x4
bfc00050:	40896002 	mtc0	t1,c0_srsctl
bfc00054:	000000c0 	ehb
bfc00058:	41dce000 	wrpgpr	gp,gp
bfc0005c:	408b6002 	mtc0	t3,c0_srsctl
bfc00060:	3c089d00 	lui	t0,0x9d00
bfc00064:	25087330 	addiu	t0,t0,29488
bfc00068:	0100f809 	jalr	t0
bfc0006c:	00000000 	nop
bfc00070:	3c08a000 	lui	t0,0xa000
bfc00074:	25080000 	addiu	t0,t0,0
bfc00078:	3c09a000 	lui	t1,0xa000
bfc0007c:	2529029c 	addiu	t1,t1,668
bfc00080:	10000006 	b	bfc0009c <_bss_check>
bfc00084:	00000000 	nop

bfc00088 <_bss_init>:
bfc00088:	ad000000 	sw	zero,0(t0)
bfc0008c:	ad000004 	sw	zero,4(t0)
bfc00090:	ad000008 	sw	zero,8(t0)
bfc00094:	ad00000c 	sw	zero,12(t0)
bfc00098:	25080010 	addiu	t0,t0,16

bfc0009c <_bss_check>:
bfc0009c:	0109082b 	sltu	at,t0,t1
bfc000a0:	1420fff9 	bnez	at,bfc00088 <_bss_init>
bfc000a4:	00000000 	nop

bfc000a8 <_dinit_init>:
bfc000a8:	3c089d00 	lui	t0,0x9d00
bfc000ac:	25087224 	addiu	t0,t0,29220
bfc000b0:	8d090000 	lw	t1,0(t0)
bfc000b4:	11200018 	beqz	t1,bfc00118 <_dinit_end+0x18>
bfc000b8:	25080004 	addiu	t0,t0,4
bfc000bc:	8d0a0000 	lw	t2,0(t0)
bfc000c0:	25080004 	addiu	t0,t0,4
bfc000c4:	8d0b0000 	lw	t3,0(t0)
bfc000c8:	11600009 	beqz	t3,bfc000f0 <_dinit_clear>
bfc000cc:	25080004 	addiu	t0,t0,4

bfc000d0 <_dinit_copy>:
bfc000d0:	910c0000 	lbu	t4,0(t0)
bfc000d4:	254affff 	addiu	t2,t2,-1
bfc000d8:	25080001 	addiu	t0,t0,1
bfc000dc:	a12c0000 	sb	t4,0(t1)
bfc000e0:	1540fffb 	bnez	t2,bfc000d0 <_dinit_copy>
bfc000e4:	25290001 	addiu	t1,t1,1
bfc000e8:	10000005 	b	bfc00100 <_dinit_end>
bfc000ec:	00000000 	nop

bfc000f0 <_dinit_clear>:
bfc000f0:	a1200000 	sb	zero,0(t1)
bfc000f4:	254affff 	addiu	t2,t2,-1
bfc000f8:	1540fffd 	bnez	t2,bfc000f0 <_dinit_clear>
bfc000fc:	25290001 	addiu	t1,t1,1

bfc00100 <_dinit_end>:
bfc00100:	25080003 	addiu	t0,t0,3
bfc00104:	240afffc 	li	t2,-4
bfc00108:	01484024 	and	t0,t2,t0
bfc0010c:	8d090000 	lw	t1,0(t0)
bfc00110:	1520ffe7 	bnez	t1,bfc000b0 <_dinit_init+0x8>
bfc00114:	00000000 	nop
bfc00118:	3c090000 	lui	t1,0x0
bfc0011c:	25290000 	addiu	t1,t1,0
bfc00120:	11200010 	beqz	t1,bfc00164 <_ramfunc_done>
bfc00124:	00000000 	nop
bfc00128:	3c090001 	lui	t1,0x1
bfc0012c:	25298000 	addiu	t1,t1,-32768
bfc00130:	3c0abf88 	lui	t2,0xbf88
bfc00134:	254a2010 	addiu	t2,t2,8208
bfc00138:	ad490000 	sw	t1,0(t2)
bfc0013c:	3c090001 	lui	t1,0x1
bfc00140:	25298000 	addiu	t1,t1,-32768
bfc00144:	3c0abf88 	lui	t2,0xbf88
bfc00148:	254a2020 	addiu	t2,t2,8224
bfc0014c:	ad490000 	sw	t1,0(t2)
bfc00150:	3c090001 	lui	t1,0x1
bfc00154:	25298000 	addiu	t1,t1,-32768
bfc00158:	3c0abf88 	lui	t2,0xbf88
bfc0015c:	254a2030 	addiu	t2,t2,8240
bfc00160:	ad490000 	sw	t1,0(t2)

bfc00164 <_ramfunc_done>:
bfc00164:	40804800 	mtc0	zero,c0_count
bfc00168:	240affff 	li	t2,-1
bfc0016c:	408a5800 	mtc0	t2,c0_compare
bfc00170:	3c099d02 	lui	t1,0x9d02
bfc00174:	2529f000 	addiu	t1,t1,-4096
bfc00178:	40897801 	mtc0	t1,c0_ebase
bfc0017c:	3c090000 	lui	t1,0x0
bfc00180:	25290001 	addiu	t1,t1,1
bfc00184:	240a0000 	li	t2,0
bfc00188:	7d2a4944 	ins	t2,t1,0x5,0x5
bfc0018c:	408a6001 	mtc0	t2,c0_intctl
bfc00190:	3c090080 	lui	t1,0x80
bfc00194:	40896800 	mtc0	t1,c0_cause
bfc00198:	40088000 	mfc0	t0,c0_config
bfc0019c:	7d090580 	ext	t1,t0,0x16,0x1
bfc001a0:	00094c40 	sll	t1,t1,0x11
bfc001a4:	40086000 	mfc0	t0,c0_status
bfc001a8:	3c010058 	lui	at,0x58
bfc001ac:	01014024 	and	t0,t0,at
bfc001b0:	01284025 	or	t0,t1,t0
bfc001b4:	40886000 	mtc0	t0,c0_status
bfc001b8:	3c089d00 	lui	t0,0x9d00
bfc001bc:	25087338 	addiu	t0,t0,29496
bfc001c0:	0100f809 	jalr	t0
bfc001c4:	00000000 	nop
bfc001c8:	40086000 	mfc0	t0,c0_status
bfc001cc:	3c01ffbf 	lui	at,0xffbf
bfc001d0:	3421ffff 	ori	at,at,0xffff
bfc001d4:	01014024 	and	t0,t0,at
bfc001d8:	40886000 	mtc0	t0,c0_status
bfc001dc:	30840000 	andi	a0,a0,0x0
bfc001e0:	30a50000 	andi	a1,a1,0x0
bfc001e4:	3c089d00 	lui	t0,0x9d00
bfc001e8:	25087310 	addiu	t0,t0,29456
bfc001ec:	01000008 	jr	t0
bfc001f0:	00000000 	nop

Disassembly of section .bev_excpt:

bfc00380 <_bev_exception>:
bfc00380:	3c1a9d00 	lui	k0,0x9d00
bfc00384:	275a7328 	addiu	k0,k0,29480
bfc00388:	03400008 	jr	k0
bfc0038c:	00000000 	nop

Disassembly of section .app_excpt:

9d01f180 <_gen_exception>:
9d01f180:	3c1a9d00 	lui	k0,0x9d00
9d01f184:	275a7028 	addiu	k0,k0,28712
9d01f188:	03400008 	jr	k0
9d01f18c:	00000000 	nop

Disassembly of section .vector_8:

9d01f300 <__vector_dispatch_8>:
9d01f300:	0b401b17 	j	9d006c5c <Timer1Handler>
9d01f304:	00000000 	nop

Disassembly of section .text:

9d000008 <USBDeviceInit>:
    Remarks:
        None
                                                          
  ***************************************************************************/
void USBDeviceInit(void)
{
9d000008:	27bdfff0 	addiu	sp,sp,-16
9d00000c:	afbe000c 	sw	s8,12(sp)
9d000010:	03a0f021 	move	s8,sp
    UINT8 i;

    MUSBDisableInterrupts();
9d000014:	3c02bf88 	lui	v0,0xbf88
9d000018:	24030008 	li	v1,8
9d00001c:	ac431074 	sw	v1,4212(v0)

    // Clear all USB error flags
    MUSBClearInterruptRegister(U1EIR);  
9d000020:	3c02bf88 	lui	v0,0xbf88
9d000024:	240300ff 	li	v1,255
9d000028:	ac435220 	sw	v1,21024(v0)
       
    // Clears all USB interrupts          
    MUSBClearInterruptRegister(U1IR); 
9d00002c:	3c02bf88 	lui	v0,0xbf88
9d000030:	240300ff 	li	v1,255
9d000034:	ac435200 	sw	v1,20992(v0)

    // Clear all of the endpoint control registers
    U1EP0 = 0;
9d000038:	3c02bf88 	lui	v0,0xbf88
9d00003c:	ac405300 	sw	zero,21248(v0)
    
    MDisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
9d000040:	3c02bf88 	lui	v0,0xbf88
9d000044:	24425310 	addiu	v0,v0,21264
9d000048:	afc20004 	sw	v0,4(s8)
9d00004c:	a3c00001 	sb	zero,1(s8)
9d000050:	0b40001e 	j	9d000078 <USBDeviceInit+0x70>
9d000054:	00000000 	nop
9d000058:	8fc20004 	lw	v0,4(s8)
9d00005c:	ac400000 	sw	zero,0(v0)
9d000060:	8fc20004 	lw	v0,4(s8)
9d000064:	24420010 	addiu	v0,v0,16
9d000068:	afc20004 	sw	v0,4(s8)
9d00006c:	93c20001 	lbu	v0,1(s8)
9d000070:	24420001 	addiu	v0,v0,1
9d000074:	a3c20001 	sb	v0,1(s8)
9d000078:	93c20001 	lbu	v0,1(s8)
9d00007c:	1040fff6 	beqz	v0,9d000058 <USBDeviceInit+0x50>
9d000080:	00000000 	nop

    MSetConfigurationOptions();
9d000084:	3c02bf88 	lui	v0,0xbf88
9d000088:	ac4052e0 	sw	zero,21216(v0)
9d00008c:	3c02bf88 	lui	v0,0xbf88
9d000090:	2403009f 	li	v1,159
9d000094:	ac435230 	sw	v1,21040(v0)
9d000098:	3c02bf88 	lui	v0,0xbf88
9d00009c:	2403009f 	li	v1,159
9d0000a0:	ac435210 	sw	v1,21008(v0)
9d0000a4:	3c02bf88 	lui	v0,0xbf88
9d0000a8:	8c425070 	lw	v0,20592(v0)
9d0000ac:	3043000f 	andi	v1,v0,0xf
9d0000b0:	3c02bf88 	lui	v0,0xbf88
9d0000b4:	ac435070 	sw	v1,20592(v0)
9d0000b8:	3c02bf88 	lui	v0,0xbf88
9d0000bc:	8c435070 	lw	v1,20592(v0)
9d0000c0:	3c02bf88 	lui	v0,0xbf88
9d0000c4:	ac435070 	sw	v1,20592(v0)

    // Power up the module (if not already powered)
    USBPowerModule();
9d0000c8:	3c03bf88 	lui	v1,0xbf88
9d0000cc:	8c625080 	lw	v0,20608(v1)
9d0000d0:	24040001 	li	a0,1
9d0000d4:	7c820004 	ins	v0,a0,0x0,0x1
9d0000d8:	ac625080 	sw	v0,20608(v1)

    // Set the address of the BDT (if applicable)
    USBSetBDTAddress(BDT);
9d0000dc:	3c02a000 	lui	v0,0xa000
9d0000e0:	24420200 	addiu	v0,v0,512
9d0000e4:	7c42e000 	ext	v0,v0,0x0,0x1d
9d0000e8:	00021e02 	srl	v1,v0,0x18
9d0000ec:	3c02bf88 	lui	v0,0xbf88
9d0000f0:	ac4352d0 	sw	v1,21200(v0)
9d0000f4:	3c02a000 	lui	v0,0xa000
9d0000f8:	24420200 	addiu	v0,v0,512
9d0000fc:	7c42e000 	ext	v0,v0,0x0,0x1d
9d000100:	00021c02 	srl	v1,v0,0x10
9d000104:	3c02bf88 	lui	v0,0xbf88
9d000108:	ac4352c0 	sw	v1,21184(v0)
9d00010c:	3c02a000 	lui	v0,0xa000
9d000110:	24420200 	addiu	v0,v0,512
9d000114:	7c42e000 	ext	v0,v0,0x0,0x1d
9d000118:	00021a02 	srl	v1,v0,0x8
9d00011c:	3c02bf88 	lui	v0,0xbf88
9d000120:	ac435270 	sw	v1,21104(v0)

    // Clear all of the BDT entries
    for (i = 0; i < MArrayLen(BDT); i++)
9d000124:	a3c00000 	sb	zero,0(s8)
9d000128:	0b400058 	j	9d000160 <USBDeviceInit+0x158>
9d00012c:	00000000 	nop
    {
        BDT[i].Val = 0x00;
9d000130:	93c30000 	lbu	v1,0(s8)
9d000134:	3c02a000 	lui	v0,0xa000
9d000138:	000318c0 	sll	v1,v1,0x3
9d00013c:	24420200 	addiu	v0,v0,512
9d000140:	00621021 	addu	v0,v1,v0
9d000144:	00002021 	move	a0,zero
9d000148:	00002821 	move	a1,zero
9d00014c:	ac440000 	sw	a0,0(v0)
9d000150:	ac450004 	sw	a1,4(v0)

    // Set the address of the BDT (if applicable)
    USBSetBDTAddress(BDT);

    // Clear all of the BDT entries
    for (i = 0; i < MArrayLen(BDT); i++)
9d000154:	93c20000 	lbu	v0,0(s8)
9d000158:	24420001 	addiu	v0,v0,1
9d00015c:	a3c20000 	sb	v0,0(s8)
9d000160:	93c20000 	lbu	v0,0(s8)
9d000164:	2c420008 	sltiu	v0,v0,8
9d000168:	1440fff1 	bnez	v0,9d000130 <USBDeviceInit+0x128>
9d00016c:	00000000 	nop
    {
        BDT[i].Val = 0x00;
    }

    // Assert reset request to all of the Ping Pong buffer pointers
    USBPingPongBufferReset = 1;                    
9d000170:	3c03bf88 	lui	v1,0xbf88
9d000174:	8c625250 	lw	v0,21072(v1)
9d000178:	24040001 	li	a0,1
9d00017c:	7c820844 	ins	v0,a0,0x1,0x1
9d000180:	ac625250 	sw	v0,21072(v1)

    // Reset to default address
    U1ADDR = 0x00;                   
9d000184:	3c02bf88 	lui	v0,0xbf88
9d000188:	ac405260 	sw	zero,21088(v0)

    // Make sure packet processing is enabled
    USBPacketDisable = 0;           
9d00018c:	3c03bf88 	lui	v1,0xbf88
9d000190:	8c625250 	lw	v0,21072(v1)
9d000194:	7c022944 	ins	v0,zero,0x5,0x1
9d000198:	ac625250 	sw	v0,21072(v1)

    // Stop trying to reset ping pong buffer pointers
    USBPingPongBufferReset = 0;
9d00019c:	3c03bf88 	lui	v1,0xbf88
9d0001a0:	8c625250 	lw	v0,21072(v1)
9d0001a4:	7c020844 	ins	v0,zero,0x1,0x1
9d0001a8:	ac625250 	sw	v0,21072(v1)

    // Flush any pending transactions
    while (USBTransactionCompleteIF == 1)      
9d0001ac:	0b40007b 	j	9d0001ec <USBDeviceInit+0x1e4>
9d0001b0:	00000000 	nop
    {
        USBClearInterruptFlag(USBTransactionCompleteIFReg, USBTransactionCompleteIFBitNum);
9d0001b4:	3c02bf88 	lui	v0,0xbf88
9d0001b8:	24030008 	li	v1,8
9d0001bc:	ac435200 	sw	v1,20992(v0)

        // Initialize USB stack software state variables
        inPipes[0].info.Val = 0;
9d0001c0:	3c02a000 	lui	v0,0xa000
9d0001c4:	24420280 	addiu	v0,v0,640
9d0001c8:	a0400004 	sb	zero,4(v0)
        outPipes[0].info.Val = 0;
9d0001cc:	3c02a000 	lui	v0,0xa000
9d0001d0:	24420290 	addiu	v0,v0,656
9d0001d4:	a0400004 	sb	zero,4(v0)
        outPipes[0].wCount = 0;
9d0001d8:	3c02a000 	lui	v0,0xa000
9d0001dc:	24430290 	addiu	v1,v0,656
9d0001e0:	8c620004 	lw	v0,4(v1)
9d0001e4:	7c02ba04 	ins	v0,zero,0x8,0x10
9d0001e8:	ac620004 	sw	v0,4(v1)

    // Stop trying to reset ping pong buffer pointers
    USBPingPongBufferReset = 0;

    // Flush any pending transactions
    while (USBTransactionCompleteIF == 1)      
9d0001ec:	3c02bf88 	lui	v0,0xbf88
9d0001f0:	8c425200 	lw	v0,20992(v0)
9d0001f4:	30420008 	andi	v0,v0,0x8
9d0001f8:	1440ffee 	bnez	v0,9d0001b4 <USBDeviceInit+0x1ac>
9d0001fc:	00000000 	nop
        outPipes[0].wCount = 0;
    }

    //Set flags to TRUE, so the USBCtrlEPAllowStatusStage() function knows not to
    //try and arm a status stage, even before the first control transfer starts.
    USBStatusStageEnabledFlag1 = TRUE;  
9d000200:	24020001 	li	v0,1
9d000204:	a3828042 	sb	v0,-32702(gp)
    USBStatusStageEnabledFlag2 = TRUE;
9d000208:	24020001 	li	v0,1
9d00020c:	a3828043 	sb	v0,-32701(gp)

    //Initialize other flags
    USBDeferINDataStagePackets = FALSE;
9d000210:	a380802c 	sb	zero,-32724(gp)
    USBDeferOUTDataStagePackets = FALSE;
9d000214:	a380802d 	sb	zero,-32723(gp)
    USBBusIsSuspended = FALSE;
9d000218:	a3808054 	sb	zero,-32684(gp)

	//Initialize all pBDTEntryIn[] and pBDTEntryOut[]
	//pointers to NULL, so they don't get used inadvertently.  
	for (i = 0; i < (UINT8)(USB_MAX_EP_NUMBER + 1u); i++)
9d00021c:	a3c00000 	sb	zero,0(s8)
9d000220:	0b40009f 	j	9d00027c <USBDeviceInit+0x274>
9d000224:	00000000 	nop
	{
		pBDTEntryIn[i] = 0u;
9d000228:	93c20000 	lbu	v0,0(s8)
9d00022c:	00021880 	sll	v1,v0,0x2
9d000230:	27828038 	addiu	v0,gp,-32712
9d000234:	00621021 	addu	v0,v1,v0
9d000238:	ac400000 	sw	zero,0(v0)
		pBDTEntryOut[i] = 0u;		
9d00023c:	93c20000 	lbu	v0,0(s8)
9d000240:	00021880 	sll	v1,v0,0x2
9d000244:	27828044 	addiu	v0,gp,-32700
9d000248:	00621021 	addu	v0,v1,v0
9d00024c:	ac400000 	sw	zero,0(v0)
		ep_data_in[i].Val = 0u;
9d000250:	93c30000 	lbu	v1,0(s8)
9d000254:	27828060 	addiu	v0,gp,-32672
9d000258:	00621021 	addu	v0,v1,v0
9d00025c:	a0400000 	sb	zero,0(v0)
        ep_data_out[i].Val = 0u;
9d000260:	93c30000 	lbu	v1,0(s8)
9d000264:	27828040 	addiu	v0,gp,-32704
9d000268:	00621021 	addu	v0,v1,v0
9d00026c:	a0400000 	sb	zero,0(v0)
    USBDeferOUTDataStagePackets = FALSE;
    USBBusIsSuspended = FALSE;

	//Initialize all pBDTEntryIn[] and pBDTEntryOut[]
	//pointers to NULL, so they don't get used inadvertently.  
	for (i = 0; i < (UINT8)(USB_MAX_EP_NUMBER + 1u); i++)
9d000270:	93c20000 	lbu	v0,0(s8)
9d000274:	24420001 	addiu	v0,v0,1
9d000278:	a3c20000 	sb	v0,0(s8)
9d00027c:	93c20000 	lbu	v0,0(s8)
9d000280:	2c420002 	sltiu	v0,v0,2
9d000284:	1440ffe8 	bnez	v0,9d000228 <USBDeviceInit+0x220>
9d000288:	00000000 	nop
		ep_data_in[i].Val = 0u;
        ep_data_out[i].Val = 0u;
	}

    //Get ready for the first packet
    pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
9d00028c:	3c02a000 	lui	v0,0xa000
9d000290:	24420210 	addiu	v0,v0,528
9d000294:	af828038 	sw	v0,-32712(gp)

    // Initialize EP0 as a Ctrl EP
    U1EP0 = EP_CTRL | USB_HANDSHAKE_ENABLED;
9d000298:	3c02bf88 	lui	v0,0xbf88
9d00029c:	2403000d 	li	v1,13
9d0002a0:	ac435300 	sw	v1,21248(v0)

	//Prepare for the first SETUP on EP0 OUT
    BDT[EP0_OUT_EVEN].ADR = MConvertToPhysicalAddress(&SetupPkt);
9d0002a4:	27828058 	addiu	v0,gp,-32680
9d0002a8:	7c43e000 	ext	v1,v0,0x0,0x1d
9d0002ac:	3c02a000 	lui	v0,0xa000
9d0002b0:	24420200 	addiu	v0,v0,512
9d0002b4:	ac430004 	sw	v1,4(v0)
    BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
9d0002b8:	3c03a000 	lui	v1,0xa000
9d0002bc:	8c620200 	lw	v0,512(v1)
9d0002c0:	24040040 	li	a0,64
9d0002c4:	7c82cc04 	ins	v0,a0,0x10,0xa
9d0002c8:	ac620200 	sw	v0,512(v1)
    BDT[EP0_OUT_EVEN].STAT.Val = _USIE | _DAT0 | _BSTALL;
9d0002cc:	3c02a000 	lui	v0,0xa000
9d0002d0:	24030084 	li	v1,132
9d0002d4:	a4430200 	sh	v1,512(v0)

    // Clear active configuration
    l_USBActiveConfiguration = 0;     
9d0002d8:	a3808010 	sb	zero,-32752(gp)

    //Indicate that we are now in the detached state        
    USBDeviceState = DETACHED_STATE;
9d0002dc:	af808030 	sw	zero,-32720(gp)
}
9d0002e0:	03c0e821 	move	sp,s8
9d0002e4:	8fbe000c 	lw	s8,12(sp)
9d0002e8:	27bd0010 	addiu	sp,sp,16
9d0002ec:	03e00008 	jr	ra
9d0002f0:	00000000 	nop

9d0002f4 <USBDeviceTasks>:
#error Platform not defined
#endif
#else
void USBDeviceTasks(void)
#endif
{
9d0002f4:	27bdffe0 	addiu	sp,sp,-32
9d0002f8:	afbf001c 	sw	ra,28(sp)
9d0002fc:	afbe0018 	sw	s8,24(sp)
9d000300:	03a0f021 	move	s8,sp
    UINT8 i;

#if defined(USB_POLLING)
    //if we are in the detached state
    if (USBDeviceState == DETACHED_STATE)
9d000304:	8f828030 	lw	v0,-32720(gp)
9d000308:	14400024 	bnez	v0,9d00039c <USBDeviceTasks+0xa8>
9d00030c:	00000000 	nop
    {
	    //Initialize register to known value
        U1CON = 0;                          
9d000310:	3c02bf88 	lui	v0,0xbf88
9d000314:	ac405250 	sw	zero,21072(v0)

        // Mask all USB interrupts
        U1IE = 0;                                
9d000318:	3c02bf88 	lui	v0,0xbf88
9d00031c:	ac405210 	sw	zero,21008(v0)

        //Enable/set things like: pull ups, full/low-speed mode, 
        //set the ping pong mode, and set internal transceiver
        MSetConfigurationOptions();
9d000320:	3c02bf88 	lui	v0,0xbf88
9d000324:	ac4052e0 	sw	zero,21216(v0)
9d000328:	3c02bf88 	lui	v0,0xbf88
9d00032c:	2403009f 	li	v1,159
9d000330:	ac435230 	sw	v1,21040(v0)
9d000334:	3c02bf88 	lui	v0,0xbf88
9d000338:	2403009f 	li	v1,159
9d00033c:	ac435210 	sw	v1,21008(v0)
9d000340:	3c02bf88 	lui	v0,0xbf88
9d000344:	8c425070 	lw	v0,20592(v0)
9d000348:	3043000f 	andi	v1,v0,0xf
9d00034c:	3c02bf88 	lui	v0,0xbf88
9d000350:	ac435070 	sw	v1,20592(v0)
9d000354:	3c02bf88 	lui	v0,0xbf88
9d000358:	8c435070 	lw	v1,20592(v0)
9d00035c:	3c02bf88 	lui	v0,0xbf88
9d000360:	ac435070 	sw	v1,20592(v0)

        // Enable module & attach to bus
        while (!U1CONbits.USBEN)
9d000364:	0b4000e0 	j	9d000380 <USBDeviceTasks+0x8c>
9d000368:	00000000 	nop
        {
            U1CONbits.USBEN = 1;
9d00036c:	3c03bf88 	lui	v1,0xbf88
9d000370:	8c625250 	lw	v0,21072(v1)
9d000374:	24040001 	li	a0,1
9d000378:	7c820004 	ins	v0,a0,0x0,0x1
9d00037c:	ac625250 	sw	v0,21072(v1)
        //Enable/set things like: pull ups, full/low-speed mode, 
        //set the ping pong mode, and set internal transceiver
        MSetConfigurationOptions();

        // Enable module & attach to bus
        while (!U1CONbits.USBEN)
9d000380:	3c02bf88 	lui	v0,0xbf88
9d000384:	8c425250 	lw	v0,21072(v0)
9d000388:	30420001 	andi	v0,v0,0x1
9d00038c:	1040fff7 	beqz	v0,9d00036c <USBDeviceTasks+0x78>
9d000390:	00000000 	nop
        {
            U1CONbits.USBEN = 1;
        }

        //moved to the attached state
        USBDeviceState = ATTACHED_STATE;
9d000394:	24020001 	li	v0,1
9d000398:	af828030 	sw	v0,-32720(gp)
    }
#endif //#if defined(USB_POLLING)

    if (USBDeviceState == ATTACHED_STATE)
9d00039c:	8f838030 	lw	v1,-32720(gp)
9d0003a0:	24020001 	li	v0,1
9d0003a4:	14620012 	bne	v1,v0,9d0003f0 <USBDeviceTasks+0xfc>
9d0003a8:	00000000 	nop
         * as a USB bus reset from the USB host.
         */

        if (!USBSE0Event)
        {
            MUSBClearInterruptRegister(U1IR);// Clear all USB interrupts
9d0003ac:	3c02bf88 	lui	v0,0xbf88
9d0003b0:	240300ff 	li	v1,255
9d0003b4:	ac435200 	sw	v1,20992(v0)

#if defined(USB_POLLING)
            U1IE = 0;                  // Mask all USB interrupts
9d0003b8:	3c02bf88 	lui	v0,0xbf88
9d0003bc:	ac405210 	sw	zero,21008(v0)
#endif

            USBResetIE = 1;            // Unmask RESET interrupt
9d0003c0:	3c03bf88 	lui	v1,0xbf88
9d0003c4:	8c625210 	lw	v0,21008(v1)
9d0003c8:	24040001 	li	a0,1
9d0003cc:	7c820004 	ins	v0,a0,0x0,0x1
9d0003d0:	ac625210 	sw	v0,21008(v1)
            USBIdleIE = 1;             // Unmask IDLE interrupt
9d0003d4:	3c03bf88 	lui	v1,0xbf88
9d0003d8:	8c625210 	lw	v0,21008(v1)
9d0003dc:	24040001 	li	a0,1
9d0003e0:	7c822104 	ins	v0,a0,0x4,0x1
9d0003e4:	ac625210 	sw	v0,21008(v1)

            USBDeviceState = POWERED_STATE;
9d0003e8:	24020002 	li	v0,2
9d0003ec:	af828030 	sw	v0,-32720(gp)
    }

    /*
     * Task A: Service USB Activity Interrupt
     */
    if (USBActivityIF && USBActivityIE)
9d0003f0:	3c02bf88 	lui	v0,0xbf88
9d0003f4:	8c425040 	lw	v0,20544(v0)
9d0003f8:	30420010 	andi	v0,v0,0x10
9d0003fc:	1040000b 	beqz	v0,9d00042c <USBDeviceTasks+0x138>
9d000400:	00000000 	nop
9d000404:	3c02bf88 	lui	v0,0xbf88
9d000408:	8c425050 	lw	v0,20560(v0)
9d00040c:	30420010 	andi	v0,v0,0x10
9d000410:	10400006 	beqz	v0,9d00042c <USBDeviceTasks+0x138>
9d000414:	00000000 	nop
    {
        USBClearInterruptFlag(USBActivityIFReg, USBActivityIFBitNum);
9d000418:	3c02bf88 	lui	v0,0xbf88
9d00041c:	24030010 	li	v1,16
9d000420:	ac435040 	sw	v1,20544(v0)

        USBWakeFromSuspend();
9d000424:	0f4008ed 	jal	9d0023b4 <USBCtrlEPAllowDataStage+0x10e4>
9d000428:	00000000 	nop
    }

    /*
     * Pointless to continue servicing if the device is in suspend mode.
     */
    if (USBSuspendControl == 1)
9d00042c:	3c02bf88 	lui	v0,0xbf88
9d000430:	8c425080 	lw	v0,20608(v0)
9d000434:	30420002 	andi	v0,v0,0x2
9d000438:	10400006 	beqz	v0,9d000454 <USBDeviceTasks+0x160>
9d00043c:	00000000 	nop
    {
        MUSBClearUSBInterrupt();
9d000440:	24040045 	li	a0,69
9d000444:	0f401cb3 	jal	9d0072cc <INTClearFlag>
9d000448:	00000000 	nop

        return;
9d00044c:	0b4001da 	j	9d000768 <USBDeviceTasks+0x474>
9d000450:	00000000 	nop
     *
     * The USB reset flag is masked when the USB state is in
     * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
     * cause a USB reset event during these two states.
     */
    if (USBResetIF && USBResetIE)
9d000454:	3c02bf88 	lui	v0,0xbf88
9d000458:	8c425200 	lw	v0,20992(v0)
9d00045c:	30420001 	andi	v0,v0,0x1
9d000460:	1040000d 	beqz	v0,9d000498 <USBDeviceTasks+0x1a4>
9d000464:	00000000 	nop
9d000468:	3c02bf88 	lui	v0,0xbf88
9d00046c:	8c425210 	lw	v0,21008(v0)
9d000470:	30420001 	andi	v0,v0,0x1
9d000474:	10400008 	beqz	v0,9d000498 <USBDeviceTasks+0x1a4>
9d000478:	00000000 	nop
    {
        USBDeviceInit();
9d00047c:	0f400002 	jal	9d000008 <USBDeviceInit>
9d000480:	00000000 	nop
        //Re-enable the interrupts since the USBDeviceInit() function will
        //  disable them.  This will do nothing in a polling setup
        MUSBUnmaskInterrupts();
#endif

        USBDeviceState = DEFAULT_STATE;
9d000484:	24020004 	li	v0,4
9d000488:	af828030 	sw	v0,-32720(gp)

        USBClearInterruptFlag(USBResetIFReg, USBResetIFBitNum);
9d00048c:	3c02bf88 	lui	v0,0xbf88
9d000490:	24030001 	li	v1,1
9d000494:	ac435200 	sw	v1,20992(v0)
    }

    /*
     * Task C: Service other USB interrupts
     */
    if (USBIdleIF && USBIdleIE)
9d000498:	3c02bf88 	lui	v0,0xbf88
9d00049c:	8c425200 	lw	v0,20992(v0)
9d0004a0:	30420010 	andi	v0,v0,0x10
9d0004a4:	1040000b 	beqz	v0,9d0004d4 <USBDeviceTasks+0x1e0>
9d0004a8:	00000000 	nop
9d0004ac:	3c02bf88 	lui	v0,0xbf88
9d0004b0:	8c425210 	lw	v0,21008(v0)
9d0004b4:	30420010 	andi	v0,v0,0x10
9d0004b8:	10400006 	beqz	v0,9d0004d4 <USBDeviceTasks+0x1e0>
9d0004bc:	00000000 	nop
    { 
        USBSuspend();
9d0004c0:	0f4008d4 	jal	9d002350 <USBCtrlEPAllowDataStage+0x1080>
9d0004c4:	00000000 	nop
        
        USBClearInterruptFlag(USBIdleIFReg, USBIdleIFBitNum);
9d0004c8:	3c02bf88 	lui	v0,0xbf88
9d0004cc:	24030010 	li	v1,16
9d0004d0:	ac435200 	sw	v1,20992(v0)
    }

    if (USBSOFIF)
9d0004d4:	3c02bf88 	lui	v0,0xbf88
9d0004d8:	8c425200 	lw	v0,20992(v0)
9d0004dc:	30420004 	andi	v0,v0,0x4
9d0004e0:	1040001a 	beqz	v0,9d00054c <USBDeviceTasks+0x258>
9d0004e4:	00000000 	nop
    {
        if (USBSOFIE)
9d0004e8:	3c02bf88 	lui	v0,0xbf88
9d0004ec:	8c425210 	lw	v0,21008(v0)
9d0004f0:	30420004 	andi	v0,v0,0x4
9d0004f4:	10400006 	beqz	v0,9d000510 <USBDeviceTasks+0x21c>
9d0004f8:	00000000 	nop
        {
            USB_SOF_HANDLER(EVENT_SOF, 0, 1);
9d0004fc:	24040073 	li	a0,115
9d000500:	00002821 	move	a1,zero
9d000504:	24060001 	li	a2,1
9d000508:	0f4018f1 	jal	9d0063c4 <USER_USB_CALLBACK_EVENT_HANDLER>
9d00050c:	00000000 	nop
        }    

        USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
9d000510:	3c02bf88 	lui	v0,0xbf88
9d000514:	24030004 	li	v1,4
9d000518:	ac435200 	sw	v1,20992(v0)
                //been called at least once (since the last microcontroller reset/power up), 
                //prior to executing the below code.
            #endif
            
        //Decrement our status stage counter.
        if (USBStatusStageTimeoutCounter != 0u)
9d00051c:	93828055 	lbu	v0,-32683(gp)
9d000520:	10400005 	beqz	v0,9d000538 <USBDeviceTasks+0x244>
9d000524:	00000000 	nop
        {
            USBStatusStageTimeoutCounter--;
9d000528:	93828055 	lbu	v0,-32683(gp)
9d00052c:	2442ffff 	addiu	v0,v0,-1
9d000530:	304200ff 	andi	v0,v0,0xff
9d000534:	a3828055 	sb	v0,-32683(gp)
        //Check if too much time has elapsed since progress was made in 
        //processing the control transfer, without arming the status stage.  
        //If so, auto-arm the status stage to ensure that the control 
        //transfer can [eventually] complete, within the timing limits
        //dictated by section 9.2.6 of the official USB 2.0 specifications.
        if (USBStatusStageTimeoutCounter == 0)
9d000538:	93828055 	lbu	v0,-32683(gp)
9d00053c:	14400003 	bnez	v0,9d00054c <USBDeviceTasks+0x258>
9d000540:	00000000 	nop
        {
            USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
9d000544:	0f400429 	jal	9d0010a4 <USBCtrlEPAllowStatusStage>
9d000548:	00000000 	nop
        } 
#endif
    }

    if (USBStallIF && USBStallIE)
9d00054c:	3c02bf88 	lui	v0,0xbf88
9d000550:	8c425200 	lw	v0,20992(v0)
9d000554:	30420080 	andi	v0,v0,0x80
9d000558:	10400008 	beqz	v0,9d00057c <USBDeviceTasks+0x288>
9d00055c:	00000000 	nop
9d000560:	3c02bf88 	lui	v0,0xbf88
9d000564:	8c425210 	lw	v0,21008(v0)
9d000568:	30420080 	andi	v0,v0,0x80
9d00056c:	10400003 	beqz	v0,9d00057c <USBDeviceTasks+0x288>
9d000570:	00000000 	nop
    {
        USBStallHandler();
9d000574:	0f4008a0 	jal	9d002280 <USBCtrlEPAllowDataStage+0xfb0>
9d000578:	00000000 	nop
    }

    if (USBErrorIF && USBErrorIE)
9d00057c:	3c02bf88 	lui	v0,0xbf88
9d000580:	8c425200 	lw	v0,20992(v0)
9d000584:	30420002 	andi	v0,v0,0x2
9d000588:	10400012 	beqz	v0,9d0005d4 <USBDeviceTasks+0x2e0>
9d00058c:	00000000 	nop
9d000590:	3c02bf88 	lui	v0,0xbf88
9d000594:	8c425210 	lw	v0,21008(v0)
9d000598:	30420002 	andi	v0,v0,0x2
9d00059c:	1040000d 	beqz	v0,9d0005d4 <USBDeviceTasks+0x2e0>
9d0005a0:	00000000 	nop
    {
        USB_ERROR_HANDLER(EVENT_BUS_ERROR, 0, 1);
9d0005a4:	3c027fff 	lui	v0,0x7fff
9d0005a8:	3444ffff 	ori	a0,v0,0xffff
9d0005ac:	00002821 	move	a1,zero
9d0005b0:	24060001 	li	a2,1
9d0005b4:	0f4018f1 	jal	9d0063c4 <USER_USB_CALLBACK_EVENT_HANDLER>
9d0005b8:	00000000 	nop
        MUSBClearInterruptRegister(U1EIR);               // This clears UERRIF
9d0005bc:	3c02bf88 	lui	v0,0xbf88
9d0005c0:	240300ff 	li	v1,255
9d0005c4:	ac435220 	sw	v1,21024(v0)

        // On PIC18, clearing the source of the error will automatically clear
        // the interrupt flag.  On other devices the interrupt flag must be 
        // manually cleared. 
        USBClearInterruptFlag(USBErrorIFReg, USBErrorIFBitNum);
9d0005c8:	3c02bf88 	lui	v0,0xbf88
9d0005cc:	24030002 	li	v1,2
9d0005d0:	ac435200 	sw	v1,20992(v0)
    /*
     * Pointless to continue servicing if the host has not sent a bus reset.
     * Once bus reset is received, the device transitions into the DEFAULT
     * state and is ready for communication.
     */
    if (USBDeviceState < DEFAULT_STATE)
9d0005d4:	8f828030 	lw	v0,-32720(gp)
9d0005d8:	2c420004 	sltiu	v0,v0,4
9d0005dc:	10400006 	beqz	v0,9d0005f8 <USBDeviceTasks+0x304>
9d0005e0:	00000000 	nop
    {
	    MUSBClearUSBInterrupt();
9d0005e4:	24040045 	li	a0,69
9d0005e8:	0f401cb3 	jal	9d0072cc <INTClearFlag>
9d0005ec:	00000000 	nop

	    return; 
9d0005f0:	0b4001da 	j	9d000768 <USBDeviceTasks+0x474>
9d0005f4:	00000000 	nop
	}  

    /*
     * Task D: Servicing USB Transaction Complete Interrupt
     */
    if (USBTransactionCompleteIE)
9d0005f8:	3c02bf88 	lui	v0,0xbf88
9d0005fc:	8c425210 	lw	v0,21008(v0)
9d000600:	30420008 	andi	v0,v0,0x8
9d000604:	10400055 	beqz	v0,9d00075c <USBDeviceTasks+0x468>
9d000608:	00000000 	nop
    {
	    for (i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth 
9d00060c:	a3c00010 	sb	zero,16(s8)
9d000610:	0b4001d0 	j	9d000740 <USBDeviceTasks+0x44c>
9d000614:	00000000 	nop
		{                           //utilization can be compromised, and the device won't be able to receive SETUP packets.
		    if (USBTransactionCompleteIF)
9d000618:	3c02bf88 	lui	v0,0xbf88
9d00061c:	8c425200 	lw	v0,20992(v0)
9d000620:	30420008 	andi	v0,v0,0x8
9d000624:	1040004c 	beqz	v0,9d000758 <USBDeviceTasks+0x464>
9d000628:	00000000 	nop
		    {
    		    //Save and extract USTAT register info.  Will use this info later.
                USTATcopy.Val = U1STAT;
9d00062c:	3c02bf88 	lui	v0,0xbf88
9d000630:	8c425240 	lw	v0,21056(v0)
9d000634:	304200ff 	andi	v0,v0,0xff
9d000638:	a382806c 	sb	v0,-32660(gp)
                endpoint_number = MUSBHALGetLastEndpoint(USTATcopy);
9d00063c:	9382806c 	lbu	v0,-32660(gp)
9d000640:	7c421900 	ext	v0,v0,0x4,0x4
9d000644:	304200ff 	andi	v0,v0,0xff
9d000648:	a3828035 	sb	v0,-32715(gp)
                
                USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
9d00064c:	3c02bf88 	lui	v0,0xbf88
9d000650:	24030008 	li	v1,8
9d000654:	ac435200 	sw	v1,20992(v0)

                //Keep track of the hardware ping pong state for endpoints other
                //than EP0, if ping pong buffering is enabled.
#if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) 
                if (MUSBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
9d000658:	9382806c 	lbu	v0,-32660(gp)
9d00065c:	30420008 	andi	v0,v0,0x8
9d000660:	304200ff 	andi	v0,v0,0xff
9d000664:	14400015 	bnez	v0,9d0006bc <USBDeviceTasks+0x3c8>
9d000668:	00000000 	nop
                {
                    ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
9d00066c:	93828035 	lbu	v0,-32715(gp)
9d000670:	00401821 	move	v1,v0
9d000674:	93828035 	lbu	v0,-32715(gp)
9d000678:	00402021 	move	a0,v0
9d00067c:	27828040 	addiu	v0,gp,-32704
9d000680:	00821021 	addu	v0,a0,v0
9d000684:	90420000 	lbu	v0,0(v0)
9d000688:	7c420000 	ext	v0,v0,0x0,0x1
9d00068c:	304200ff 	andi	v0,v0,0xff
9d000690:	38420001 	xori	v0,v0,0x1
9d000694:	304200ff 	andi	v0,v0,0xff
9d000698:	30420001 	andi	v0,v0,0x1
9d00069c:	304400ff 	andi	a0,v0,0xff
9d0006a0:	27828040 	addiu	v0,gp,-32704
9d0006a4:	00621821 	addu	v1,v1,v0
9d0006a8:	90620000 	lbu	v0,0(v1)
9d0006ac:	7c820004 	ins	v0,a0,0x0,0x1
9d0006b0:	a0620000 	sb	v0,0(v1)
9d0006b4:	0b4001c1 	j	9d000704 <USBDeviceTasks+0x410>
9d0006b8:	00000000 	nop
                }   
                else
                {
                    ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
9d0006bc:	93828035 	lbu	v0,-32715(gp)
9d0006c0:	00401821 	move	v1,v0
9d0006c4:	93828035 	lbu	v0,-32715(gp)
9d0006c8:	00402021 	move	a0,v0
9d0006cc:	27828060 	addiu	v0,gp,-32672
9d0006d0:	00821021 	addu	v0,a0,v0
9d0006d4:	90420000 	lbu	v0,0(v0)
9d0006d8:	7c420000 	ext	v0,v0,0x0,0x1
9d0006dc:	304200ff 	andi	v0,v0,0xff
9d0006e0:	38420001 	xori	v0,v0,0x1
9d0006e4:	304200ff 	andi	v0,v0,0xff
9d0006e8:	30420001 	andi	v0,v0,0x1
9d0006ec:	304400ff 	andi	a0,v0,0xff
9d0006f0:	27828060 	addiu	v0,gp,-32672
9d0006f4:	00621821 	addu	v1,v1,v0
9d0006f8:	90620000 	lbu	v0,0(v1)
9d0006fc:	7c820004 	ins	v0,a0,0x0,0x1
9d000700:	a0620000 	sb	v0,0(v1)
                }         
#endif    
                
                //USBCtrlEPService only services transactions over EP0.
                //It ignores all other EP transactions.
                if (endpoint_number == 0)
9d000704:	93828035 	lbu	v0,-32715(gp)
9d000708:	14400005 	bnez	v0,9d000720 <USBDeviceTasks+0x42c>
9d00070c:	00000000 	nop
                {
                    USBCtrlEPService();
9d000710:	0f400904 	jal	9d002410 <USBCtrlEPAllowDataStage+0x1140>
9d000714:	00000000 	nop
9d000718:	0b4001cd 	j	9d000734 <USBDeviceTasks+0x440>
9d00071c:	00000000 	nop
                }
                else
                {
                    USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (UINT8*)&USTATcopy.Val, 0);
9d000720:	24040072 	li	a0,114
9d000724:	2785806c 	addiu	a1,gp,-32660
9d000728:	00003021 	move	a2,zero
9d00072c:	0f4018f1 	jal	9d0063c4 <USER_USB_CALLBACK_EVENT_HANDLER>
9d000730:	00000000 	nop
    /*
     * Task D: Servicing USB Transaction Complete Interrupt
     */
    if (USBTransactionCompleteIE)
    {
	    for (i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth 
9d000734:	93c20010 	lbu	v0,16(s8)
9d000738:	24420001 	addiu	v0,v0,1
9d00073c:	a3c20010 	sb	v0,16(s8)
9d000740:	93c20010 	lbu	v0,16(s8)
9d000744:	2c420004 	sltiu	v0,v0,4
9d000748:	1440ffb3 	bnez	v0,9d000618 <USBDeviceTasks+0x324>
9d00074c:	00000000 	nop
9d000750:	0b4001d7 	j	9d00075c <USBDeviceTasks+0x468>
9d000754:	00000000 	nop
                {
                    USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (UINT8*)&USTATcopy.Val, 0);
                }
		    }//end if(USBTransactionCompleteIF)
		    else
		    	break;	//USTAT FIFO must be empty.
9d000758:	00000000 	nop
		}//end for()
	}//end if(USBTransactionCompleteIE)   

    MUSBClearUSBInterrupt();
9d00075c:	24040045 	li	a0,69
9d000760:	0f401cb3 	jal	9d0072cc <INTClearFlag>
9d000764:	00000000 	nop
}//end of USBDeviceTasks()
9d000768:	03c0e821 	move	sp,s8
9d00076c:	8fbf001c 	lw	ra,28(sp)
9d000770:	8fbe0018 	lw	s8,24(sp)
9d000774:	27bd0020 	addiu	sp,sp,32
9d000778:	03e00008 	jr	ra
9d00077c:	00000000 	nop

9d000780 <USBEnableEndpoint>:
    None
  Remarks:
    None                                                                                                          
  *****************************************************************************/
void USBEnableEndpoint(UINT8 ep, UINT8 options)
{
9d000780:	27bdffe0 	addiu	sp,sp,-32
9d000784:	afbf001c 	sw	ra,28(sp)
9d000788:	afbe0018 	sw	s8,24(sp)
9d00078c:	03a0f021 	move	s8,sp
9d000790:	00801821 	move	v1,a0
9d000794:	00a01021 	move	v0,a1
9d000798:	a3c30020 	sb	v1,32(s8)
9d00079c:	a3c20024 	sb	v0,36(s8)
    UINT8* p;
        
    //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
    //starting DTS state in the BDT entry.
    if (options & USB_OUT_ENABLED)
9d0007a0:	93c20024 	lbu	v0,36(s8)
9d0007a4:	30420008 	andi	v0,v0,0x8
9d0007a8:	10400006 	beqz	v0,9d0007c4 <USBEnableEndpoint+0x44>
9d0007ac:	00000000 	nop
    {
        USBConfigureEndpoint(ep, OUT_FROM_HOST);
9d0007b0:	93c20020 	lbu	v0,32(s8)
9d0007b4:	00402021 	move	a0,v0
9d0007b8:	00002821 	move	a1,zero
9d0007bc:	0f400526 	jal	9d001498 <USBCtrlEPAllowDataStage+0x1c8>
9d0007c0:	00000000 	nop
    }

    if (options & USB_IN_ENABLED)
9d0007c4:	93c20024 	lbu	v0,36(s8)
9d0007c8:	30420004 	andi	v0,v0,0x4
9d0007cc:	10400006 	beqz	v0,9d0007e8 <USBEnableEndpoint+0x68>
9d0007d0:	00000000 	nop
    {
        USBConfigureEndpoint(ep, IN_TO_HOST);
9d0007d4:	93c20020 	lbu	v0,32(s8)
9d0007d8:	00402021 	move	a0,v0
9d0007dc:	24050001 	li	a1,1
9d0007e0:	0f400526 	jal	9d001498 <USBCtrlEPAllowDataStage+0x1c8>
9d0007e4:	00000000 	nop
    }

    //Update the relevant UEPx register to actually enable the endpoint with
    //the specified options (ex: handshaking enabled, control transfers allowed,
    //etc.)
    p = (UINT8*)(&U1EP0 + (4 * ep));
9d0007e8:	3c02bf88 	lui	v0,0xbf88
9d0007ec:	24435300 	addiu	v1,v0,21248
9d0007f0:	93c20020 	lbu	v0,32(s8)
9d0007f4:	00021100 	sll	v0,v0,0x4
9d0007f8:	00621021 	addu	v0,v1,v0
9d0007fc:	afc20010 	sw	v0,16(s8)

    *p = options;
9d000800:	8fc20010 	lw	v0,16(s8)
9d000804:	93c30024 	lbu	v1,36(s8)
9d000808:	a0430000 	sb	v1,0(v0)
}
9d00080c:	03c0e821 	move	sp,s8
9d000810:	8fbf001c 	lw	ra,28(sp)
9d000814:	8fbe0018 	lw	s8,24(sp)
9d000818:	27bd0020 	addiu	sp,sp,32
9d00081c:	03e00008 	jr	ra
9d000820:	00000000 	nop

9d000824 <USBTransferOnePacket>:
    endpoint has been enabled and initialized by the USBEnableEndpoint() 
    function first.  
    
  *************************************************************************/
USB_HANDLE USBTransferOnePacket(UINT8 ep, UINT8 dir, UINT8* data, UINT8 len)
{
9d000824:	27bdfff0 	addiu	sp,sp,-16
9d000828:	afbe000c 	sw	s8,12(sp)
9d00082c:	03a0f021 	move	s8,sp
9d000830:	00a01821 	move	v1,a1
9d000834:	afc60018 	sw	a2,24(s8)
9d000838:	00e01021 	move	v0,a3
9d00083c:	a3c40010 	sb	a0,16(s8)
9d000840:	a3c30014 	sb	v1,20(s8)
9d000844:	a3c2001c 	sb	v0,28(s8)
    volatile BDT_ENTRY* handle;

    //If the direction is IN
    if (dir != 0)
9d000848:	93c20014 	lbu	v0,20(s8)
9d00084c:	10400009 	beqz	v0,9d000874 <USBTransferOnePacket+0x50>
9d000850:	00000000 	nop
    {
        //point to the IN BDT of the specified endpoint
        handle = pBDTEntryIn[ep];
9d000854:	93c20010 	lbu	v0,16(s8)
9d000858:	00021880 	sll	v1,v0,0x2
9d00085c:	27828038 	addiu	v0,gp,-32712
9d000860:	00621021 	addu	v0,v1,v0
9d000864:	8c420000 	lw	v0,0(v0)
9d000868:	afc20000 	sw	v0,0(s8)
9d00086c:	0b400223 	j	9d00088c <USBTransferOnePacket+0x68>
9d000870:	00000000 	nop
    }
    else
    {
        //else point to the OUT BDT of the specified endpoint
        handle = pBDTEntryOut[ep];
9d000874:	93c20010 	lbu	v0,16(s8)
9d000878:	00021880 	sll	v1,v0,0x2
9d00087c:	27828044 	addiu	v0,gp,-32700
9d000880:	00621021 	addu	v0,v1,v0
9d000884:	8c420000 	lw	v0,0(v0)
9d000888:	afc20000 	sw	v0,0(s8)
    }
    
    //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
    //pBDTEntryOut[ep]) is initialized before using it.
    if (handle == 0)
9d00088c:	8fc20000 	lw	v0,0(s8)
9d000890:	14400004 	bnez	v0,9d0008a4 <USBTransferOnePacket+0x80>
9d000894:	00000000 	nop
    {
	    return 0;
9d000898:	00001021 	move	v0,zero
9d00089c:	0b40029e 	j	9d000a78 <USBTransferOnePacket+0x254>
9d0008a0:	00000000 	nop
        handle->STAT.Val ^= _DTSMASK;
    }
#endif

    //Set the data pointer, data length, and enable the endpoint
    handle->ADR = MConvertToPhysicalAddress(data);
9d0008a4:	8fc20018 	lw	v0,24(s8)
9d0008a8:	7c43e000 	ext	v1,v0,0x0,0x1d
9d0008ac:	8fc20000 	lw	v0,0(s8)
9d0008b0:	306400ff 	andi	a0,v1,0xff
9d0008b4:	90450004 	lbu	a1,4(v0)
9d0008b8:	30a50000 	andi	a1,a1,0x0
9d0008bc:	00a42025 	or	a0,a1,a0
9d0008c0:	a0440004 	sb	a0,4(v0)
9d0008c4:	00032202 	srl	a0,v1,0x8
9d0008c8:	308400ff 	andi	a0,a0,0xff
9d0008cc:	90450005 	lbu	a1,5(v0)
9d0008d0:	30a50000 	andi	a1,a1,0x0
9d0008d4:	00a42025 	or	a0,a1,a0
9d0008d8:	a0440005 	sb	a0,5(v0)
9d0008dc:	00032402 	srl	a0,v1,0x10
9d0008e0:	308400ff 	andi	a0,a0,0xff
9d0008e4:	90450006 	lbu	a1,6(v0)
9d0008e8:	30a50000 	andi	a1,a1,0x0
9d0008ec:	00a42025 	or	a0,a1,a0
9d0008f0:	a0440006 	sb	a0,6(v0)
9d0008f4:	00031e02 	srl	v1,v1,0x18
9d0008f8:	90440007 	lbu	a0,7(v0)
9d0008fc:	30840000 	andi	a0,a0,0x0
9d000900:	00831825 	or	v1,a0,v1
9d000904:	a0430007 	sb	v1,7(v0)
    handle->CNT = len;
9d000908:	93c2001c 	lbu	v0,28(s8)
9d00090c:	304203ff 	andi	v0,v0,0x3ff
9d000910:	3043ffff 	andi	v1,v0,0xffff
9d000914:	8fc20000 	lw	v0,0(s8)
9d000918:	306400ff 	andi	a0,v1,0xff
9d00091c:	90450002 	lbu	a1,2(v0)
9d000920:	30a50000 	andi	a1,a1,0x0
9d000924:	00a42025 	or	a0,a1,a0
9d000928:	a0440002 	sb	a0,2(v0)
9d00092c:	00031a02 	srl	v1,v1,0x8
9d000930:	3063ffff 	andi	v1,v1,0xffff
9d000934:	30630003 	andi	v1,v1,0x3
9d000938:	30630003 	andi	v1,v1,0x3
9d00093c:	90450003 	lbu	a1,3(v0)
9d000940:	2404fffc 	li	a0,-4
9d000944:	00a42024 	and	a0,a1,a0
9d000948:	00831825 	or	v1,a0,v1
9d00094c:	a0430003 	sb	v1,3(v0)
    handle->STAT.Val &= _DTSMASK;
9d000950:	8fc20000 	lw	v0,0(s8)
9d000954:	90430000 	lbu	v1,0(v0)
9d000958:	306300ff 	andi	v1,v1,0xff
9d00095c:	90420001 	lbu	v0,1(v0)
9d000960:	304200ff 	andi	v0,v0,0xff
9d000964:	00021200 	sll	v0,v0,0x8
9d000968:	00431025 	or	v0,v0,v1
9d00096c:	3042ffff 	andi	v0,v0,0xffff
9d000970:	30420040 	andi	v0,v0,0x40
9d000974:	3043ffff 	andi	v1,v0,0xffff
9d000978:	8fc20000 	lw	v0,0(s8)
9d00097c:	306400ff 	andi	a0,v1,0xff
9d000980:	90450000 	lbu	a1,0(v0)
9d000984:	30a50000 	andi	a1,a1,0x0
9d000988:	00a42025 	or	a0,a1,a0
9d00098c:	a0440000 	sb	a0,0(v0)
9d000990:	00031a02 	srl	v1,v1,0x8
9d000994:	3063ffff 	andi	v1,v1,0xffff
9d000998:	90440001 	lbu	a0,1(v0)
9d00099c:	30840000 	andi	a0,a0,0x0
9d0009a0:	00831825 	or	v1,a0,v1
9d0009a4:	a0430001 	sb	v1,1(v0)
    handle->STAT.Val |= _USIE | (_DTSEN & _DTS_CHECKING_ENABLED);
9d0009a8:	8fc20000 	lw	v0,0(s8)
9d0009ac:	90430000 	lbu	v1,0(v0)
9d0009b0:	306300ff 	andi	v1,v1,0xff
9d0009b4:	90420001 	lbu	v0,1(v0)
9d0009b8:	304200ff 	andi	v0,v0,0xff
9d0009bc:	00021200 	sll	v0,v0,0x8
9d0009c0:	00431025 	or	v0,v0,v1
9d0009c4:	3042ffff 	andi	v0,v0,0xffff
9d0009c8:	34420088 	ori	v0,v0,0x88
9d0009cc:	3043ffff 	andi	v1,v0,0xffff
9d0009d0:	8fc20000 	lw	v0,0(s8)
9d0009d4:	306400ff 	andi	a0,v1,0xff
9d0009d8:	90450000 	lbu	a1,0(v0)
9d0009dc:	30a50000 	andi	a1,a1,0x0
9d0009e0:	00a42025 	or	a0,a1,a0
9d0009e4:	a0440000 	sb	a0,0(v0)
9d0009e8:	00031a02 	srl	v1,v1,0x8
9d0009ec:	3063ffff 	andi	v1,v1,0xffff
9d0009f0:	90440001 	lbu	a0,1(v0)
9d0009f4:	30840000 	andi	a0,a0,0x0
9d0009f8:	00831825 	or	v1,a0,v1
9d0009fc:	a0430001 	sb	v1,1(v0)

    //Point to the next buffer for ping pong purposes.
    if (dir != OUT_FROM_HOST)
9d000a00:	93c20014 	lbu	v0,20(s8)
9d000a04:	1040000f 	beqz	v0,9d000a44 <USBTransferOnePacket+0x220>
9d000a08:	00000000 	nop
    {
        //toggle over the to the next buffer for an IN endpoint
        USBAdvancePingPongBuffer(&pBDTEntryIn[ep]);      
9d000a0c:	27838038 	addiu	v1,gp,-32712
9d000a10:	93c20010 	lbu	v0,16(s8)
9d000a14:	00021080 	sll	v0,v0,0x2
9d000a18:	00621021 	addu	v0,v1,v0
9d000a1c:	27848038 	addiu	a0,gp,-32712
9d000a20:	93c30010 	lbu	v1,16(s8)
9d000a24:	00031880 	sll	v1,v1,0x2
9d000a28:	00831821 	addu	v1,a0,v1
9d000a2c:	90630000 	lbu	v1,0(v1)
9d000a30:	38630008 	xori	v1,v1,0x8
9d000a34:	306300ff 	andi	v1,v1,0xff
9d000a38:	a0430000 	sb	v1,0(v0)
9d000a3c:	0b40029d 	j	9d000a74 <USBTransferOnePacket+0x250>
9d000a40:	00000000 	nop
    }
    else
    {
        //toggle over the to the next buffer for an OUT endpoint
        USBAdvancePingPongBuffer(&pBDTEntryOut[ep]);     
9d000a44:	27838044 	addiu	v1,gp,-32700
9d000a48:	93c20010 	lbu	v0,16(s8)
9d000a4c:	00021080 	sll	v0,v0,0x2
9d000a50:	00621021 	addu	v0,v1,v0
9d000a54:	27848044 	addiu	a0,gp,-32700
9d000a58:	93c30010 	lbu	v1,16(s8)
9d000a5c:	00031880 	sll	v1,v1,0x2
9d000a60:	00831821 	addu	v1,a0,v1
9d000a64:	90630000 	lbu	v1,0(v1)
9d000a68:	38630008 	xori	v1,v1,0x8
9d000a6c:	306300ff 	andi	v1,v1,0xff
9d000a70:	a0430000 	sb	v1,0(v0)
    }

    return (USB_HANDLE)handle;
9d000a74:	8fc20000 	lw	v0,0(s8)
}
9d000a78:	03c0e821 	move	sp,s8
9d000a7c:	8fbe000c 	lw	s8,12(sp)
9d000a80:	27bd0010 	addiu	sp,sp,16
9d000a84:	03e00008 	jr	ra
9d000a88:	00000000 	nop

9d000a8c <USBStallEndpoint>:
    Remarks:
        None

 *******************************************************************/
void USBStallEndpoint(UINT8 ep, UINT8 dir)
{
9d000a8c:	27bdfff0 	addiu	sp,sp,-16
9d000a90:	afbe000c 	sw	s8,12(sp)
9d000a94:	03a0f021 	move	s8,sp
9d000a98:	00801821 	move	v1,a0
9d000a9c:	00a01021 	move	v0,a1
9d000aa0:	a3c30010 	sb	v1,16(s8)
9d000aa4:	a3c20014 	sb	v0,20(s8)
    BDT_ENTRY *p;

    if (ep == 0)
9d000aa8:	93c20010 	lbu	v0,16(s8)
9d000aac:	14400039 	bnez	v0,9d000b94 <USBStallEndpoint+0x108>
9d000ab0:	00000000 	nop
    {
        //For control endpoints (ex: EP0), we need to STALL both IN and OUT
        //endpoints.  EP0 OUT must also be prepared to receive the next SETUP 
        //packet that will arrive.
        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9d000ab4:	8f828050 	lw	v0,-32688(gp)
9d000ab8:	90430002 	lbu	v1,2(v0)
9d000abc:	30630000 	andi	v1,v1,0x0
9d000ac0:	34630040 	ori	v1,v1,0x40
9d000ac4:	a0430002 	sb	v1,2(v0)
9d000ac8:	90440003 	lbu	a0,3(v0)
9d000acc:	2403fffc 	li	v1,-4
9d000ad0:	00831824 	and	v1,a0,v1
9d000ad4:	a0430003 	sb	v1,3(v0)
        pBDTEntryEP0OutNext->ADR = MConvertToPhysicalAddress(&SetupPkt);
9d000ad8:	8f828050 	lw	v0,-32688(gp)
9d000adc:	27838058 	addiu	v1,gp,-32680
9d000ae0:	7c63e000 	ext	v1,v1,0x0,0x1d
9d000ae4:	306400ff 	andi	a0,v1,0xff
9d000ae8:	90450004 	lbu	a1,4(v0)
9d000aec:	30a50000 	andi	a1,a1,0x0
9d000af0:	00a42025 	or	a0,a1,a0
9d000af4:	a0440004 	sb	a0,4(v0)
9d000af8:	00032202 	srl	a0,v1,0x8
9d000afc:	308400ff 	andi	a0,a0,0xff
9d000b00:	90450005 	lbu	a1,5(v0)
9d000b04:	30a50000 	andi	a1,a1,0x0
9d000b08:	00a42025 	or	a0,a1,a0
9d000b0c:	a0440005 	sb	a0,5(v0)
9d000b10:	00032402 	srl	a0,v1,0x10
9d000b14:	308400ff 	andi	a0,a0,0xff
9d000b18:	90450006 	lbu	a1,6(v0)
9d000b1c:	30a50000 	andi	a1,a1,0x0
9d000b20:	00a42025 	or	a0,a1,a0
9d000b24:	a0440006 	sb	a0,6(v0)
9d000b28:	00031e02 	srl	v1,v1,0x18
9d000b2c:	90440007 	lbu	a0,7(v0)
9d000b30:	30840000 	andi	a0,a0,0x0
9d000b34:	00831825 	or	v1,a0,v1
9d000b38:	a0430007 	sb	v1,7(v0)
        pBDTEntryEP0OutNext->STAT.Val = _USIE | _DAT0 | (_DTSEN & _DTS_CHECKING_ENABLED) | _BSTALL;
9d000b3c:	8f828050 	lw	v0,-32688(gp)
9d000b40:	90430000 	lbu	v1,0(v0)
9d000b44:	30630000 	andi	v1,v1,0x0
9d000b48:	00602021 	move	a0,v1
9d000b4c:	2403ff8c 	li	v1,-116
9d000b50:	00831825 	or	v1,a0,v1
9d000b54:	a0430000 	sb	v1,0(v0)
9d000b58:	90430001 	lbu	v1,1(v0)
9d000b5c:	30630000 	andi	v1,v1,0x0
9d000b60:	a0430001 	sb	v1,1(v0)
        pBDTEntryIn[0]->STAT.Val = _USIE | _BSTALL; 
9d000b64:	8f828038 	lw	v0,-32712(gp)
9d000b68:	90430000 	lbu	v1,0(v0)
9d000b6c:	30630000 	andi	v1,v1,0x0
9d000b70:	00602021 	move	a0,v1
9d000b74:	2403ff84 	li	v1,-124
9d000b78:	00831825 	or	v1,a0,v1
9d000b7c:	a0430000 	sb	v1,0(v0)
9d000b80:	90430001 	lbu	v1,1(v0)
9d000b84:	30630000 	andi	v1,v1,0x0
9d000b88:	a0430001 	sb	v1,1(v0)
9d000b8c:	0b400321 	j	9d000c84 <USBStallEndpoint+0x1f8>
9d000b90:	00000000 	nop
    }
    else
    {
        p = (BDT_ENTRY*)(&BDT[EP(ep, dir, 0)]);
9d000b94:	93c20010 	lbu	v0,16(s8)
9d000b98:	00021840 	sll	v1,v0,0x1
9d000b9c:	93c20014 	lbu	v0,20(s8)
9d000ba0:	00621021 	addu	v0,v1,v0
9d000ba4:	00021100 	sll	v0,v0,0x4
9d000ba8:	00401821 	move	v1,v0
9d000bac:	3c02a000 	lui	v0,0xa000
9d000bb0:	24420200 	addiu	v0,v0,512
9d000bb4:	00621021 	addu	v0,v1,v0
9d000bb8:	afc20000 	sw	v0,0(s8)

        p->STAT.Val |= _BSTALL | _USIE;
9d000bbc:	8fc20000 	lw	v0,0(s8)
9d000bc0:	90430000 	lbu	v1,0(v0)
9d000bc4:	90420001 	lbu	v0,1(v0)
9d000bc8:	00021200 	sll	v0,v0,0x8
9d000bcc:	00431025 	or	v0,v0,v1
9d000bd0:	3042ffff 	andi	v0,v0,0xffff
9d000bd4:	34420084 	ori	v0,v0,0x84
9d000bd8:	3043ffff 	andi	v1,v0,0xffff
9d000bdc:	8fc20000 	lw	v0,0(s8)
9d000be0:	306400ff 	andi	a0,v1,0xff
9d000be4:	90450000 	lbu	a1,0(v0)
9d000be8:	30a50000 	andi	a1,a1,0x0
9d000bec:	00a42025 	or	a0,a1,a0
9d000bf0:	a0440000 	sb	a0,0(v0)
9d000bf4:	00031a02 	srl	v1,v1,0x8
9d000bf8:	3063ffff 	andi	v1,v1,0xffff
9d000bfc:	90440001 	lbu	a0,1(v0)
9d000c00:	30840000 	andi	a0,a0,0x0
9d000c04:	00831825 	or	v1,a0,v1
9d000c08:	a0430001 	sb	v1,1(v0)

        //If the device is in FULL or ALL_BUT_EP0 ping pong modes
        //then stall that entry as well
#if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
        p = (BDT_ENTRY*)(&BDT[EP(ep, dir, 1)]);
9d000c0c:	93c20010 	lbu	v0,16(s8)
9d000c10:	00021840 	sll	v1,v0,0x1
9d000c14:	93c20014 	lbu	v0,20(s8)
9d000c18:	00621021 	addu	v0,v1,v0
9d000c1c:	00021100 	sll	v0,v0,0x4
9d000c20:	24430008 	addiu	v1,v0,8
9d000c24:	3c02a000 	lui	v0,0xa000
9d000c28:	24420200 	addiu	v0,v0,512
9d000c2c:	00621021 	addu	v0,v1,v0
9d000c30:	afc20000 	sw	v0,0(s8)

        p->STAT.Val |= _BSTALL | _USIE;
9d000c34:	8fc20000 	lw	v0,0(s8)
9d000c38:	90430000 	lbu	v1,0(v0)
9d000c3c:	90420001 	lbu	v0,1(v0)
9d000c40:	00021200 	sll	v0,v0,0x8
9d000c44:	00431025 	or	v0,v0,v1
9d000c48:	3042ffff 	andi	v0,v0,0xffff
9d000c4c:	34420084 	ori	v0,v0,0x84
9d000c50:	3043ffff 	andi	v1,v0,0xffff
9d000c54:	8fc20000 	lw	v0,0(s8)
9d000c58:	306400ff 	andi	a0,v1,0xff
9d000c5c:	90450000 	lbu	a1,0(v0)
9d000c60:	30a50000 	andi	a1,a1,0x0
9d000c64:	00a42025 	or	a0,a1,a0
9d000c68:	a0440000 	sb	a0,0(v0)
9d000c6c:	00031a02 	srl	v1,v1,0x8
9d000c70:	3063ffff 	andi	v1,v1,0xffff
9d000c74:	90440001 	lbu	a0,1(v0)
9d000c78:	30840000 	andi	a0,a0,0x0
9d000c7c:	00831825 	or	v1,a0,v1
9d000c80:	a0430001 	sb	v1,1(v0)
#endif
    }
}
9d000c84:	03c0e821 	move	sp,s8
9d000c88:	8fbe000c 	lw	s8,12(sp)
9d000c8c:	27bd0010 	addiu	sp,sp,16
9d000c90:	03e00008 	jr	ra
9d000c94:	00000000 	nop

9d000c98 <USBCancelIO>:
    Remarks:
        None
                                                          
  **************************************************************************/
void USBCancelIO(UINT8 endpoint)
{
9d000c98:	27bdfff8 	addiu	sp,sp,-8
9d000c9c:	afbe0004 	sw	s8,4(sp)
9d000ca0:	03a0f021 	move	s8,sp
9d000ca4:	00801021 	move	v0,a0
9d000ca8:	a3c20008 	sb	v0,8(s8)
    if (USBPacketDisable == 1)
9d000cac:	3c02bf88 	lui	v0,0xbf88
9d000cb0:	8c425250 	lw	v0,21072(v0)
9d000cb4:	30420020 	andi	v0,v0,0x20
9d000cb8:	104000f5 	beqz	v0,9d001090 <USBCancelIO+0x3f8>
9d000cbc:	00000000 	nop
    {
    	//The PKTDIS bit is currently set right now.  It is therefore "safe"
    	//to mess with the BDT right now.
    	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
9d000cc0:	93c20008 	lbu	v0,8(s8)
9d000cc4:	00021880 	sll	v1,v0,0x2
9d000cc8:	27828038 	addiu	v0,gp,-32712
9d000ccc:	00621021 	addu	v0,v1,v0
9d000cd0:	8c420000 	lw	v0,0(v0)
9d000cd4:	93c30008 	lbu	v1,8(s8)
9d000cd8:	00032080 	sll	a0,v1,0x2
9d000cdc:	27838038 	addiu	v1,gp,-32712
9d000ce0:	00831821 	addu	v1,a0,v1
9d000ce4:	8c630000 	lw	v1,0(v1)
9d000ce8:	906a0000 	lbu	t2,0(v1)
9d000cec:	314a00ff 	andi	t2,t2,0xff
9d000cf0:	906b0001 	lbu	t3,1(v1)
9d000cf4:	316b00ff 	andi	t3,t3,0xff
9d000cf8:	000b5a00 	sll	t3,t3,0x8
9d000cfc:	016a5025 	or	t2,t3,t2
9d000d00:	906b0002 	lbu	t3,2(v1)
9d000d04:	316b00ff 	andi	t3,t3,0xff
9d000d08:	000b5c00 	sll	t3,t3,0x10
9d000d0c:	016a5025 	or	t2,t3,t2
9d000d10:	906b0003 	lbu	t3,3(v1)
9d000d14:	316b00ff 	andi	t3,t3,0xff
9d000d18:	000b5e00 	sll	t3,t3,0x18
9d000d1c:	016a5025 	or	t2,t3,t2
9d000d20:	01402021 	move	a0,t2
9d000d24:	906a0004 	lbu	t2,4(v1)
9d000d28:	314a00ff 	andi	t2,t2,0xff
9d000d2c:	906b0005 	lbu	t3,5(v1)
9d000d30:	316b00ff 	andi	t3,t3,0xff
9d000d34:	000b5a00 	sll	t3,t3,0x8
9d000d38:	016a5025 	or	t2,t3,t2
9d000d3c:	906b0006 	lbu	t3,6(v1)
9d000d40:	316b00ff 	andi	t3,t3,0xff
9d000d44:	000b5c00 	sll	t3,t3,0x10
9d000d48:	016a5025 	or	t2,t3,t2
9d000d4c:	90630007 	lbu	v1,7(v1)
9d000d50:	306300ff 	andi	v1,v1,0xff
9d000d54:	00031e00 	sll	v1,v1,0x18
9d000d58:	006a1825 	or	v1,v1,t2
9d000d5c:	00602821 	move	a1,v1
9d000d60:	30880040 	andi	t0,a0,0x40
9d000d64:	30a90000 	andi	t1,a1,0x0
9d000d68:	310300ff 	andi	v1,t0,0xff
9d000d6c:	90440000 	lbu	a0,0(v0)
9d000d70:	30840000 	andi	a0,a0,0x0
9d000d74:	00831825 	or	v1,a0,v1
9d000d78:	a0430000 	sb	v1,0(v0)
9d000d7c:	00081a02 	srl	v1,t0,0x8
9d000d80:	306300ff 	andi	v1,v1,0xff
9d000d84:	90440001 	lbu	a0,1(v0)
9d000d88:	30840000 	andi	a0,a0,0x0
9d000d8c:	00831825 	or	v1,a0,v1
9d000d90:	a0430001 	sb	v1,1(v0)
9d000d94:	00081c02 	srl	v1,t0,0x10
9d000d98:	306300ff 	andi	v1,v1,0xff
9d000d9c:	90440002 	lbu	a0,2(v0)
9d000da0:	30840000 	andi	a0,a0,0x0
9d000da4:	00831825 	or	v1,a0,v1
9d000da8:	a0430002 	sb	v1,2(v0)
9d000dac:	00081e02 	srl	v1,t0,0x18
9d000db0:	90440003 	lbu	a0,3(v0)
9d000db4:	30840000 	andi	a0,a0,0x0
9d000db8:	00831825 	or	v1,a0,v1
9d000dbc:	a0430003 	sb	v1,3(v0)
9d000dc0:	312300ff 	andi	v1,t1,0xff
9d000dc4:	90440004 	lbu	a0,4(v0)
9d000dc8:	30840000 	andi	a0,a0,0x0
9d000dcc:	00831825 	or	v1,a0,v1
9d000dd0:	a0430004 	sb	v1,4(v0)
9d000dd4:	00091a02 	srl	v1,t1,0x8
9d000dd8:	306300ff 	andi	v1,v1,0xff
9d000ddc:	90440005 	lbu	a0,5(v0)
9d000de0:	30840000 	andi	a0,a0,0x0
9d000de4:	00831825 	or	v1,a0,v1
9d000de8:	a0430005 	sb	v1,5(v0)
9d000dec:	00091c02 	srl	v1,t1,0x10
9d000df0:	306300ff 	andi	v1,v1,0xff
9d000df4:	90440006 	lbu	a0,6(v0)
9d000df8:	30840000 	andi	a0,a0,0x0
9d000dfc:	00831825 	or	v1,a0,v1
9d000e00:	a0430006 	sb	v1,6(v0)
9d000e04:	00091e02 	srl	v1,t1,0x18
9d000e08:	90440007 	lbu	a0,7(v0)
9d000e0c:	30840000 	andi	a0,a0,0x0
9d000e10:	00831825 	or	v1,a0,v1
9d000e14:	a0430007 	sb	v1,7(v0)
    	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
9d000e18:	93c20008 	lbu	v0,8(s8)
9d000e1c:	00021880 	sll	v1,v0,0x2
9d000e20:	27828038 	addiu	v0,gp,-32712
9d000e24:	00621021 	addu	v0,v1,v0
9d000e28:	8c420000 	lw	v0,0(v0)
9d000e2c:	93c30008 	lbu	v1,8(s8)
9d000e30:	00032080 	sll	a0,v1,0x2
9d000e34:	27838038 	addiu	v1,gp,-32712
9d000e38:	00831821 	addu	v1,a0,v1
9d000e3c:	8c630000 	lw	v1,0(v1)
9d000e40:	90680000 	lbu	t0,0(v1)
9d000e44:	310800ff 	andi	t0,t0,0xff
9d000e48:	90690001 	lbu	t1,1(v1)
9d000e4c:	312900ff 	andi	t1,t1,0xff
9d000e50:	00094a00 	sll	t1,t1,0x8
9d000e54:	01284025 	or	t0,t1,t0
9d000e58:	90690002 	lbu	t1,2(v1)
9d000e5c:	312900ff 	andi	t1,t1,0xff
9d000e60:	00094c00 	sll	t1,t1,0x10
9d000e64:	01284025 	or	t0,t1,t0
9d000e68:	90690003 	lbu	t1,3(v1)
9d000e6c:	312900ff 	andi	t1,t1,0xff
9d000e70:	00094e00 	sll	t1,t1,0x18
9d000e74:	01284025 	or	t0,t1,t0
9d000e78:	01002021 	move	a0,t0
9d000e7c:	90680004 	lbu	t0,4(v1)
9d000e80:	310800ff 	andi	t0,t0,0xff
9d000e84:	90690005 	lbu	t1,5(v1)
9d000e88:	312900ff 	andi	t1,t1,0xff
9d000e8c:	00094a00 	sll	t1,t1,0x8
9d000e90:	01284025 	or	t0,t1,t0
9d000e94:	90690006 	lbu	t1,6(v1)
9d000e98:	312900ff 	andi	t1,t1,0xff
9d000e9c:	00094c00 	sll	t1,t1,0x10
9d000ea0:	01284025 	or	t0,t1,t0
9d000ea4:	90630007 	lbu	v1,7(v1)
9d000ea8:	306300ff 	andi	v1,v1,0xff
9d000eac:	00031e00 	sll	v1,v1,0x18
9d000eb0:	00681825 	or	v1,v1,t0
9d000eb4:	00602821 	move	a1,v1
9d000eb8:	38860040 	xori	a2,a0,0x40
9d000ebc:	38a70000 	xori	a3,a1,0x0
9d000ec0:	30c300ff 	andi	v1,a2,0xff
9d000ec4:	90440000 	lbu	a0,0(v0)
9d000ec8:	30840000 	andi	a0,a0,0x0
9d000ecc:	00831825 	or	v1,a0,v1
9d000ed0:	a0430000 	sb	v1,0(v0)
9d000ed4:	00061a02 	srl	v1,a2,0x8
9d000ed8:	306300ff 	andi	v1,v1,0xff
9d000edc:	90440001 	lbu	a0,1(v0)
9d000ee0:	30840000 	andi	a0,a0,0x0
9d000ee4:	00831825 	or	v1,a0,v1
9d000ee8:	a0430001 	sb	v1,1(v0)
9d000eec:	00061c02 	srl	v1,a2,0x10
9d000ef0:	306300ff 	andi	v1,v1,0xff
9d000ef4:	90440002 	lbu	a0,2(v0)
9d000ef8:	30840000 	andi	a0,a0,0x0
9d000efc:	00831825 	or	v1,a0,v1
9d000f00:	a0430002 	sb	v1,2(v0)
9d000f04:	00061e02 	srl	v1,a2,0x18
9d000f08:	90440003 	lbu	a0,3(v0)
9d000f0c:	30840000 	andi	a0,a0,0x0
9d000f10:	00831825 	or	v1,a0,v1
9d000f14:	a0430003 	sb	v1,3(v0)
9d000f18:	30e300ff 	andi	v1,a3,0xff
9d000f1c:	90440004 	lbu	a0,4(v0)
9d000f20:	30840000 	andi	a0,a0,0x0
9d000f24:	00831825 	or	v1,a0,v1
9d000f28:	a0430004 	sb	v1,4(v0)
9d000f2c:	00071a02 	srl	v1,a3,0x8
9d000f30:	306300ff 	andi	v1,v1,0xff
9d000f34:	90440005 	lbu	a0,5(v0)
9d000f38:	30840000 	andi	a0,a0,0x0
9d000f3c:	00831825 	or	v1,a0,v1
9d000f40:	a0430005 	sb	v1,5(v0)
9d000f44:	00071c02 	srl	v1,a3,0x10
9d000f48:	306300ff 	andi	v1,v1,0xff
9d000f4c:	90440006 	lbu	a0,6(v0)
9d000f50:	30840000 	andi	a0,a0,0x0
9d000f54:	00831825 	or	v1,a0,v1
9d000f58:	a0430006 	sb	v1,6(v0)
9d000f5c:	00071e02 	srl	v1,a3,0x18
9d000f60:	90440007 	lbu	a0,7(v0)
9d000f64:	30840000 	andi	a0,a0,0x0
9d000f68:	00831825 	or	v1,a0,v1
9d000f6c:	a0430007 	sb	v1,7(v0)
    	//Need to do additional handling if ping-pong buffering is being used
#if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
        //Point to the next buffer for ping pong purposes.  UOWN getting cleared
        //(either due to SIE clearing it after a transaction, or the firmware
        //clearing it) makes hardware ping pong pointer advance.
        USBAdvancePingPongBuffer(&pBDTEntryIn[endpoint]);       
9d000f70:	27838038 	addiu	v1,gp,-32712
9d000f74:	93c20008 	lbu	v0,8(s8)
9d000f78:	00021080 	sll	v0,v0,0x2
9d000f7c:	00621021 	addu	v0,v1,v0
9d000f80:	27848038 	addiu	a0,gp,-32712
9d000f84:	93c30008 	lbu	v1,8(s8)
9d000f88:	00031880 	sll	v1,v1,0x2
9d000f8c:	00831821 	addu	v1,a0,v1
9d000f90:	90630000 	lbu	v1,0(v1)
9d000f94:	38630008 	xori	v1,v1,0x8
9d000f98:	306300ff 	andi	v1,v1,0xff
9d000f9c:	a0430000 	sb	v1,0(v0)
    
    	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
9d000fa0:	93c20008 	lbu	v0,8(s8)
9d000fa4:	00021880 	sll	v1,v0,0x2
9d000fa8:	27828038 	addiu	v0,gp,-32712
9d000fac:	00621021 	addu	v0,v1,v0
9d000fb0:	8c420000 	lw	v0,0(v0)
9d000fb4:	93c30008 	lbu	v1,8(s8)
9d000fb8:	00032080 	sll	a0,v1,0x2
9d000fbc:	27838038 	addiu	v1,gp,-32712
9d000fc0:	00831821 	addu	v1,a0,v1
9d000fc4:	8c630000 	lw	v1,0(v1)
9d000fc8:	90640000 	lbu	a0,0(v1)
9d000fcc:	308400ff 	andi	a0,a0,0xff
9d000fd0:	90630001 	lbu	v1,1(v1)
9d000fd4:	306300ff 	andi	v1,v1,0xff
9d000fd8:	00031a00 	sll	v1,v1,0x8
9d000fdc:	00641825 	or	v1,v1,a0
9d000fe0:	3063ffff 	andi	v1,v1,0xffff
9d000fe4:	30630040 	andi	v1,v1,0x40
9d000fe8:	3063ffff 	andi	v1,v1,0xffff
9d000fec:	306400ff 	andi	a0,v1,0xff
9d000ff0:	90450000 	lbu	a1,0(v0)
9d000ff4:	30a50000 	andi	a1,a1,0x0
9d000ff8:	00a42025 	or	a0,a1,a0
9d000ffc:	a0440000 	sb	a0,0(v0)
9d001000:	00031a02 	srl	v1,v1,0x8
9d001004:	3063ffff 	andi	v1,v1,0xffff
9d001008:	90440001 	lbu	a0,1(v0)
9d00100c:	30840000 	andi	a0,a0,0x0
9d001010:	00831825 	or	v1,a0,v1
9d001014:	a0430001 	sb	v1,1(v0)
    	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
9d001018:	93c20008 	lbu	v0,8(s8)
9d00101c:	00021880 	sll	v1,v0,0x2
9d001020:	27828038 	addiu	v0,gp,-32712
9d001024:	00621021 	addu	v0,v1,v0
9d001028:	8c420000 	lw	v0,0(v0)
9d00102c:	93c30008 	lbu	v1,8(s8)
9d001030:	00032080 	sll	a0,v1,0x2
9d001034:	27838038 	addiu	v1,gp,-32712
9d001038:	00831821 	addu	v1,a0,v1
9d00103c:	8c630000 	lw	v1,0(v1)
9d001040:	90640000 	lbu	a0,0(v1)
9d001044:	308400ff 	andi	a0,a0,0xff
9d001048:	90630001 	lbu	v1,1(v1)
9d00104c:	306300ff 	andi	v1,v1,0xff
9d001050:	00031a00 	sll	v1,v1,0x8
9d001054:	00641825 	or	v1,v1,a0
9d001058:	3063ffff 	andi	v1,v1,0xffff
9d00105c:	38630040 	xori	v1,v1,0x40
9d001060:	3063ffff 	andi	v1,v1,0xffff
9d001064:	306400ff 	andi	a0,v1,0xff
9d001068:	90450000 	lbu	a1,0(v0)
9d00106c:	30a50000 	andi	a1,a1,0x0
9d001070:	00a42025 	or	a0,a1,a0
9d001074:	a0440000 	sb	a0,0(v0)
9d001078:	00031a02 	srl	v1,v1,0x8
9d00107c:	3063ffff 	andi	v1,v1,0xffff
9d001080:	90440001 	lbu	a0,1(v0)
9d001084:	30840000 	andi	a0,a0,0x0
9d001088:	00831825 	or	v1,a0,v1
9d00108c:	a0430001 	sb	v1,1(v0)
#endif
    }
}
9d001090:	03c0e821 	move	sp,s8
9d001094:	8fbe0004 	lw	s8,4(sp)
9d001098:	27bd0008 	addiu	sp,sp,8
9d00109c:	03e00008 	jr	ra
9d0010a0:	00000000 	nop

9d0010a4 <USBCtrlEPAllowStatusStage>:

  Remarks:
    None                                                                                                          
  *****************************************************************************/
void USBCtrlEPAllowStatusStage(void)
{
9d0010a4:	27bdfff8 	addiu	sp,sp,-8
9d0010a8:	afbe0004 	sw	s8,4(sp)
9d0010ac:	03a0f021 	move	s8,sp
    //Check and set two flags, prior to actually modifying any BDT entries.
    //This double checking is necessary to make certain that 
    //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
    //in main loop context, while simultaneously getting an interrupt which 
    //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
    if (USBStatusStageEnabledFlag1 == FALSE)
9d0010b0:	93828042 	lbu	v0,-32702(gp)
9d0010b4:	304200ff 	andi	v0,v0,0xff
9d0010b8:	14400080 	bnez	v0,9d0012bc <USBCtrlEPAllowStatusStage+0x218>
9d0010bc:	00000000 	nop
    {
        USBStatusStageEnabledFlag1 = TRUE;  
9d0010c0:	24020001 	li	v0,1
9d0010c4:	a3828042 	sb	v0,-32702(gp)

        if (USBStatusStageEnabledFlag2 == FALSE)
9d0010c8:	93828043 	lbu	v0,-32701(gp)
9d0010cc:	304200ff 	andi	v0,v0,0xff
9d0010d0:	1440007a 	bnez	v0,9d0012bc <USBCtrlEPAllowStatusStage+0x218>
9d0010d4:	00000000 	nop
        {
            USBStatusStageEnabledFlag2 = TRUE;
9d0010d8:	24020001 	li	v0,1
9d0010dc:	a3828043 	sb	v0,-32701(gp)
        
            //Determine which endpoints (EP0 IN or OUT needs arming for the status
            //stage), based on the type of control transfer currently pending.
            if (controlTransferState == CTRL_TRF_RX)
9d0010e0:	93838034 	lbu	v1,-32716(gp)
9d0010e4:	24020002 	li	v0,2
9d0010e8:	14620015 	bne	v1,v0,9d001140 <USBCtrlEPAllowStatusStage+0x9c>
9d0010ec:	00000000 	nop
            {
                pBDTEntryIn[0]->CNT = 0;
9d0010f0:	8f828038 	lw	v0,-32712(gp)
9d0010f4:	90430002 	lbu	v1,2(v0)
9d0010f8:	30630000 	andi	v1,v1,0x0
9d0010fc:	a0430002 	sb	v1,2(v0)
9d001100:	90440003 	lbu	a0,3(v0)
9d001104:	2403fffc 	li	v1,-4
9d001108:	00831824 	and	v1,a0,v1
9d00110c:	a0430003 	sb	v1,3(v0)
                pBDTEntryIn[0]->STAT.Val = _USIE | _DAT1 | (_DTSEN & _DTS_CHECKING_ENABLED);        
9d001110:	8f828038 	lw	v0,-32712(gp)
9d001114:	90430000 	lbu	v1,0(v0)
9d001118:	30630000 	andi	v1,v1,0x0
9d00111c:	00602021 	move	a0,v1
9d001120:	2403ffc8 	li	v1,-56
9d001124:	00831825 	or	v1,a0,v1
9d001128:	a0430000 	sb	v1,0(v0)
9d00112c:	90430001 	lbu	v1,1(v0)
9d001130:	30630000 	andi	v1,v1,0x0
9d001134:	a0430001 	sb	v1,1(v0)
9d001138:	0b4004af 	j	9d0012bc <USBCtrlEPAllowStatusStage+0x218>
9d00113c:	00000000 	nop
            }
            else if (controlTransferState == CTRL_TRF_TX)
9d001140:	93838034 	lbu	v1,-32716(gp)
9d001144:	24020001 	li	v0,1
9d001148:	1462005c 	bne	v1,v0,9d0012bc <USBCtrlEPAllowStatusStage+0x218>
9d00114c:	00000000 	nop
            {
        		BothEP0OutUOWNsSet = FALSE;	//Indicator flag used in USBCtrlTrfOutHandler()
9d001150:	a380804c 	sb	zero,-32692(gp)
        
                //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
                //next SETUP packet.
#if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
        		pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
9d001154:	8f828064 	lw	v0,-32668(gp)
9d001158:	90430002 	lbu	v1,2(v0)
9d00115c:	30630000 	andi	v1,v1,0x0
9d001160:	34630040 	ori	v1,v1,0x40
9d001164:	a0430002 	sb	v1,2(v0)
9d001168:	90440003 	lbu	a0,3(v0)
9d00116c:	2403fffc 	li	v1,-4
9d001170:	00831824 	and	v1,a0,v1
9d001174:	a0430003 	sb	v1,3(v0)
        		pBDTEntryEP0OutCurrent->ADR = MConvertToPhysicalAddress(&SetupPkt);
9d001178:	8f828064 	lw	v0,-32668(gp)
9d00117c:	27838058 	addiu	v1,gp,-32680
9d001180:	7c63e000 	ext	v1,v1,0x0,0x1d
9d001184:	306400ff 	andi	a0,v1,0xff
9d001188:	90450004 	lbu	a1,4(v0)
9d00118c:	30a50000 	andi	a1,a1,0x0
9d001190:	00a42025 	or	a0,a1,a0
9d001194:	a0440004 	sb	a0,4(v0)
9d001198:	00032202 	srl	a0,v1,0x8
9d00119c:	308400ff 	andi	a0,a0,0xff
9d0011a0:	90450005 	lbu	a1,5(v0)
9d0011a4:	30a50000 	andi	a1,a1,0x0
9d0011a8:	00a42025 	or	a0,a1,a0
9d0011ac:	a0440005 	sb	a0,5(v0)
9d0011b0:	00032402 	srl	a0,v1,0x10
9d0011b4:	308400ff 	andi	a0,a0,0xff
9d0011b8:	90450006 	lbu	a1,6(v0)
9d0011bc:	30a50000 	andi	a1,a1,0x0
9d0011c0:	00a42025 	or	a0,a1,a0
9d0011c4:	a0440006 	sb	a0,6(v0)
9d0011c8:	00031e02 	srl	v1,v1,0x18
9d0011cc:	90440007 	lbu	a0,7(v0)
9d0011d0:	30840000 	andi	a0,a0,0x0
9d0011d4:	00831825 	or	v1,a0,v1
9d0011d8:	a0430007 	sb	v1,7(v0)
        		pBDTEntryEP0OutCurrent->STAT.Val = _USIE | _BSTALL; //Prepare endpoint to accept a SETUP transaction
9d0011dc:	8f828064 	lw	v0,-32668(gp)
9d0011e0:	90430000 	lbu	v1,0(v0)
9d0011e4:	30630000 	andi	v1,v1,0x0
9d0011e8:	00602021 	move	a0,v1
9d0011ec:	2403ff84 	li	v1,-124
9d0011f0:	00831825 	or	v1,a0,v1
9d0011f4:	a0430000 	sb	v1,0(v0)
9d0011f8:	90430001 	lbu	v1,1(v0)
9d0011fc:	30630000 	andi	v1,v1,0x0
9d001200:	a0430001 	sb	v1,1(v0)
        		BothEP0OutUOWNsSet = TRUE;	//Indicator flag used in USBCtrlTrfOutHandler()
9d001204:	24020001 	li	v0,1
9d001208:	a382804c 	sb	v0,-32692(gp)
#endif
        
                //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
        		pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9d00120c:	8f828050 	lw	v0,-32688(gp)
9d001210:	90430002 	lbu	v1,2(v0)
9d001214:	30630000 	andi	v1,v1,0x0
9d001218:	34630040 	ori	v1,v1,0x40
9d00121c:	a0430002 	sb	v1,2(v0)
9d001220:	90440003 	lbu	a0,3(v0)
9d001224:	2403fffc 	li	v1,-4
9d001228:	00831824 	and	v1,a0,v1
9d00122c:	a0430003 	sb	v1,3(v0)
        		pBDTEntryEP0OutNext->ADR = MConvertToPhysicalAddress(&SetupPkt);
9d001230:	8f828050 	lw	v0,-32688(gp)
9d001234:	27838058 	addiu	v1,gp,-32680
9d001238:	7c63e000 	ext	v1,v1,0x0,0x1d
9d00123c:	306400ff 	andi	a0,v1,0xff
9d001240:	90450004 	lbu	a1,4(v0)
9d001244:	30a50000 	andi	a1,a1,0x0
9d001248:	00a42025 	or	a0,a1,a0
9d00124c:	a0440004 	sb	a0,4(v0)
9d001250:	00032202 	srl	a0,v1,0x8
9d001254:	308400ff 	andi	a0,a0,0xff
9d001258:	90450005 	lbu	a1,5(v0)
9d00125c:	30a50000 	andi	a1,a1,0x0
9d001260:	00a42025 	or	a0,a1,a0
9d001264:	a0440005 	sb	a0,5(v0)
9d001268:	00032402 	srl	a0,v1,0x10
9d00126c:	308400ff 	andi	a0,a0,0xff
9d001270:	90450006 	lbu	a1,6(v0)
9d001274:	30a50000 	andi	a1,a1,0x0
9d001278:	00a42025 	or	a0,a1,a0
9d00127c:	a0440006 	sb	a0,6(v0)
9d001280:	00031e02 	srl	v1,v1,0x18
9d001284:	90440007 	lbu	a0,7(v0)
9d001288:	30840000 	andi	a0,a0,0x0
9d00128c:	00831825 	or	v1,a0,v1
9d001290:	a0430007 	sb	v1,7(v0)
        		pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
9d001294:	8f828050 	lw	v0,-32688(gp)
9d001298:	90430000 	lbu	v1,0(v0)
9d00129c:	30630000 	andi	v1,v1,0x0
9d0012a0:	00602021 	move	a0,v1
9d0012a4:	2403ff80 	li	v1,-128
9d0012a8:	00831825 	or	v1,a0,v1
9d0012ac:	a0430000 	sb	v1,0(v0)
9d0012b0:	90430001 	lbu	v1,1(v0)
9d0012b4:	30630000 	andi	v1,v1,0x0
9d0012b8:	a0430001 	sb	v1,1(v0)
            }
        }    
    }
}   
9d0012bc:	03c0e821 	move	sp,s8
9d0012c0:	8fbe0004 	lw	s8,4(sp)
9d0012c4:	27bd0008 	addiu	sp,sp,8
9d0012c8:	03e00008 	jr	ra
9d0012cc:	00000000 	nop

9d0012d0 <USBCtrlEPAllowDataStage>:
  Return:

  Remarks: 
  *****************************************************************************/
void USBCtrlEPAllowDataStage(void)
{
9d0012d0:	27bdffe8 	addiu	sp,sp,-24
9d0012d4:	afbf0014 	sw	ra,20(sp)
9d0012d8:	afbe0010 	sw	s8,16(sp)
9d0012dc:	03a0f021 	move	s8,sp
    USBDeferINDataStagePackets = FALSE;
9d0012e0:	a380802c 	sb	zero,-32724(gp)
    USBDeferOUTDataStagePackets = FALSE;
9d0012e4:	a380802d 	sb	zero,-32723(gp)

    if (controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
9d0012e8:	93838034 	lbu	v1,-32716(gp)
9d0012ec:	24020002 	li	v0,2
9d0012f0:	14620030 	bne	v1,v0,9d0013b4 <USBCtrlEPAllowDataStage+0xe4>
9d0012f4:	00000000 	nop
    {
        //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9d0012f8:	8f828050 	lw	v0,-32688(gp)
9d0012fc:	90430002 	lbu	v1,2(v0)
9d001300:	30630000 	andi	v1,v1,0x0
9d001304:	34630040 	ori	v1,v1,0x40
9d001308:	a0430002 	sb	v1,2(v0)
9d00130c:	90440003 	lbu	a0,3(v0)
9d001310:	2403fffc 	li	v1,-4
9d001314:	00831824 	and	v1,a0,v1
9d001318:	a0430003 	sb	v1,3(v0)
        pBDTEntryEP0OutNext->ADR = MConvertToPhysicalAddress(&CtrlTrfData);
9d00131c:	8f828050 	lw	v0,-32688(gp)
9d001320:	3c03a000 	lui	v1,0xa000
9d001324:	24630240 	addiu	v1,v1,576
9d001328:	7c63e000 	ext	v1,v1,0x0,0x1d
9d00132c:	306400ff 	andi	a0,v1,0xff
9d001330:	90450004 	lbu	a1,4(v0)
9d001334:	30a50000 	andi	a1,a1,0x0
9d001338:	00a42025 	or	a0,a1,a0
9d00133c:	a0440004 	sb	a0,4(v0)
9d001340:	00032202 	srl	a0,v1,0x8
9d001344:	308400ff 	andi	a0,a0,0xff
9d001348:	90450005 	lbu	a1,5(v0)
9d00134c:	30a50000 	andi	a1,a1,0x0
9d001350:	00a42025 	or	a0,a1,a0
9d001354:	a0440005 	sb	a0,5(v0)
9d001358:	00032402 	srl	a0,v1,0x10
9d00135c:	308400ff 	andi	a0,a0,0xff
9d001360:	90450006 	lbu	a1,6(v0)
9d001364:	30a50000 	andi	a1,a1,0x0
9d001368:	00a42025 	or	a0,a1,a0
9d00136c:	a0440006 	sb	a0,6(v0)
9d001370:	00031e02 	srl	v1,v1,0x18
9d001374:	90440007 	lbu	a0,7(v0)
9d001378:	30840000 	andi	a0,a0,0x0
9d00137c:	00831825 	or	v1,a0,v1
9d001380:	a0430007 	sb	v1,7(v0)
        pBDTEntryEP0OutNext->STAT.Val = _USIE | _DAT1 | (_DTSEN & _DTS_CHECKING_ENABLED);
9d001384:	8f828050 	lw	v0,-32688(gp)
9d001388:	90430000 	lbu	v1,0(v0)
9d00138c:	30630000 	andi	v1,v1,0x0
9d001390:	00602021 	move	a0,v1
9d001394:	2403ffc8 	li	v1,-56
9d001398:	00831825 	or	v1,a0,v1
9d00139c:	a0430000 	sb	v1,0(v0)
9d0013a0:	90430001 	lbu	v1,1(v0)
9d0013a4:	30630000 	andi	v1,v1,0x0
9d0013a8:	a0430001 	sb	v1,1(v0)
9d0013ac:	0b400520 	j	9d001480 <USBCtrlEPAllowDataStage+0x1b0>
9d0013b0:	00000000 	nop
    }   
    else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
    {
        //Error check the data stage byte count.  Make sure the user specified
        //value was no greater than the number of bytes the host requested.
		if (SetupPkt.wLength < inPipes[0].wCount)
9d0013b4:	9782805e 	lhu	v0,-32674(gp)
9d0013b8:	3043ffff 	andi	v1,v0,0xffff
9d0013bc:	3c02a000 	lui	v0,0xa000
9d0013c0:	24420280 	addiu	v0,v0,640
9d0013c4:	94420008 	lhu	v0,8(v0)
9d0013c8:	0062102b 	sltu	v0,v1,v0
9d0013cc:	10400006 	beqz	v0,9d0013e8 <USBCtrlEPAllowDataStage+0x118>
9d0013d0:	00000000 	nop
		{
			inPipes[0].wCount = SetupPkt.wLength;
9d0013d4:	9782805e 	lhu	v0,-32674(gp)
9d0013d8:	3043ffff 	andi	v1,v0,0xffff
9d0013dc:	3c02a000 	lui	v0,0xa000
9d0013e0:	24420280 	addiu	v0,v0,640
9d0013e4:	a4430008 	sh	v1,8(v0)
		}

		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
9d0013e8:	0f40060b 	jal	9d00182c <USBCtrlEPAllowDataStage+0x55c>
9d0013ec:	00000000 	nop
		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.

	    //Cnt should have been initialized by responsible request owner (ex: by
	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
		pBDTEntryIn[0]->ADR = MConvertToPhysicalAddress(&CtrlTrfData);
9d0013f0:	8f828038 	lw	v0,-32712(gp)
9d0013f4:	3c03a000 	lui	v1,0xa000
9d0013f8:	24630240 	addiu	v1,v1,576
9d0013fc:	7c63e000 	ext	v1,v1,0x0,0x1d
9d001400:	306400ff 	andi	a0,v1,0xff
9d001404:	90450004 	lbu	a1,4(v0)
9d001408:	30a50000 	andi	a1,a1,0x0
9d00140c:	00a42025 	or	a0,a1,a0
9d001410:	a0440004 	sb	a0,4(v0)
9d001414:	00032202 	srl	a0,v1,0x8
9d001418:	308400ff 	andi	a0,a0,0xff
9d00141c:	90450005 	lbu	a1,5(v0)
9d001420:	30a50000 	andi	a1,a1,0x0
9d001424:	00a42025 	or	a0,a1,a0
9d001428:	a0440005 	sb	a0,5(v0)
9d00142c:	00032402 	srl	a0,v1,0x10
9d001430:	308400ff 	andi	a0,a0,0xff
9d001434:	90450006 	lbu	a1,6(v0)
9d001438:	30a50000 	andi	a1,a1,0x0
9d00143c:	00a42025 	or	a0,a1,a0
9d001440:	a0440006 	sb	a0,6(v0)
9d001444:	00031e02 	srl	v1,v1,0x18
9d001448:	90440007 	lbu	a0,7(v0)
9d00144c:	30840000 	andi	a0,a0,0x0
9d001450:	00831825 	or	v1,a0,v1
9d001454:	a0430007 	sb	v1,7(v0)
		pBDTEntryIn[0]->STAT.Val = _USIE | _DAT1 | (_DTSEN & _DTS_CHECKING_ENABLED);
9d001458:	8f828038 	lw	v0,-32712(gp)
9d00145c:	90430000 	lbu	v1,0(v0)
9d001460:	30630000 	andi	v1,v1,0x0
9d001464:	00602021 	move	a0,v1
9d001468:	2403ffc8 	li	v1,-56
9d00146c:	00831825 	or	v1,a0,v1
9d001470:	a0430000 	sb	v1,0(v0)
9d001474:	90430001 	lbu	v1,1(v0)
9d001478:	30630000 	andi	v1,v1,0x0
9d00147c:	a0430001 	sb	v1,1(v0)
    }     
}    
9d001480:	03c0e821 	move	sp,s8
9d001484:	8fbf0014 	lw	ra,20(sp)
9d001488:	8fbe0010 	lw	s8,16(sp)
9d00148c:	27bd0018 	addiu	sp,sp,24
9d001490:	03e00008 	jr	ra
9d001494:	00000000 	nop
 *                  endpoint
 *
 * Note:            None
 *******************************************************************/
static void USBConfigureEndpoint(UINT8 EPNum, UINT8 direction)
{
9d001498:	27bdfff0 	addiu	sp,sp,-16
9d00149c:	afbe000c 	sw	s8,12(sp)
9d0014a0:	03a0f021 	move	s8,sp
9d0014a4:	00801821 	move	v1,a0
9d0014a8:	00a01021 	move	v0,a1
9d0014ac:	a3c30010 	sb	v1,16(s8)
9d0014b0:	a3c20014 	sb	v0,20(s8)
    volatile BDT_ENTRY* handle;

    //Compute a pointer to the even BDT entry corresponding to the
    //EPNum and direction values passed to this function.
    handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
9d0014b4:	3c02a000 	lui	v0,0xa000
9d0014b8:	24420200 	addiu	v0,v0,512
9d0014bc:	afc20000 	sw	v0,0(s8)
    handle += EP(EPNum, direction, 0u);     //Add in offset to the BDT of interest
9d0014c0:	93c20010 	lbu	v0,16(s8)
9d0014c4:	00021840 	sll	v1,v0,0x1
9d0014c8:	93c20014 	lbu	v0,20(s8)
9d0014cc:	00621021 	addu	v0,v1,v0
9d0014d0:	00021100 	sll	v0,v0,0x4
9d0014d4:	8fc30000 	lw	v1,0(s8)
9d0014d8:	00621021 	addu	v0,v1,v0
9d0014dc:	afc20000 	sw	v0,0(s8)
    
    handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
9d0014e0:	8fc30000 	lw	v1,0(s8)
9d0014e4:	90620000 	lbu	v0,0(v1)
9d0014e8:	7c0239c4 	ins	v0,zero,0x7,0x1
9d0014ec:	a0620000 	sb	v0,0(v1)
    //already cleared the entire BDT table

    //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
    //for USBTransferOnePacket() API calls.
    if (direction == OUT_FROM_HOST)
9d0014f0:	93c20014 	lbu	v0,20(s8)
9d0014f4:	14400009 	bnez	v0,9d00151c <USBCtrlEPAllowDataStage+0x24c>
9d0014f8:	00000000 	nop
    {
        pBDTEntryOut[EPNum] = handle;
9d0014fc:	93c20010 	lbu	v0,16(s8)
9d001500:	00021880 	sll	v1,v0,0x2
9d001504:	27828044 	addiu	v0,gp,-32700
9d001508:	00621021 	addu	v0,v1,v0
9d00150c:	8fc30000 	lw	v1,0(s8)
9d001510:	ac430000 	sw	v1,0(v0)
9d001514:	0b40054d 	j	9d001534 <USBCtrlEPAllowDataStage+0x264>
9d001518:	00000000 	nop
    }
    else
    {
        pBDTEntryIn[EPNum] = handle;
9d00151c:	93c20010 	lbu	v0,16(s8)
9d001520:	00021880 	sll	v1,v0,0x2
9d001524:	27828038 	addiu	v0,gp,-32712
9d001528:	00621021 	addu	v0,v1,v0
9d00152c:	8fc30000 	lw	v1,0(s8)
9d001530:	ac430000 	sw	v1,0(v0)
    }

#if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
    handle->STAT.DTS = 0;
9d001534:	8fc30000 	lw	v1,0(s8)
9d001538:	90620000 	lbu	v0,0(v1)
9d00153c:	7c023184 	ins	v0,zero,0x6,0x1
9d001540:	a0620000 	sb	v0,0(v1)
    (handle+1)->STAT.DTS = 1;
9d001544:	8fc20000 	lw	v0,0(s8)
9d001548:	24430008 	addiu	v1,v0,8
9d00154c:	90620000 	lbu	v0,0(v1)
9d001550:	24040001 	li	a0,1
9d001554:	7c823184 	ins	v0,a0,0x6,0x1
9d001558:	a0620000 	sb	v0,0(v1)
    {
        handle->STAT.DTS = 0;
        (handle+1)->STAT.DTS = 1;
    }
#endif
}
9d00155c:	03c0e821 	move	sp,s8
9d001560:	8fbe000c 	lw	s8,12(sp)
9d001564:	27bd0010 	addiu	sp,sp,16
9d001568:	03e00008 	jr	ra
9d00156c:	00000000 	nop
 *                  Packet processing is resumed by clearing PKTDIS bit.
 *
 * Note:            None
 *****************************************************************************/
static void USBCtrlEPServiceComplete(void)
{
9d001570:	27bdffe8 	addiu	sp,sp,-24
9d001574:	afbf0014 	sw	ra,20(sp)
9d001578:	afbe0010 	sw	s8,16(sp)
9d00157c:	03a0f021 	move	s8,sp
    /*
     * PKTDIS bit is set when a Setup Transaction is received.
     * Clear to resume packet processing.
     */
    USBPacketDisable = 0;
9d001580:	3c03bf88 	lui	v1,0xbf88
9d001584:	8c625250 	lw	v0,21072(v1)
9d001588:	7c022944 	ins	v0,zero,0x5,0x1
9d00158c:	ac625250 	sw	v0,21072(v1)

	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
	//control transfer is currently in progress.  We need to know the type of control
	//transfer that is currently pending, in order to know how to properly arm the 
	//EP0 IN and EP0 OUT endpoints.
    if (inPipes[0].info.bits.busy == 0)
9d001590:	3c02a000 	lui	v0,0xa000
9d001594:	24420280 	addiu	v0,v0,640
9d001598:	8c420004 	lw	v0,4(v0)
9d00159c:	30420080 	andi	v0,v0,0x80
9d0015a0:	1440004d 	bnez	v0,9d0016d8 <USBCtrlEPAllowDataStage+0x408>
9d0015a4:	00000000 	nop
    {
        if (outPipes[0].info.bits.busy == 1)
9d0015a8:	3c02a000 	lui	v0,0xa000
9d0015ac:	24420290 	addiu	v0,v0,656
9d0015b0:	90430004 	lbu	v1,4(v0)
9d0015b4:	2402ff80 	li	v0,-128
9d0015b8:	00621024 	and	v0,v1,v0
9d0015bc:	304200ff 	andi	v0,v0,0xff
9d0015c0:	1040000d 	beqz	v0,9d0015f8 <USBCtrlEPAllowDataStage+0x328>
9d0015c4:	00000000 	nop
        {
            controlTransferState = CTRL_TRF_RX;
9d0015c8:	24020002 	li	v0,2
9d0015cc:	a3828034 	sb	v0,-32716(gp)
            //1. Prepare OUT EP to receive data, unless a USB class request handler
            //   function decided to defer the data stage (ex: because the intended
            //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
            //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
            //   once it is ready to begin receiving the data.
            if (USBDeferOUTDataStagePackets == FALSE)
9d0015d0:	9382802d 	lbu	v0,-32723(gp)
9d0015d4:	304200ff 	andi	v0,v0,0xff
9d0015d8:	14400003 	bnez	v0,9d0015e8 <USBCtrlEPAllowDataStage+0x318>
9d0015dc:	00000000 	nop
            {
                USBCtrlEPAllowDataStage();
9d0015e0:	0f4004b4 	jal	9d0012d0 <USBCtrlEPAllowDataStage>
9d0015e4:	00000000 	nop
            }
            
            //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
            //after all of the OUT data has been received and consumed, or if a timeout occurs.
            USBStatusStageEnabledFlag2 = FALSE;
9d0015e8:	a3808043 	sb	zero,-32701(gp)
            USBStatusStageEnabledFlag1 = FALSE;
9d0015ec:	a3808042 	sb	zero,-32702(gp)
9d0015f0:	0b400605 	j	9d001814 <USBCtrlEPAllowDataStage+0x544>
9d0015f4:	00000000 	nop
        {
            /*
             * If no one knows how to service this request then stall.
             * Must also prepare EP0 to receive the next SETUP transaction.
             */
            pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9d0015f8:	8f828050 	lw	v0,-32688(gp)
9d0015fc:	90430002 	lbu	v1,2(v0)
9d001600:	30630000 	andi	v1,v1,0x0
9d001604:	34630040 	ori	v1,v1,0x40
9d001608:	a0430002 	sb	v1,2(v0)
9d00160c:	90440003 	lbu	a0,3(v0)
9d001610:	2403fffc 	li	v1,-4
9d001614:	00831824 	and	v1,a0,v1
9d001618:	a0430003 	sb	v1,3(v0)
            pBDTEntryEP0OutNext->ADR = MConvertToPhysicalAddress(&SetupPkt);
9d00161c:	8f828050 	lw	v0,-32688(gp)
9d001620:	27838058 	addiu	v1,gp,-32680
9d001624:	7c63e000 	ext	v1,v1,0x0,0x1d
9d001628:	306400ff 	andi	a0,v1,0xff
9d00162c:	90450004 	lbu	a1,4(v0)
9d001630:	30a50000 	andi	a1,a1,0x0
9d001634:	00a42025 	or	a0,a1,a0
9d001638:	a0440004 	sb	a0,4(v0)
9d00163c:	00032202 	srl	a0,v1,0x8
9d001640:	308400ff 	andi	a0,a0,0xff
9d001644:	90450005 	lbu	a1,5(v0)
9d001648:	30a50000 	andi	a1,a1,0x0
9d00164c:	00a42025 	or	a0,a1,a0
9d001650:	a0440005 	sb	a0,5(v0)
9d001654:	00032402 	srl	a0,v1,0x10
9d001658:	308400ff 	andi	a0,a0,0xff
9d00165c:	90450006 	lbu	a1,6(v0)
9d001660:	30a50000 	andi	a1,a1,0x0
9d001664:	00a42025 	or	a0,a1,a0
9d001668:	a0440006 	sb	a0,6(v0)
9d00166c:	00031e02 	srl	v1,v1,0x18
9d001670:	90440007 	lbu	a0,7(v0)
9d001674:	30840000 	andi	a0,a0,0x0
9d001678:	00831825 	or	v1,a0,v1
9d00167c:	a0430007 	sb	v1,7(v0)
            pBDTEntryEP0OutNext->STAT.Val = _USIE | _DAT0 | (_DTSEN & _DTS_CHECKING_ENABLED) | _BSTALL;
9d001680:	8f828050 	lw	v0,-32688(gp)
9d001684:	90430000 	lbu	v1,0(v0)
9d001688:	30630000 	andi	v1,v1,0x0
9d00168c:	00602021 	move	a0,v1
9d001690:	2403ff8c 	li	v1,-116
9d001694:	00831825 	or	v1,a0,v1
9d001698:	a0430000 	sb	v1,0(v0)
9d00169c:	90430001 	lbu	v1,1(v0)
9d0016a0:	30630000 	andi	v1,v1,0x0
9d0016a4:	a0430001 	sb	v1,1(v0)
            pBDTEntryIn[0]->STAT.Val = _USIE | _BSTALL; 
9d0016a8:	8f828038 	lw	v0,-32712(gp)
9d0016ac:	90430000 	lbu	v1,0(v0)
9d0016b0:	30630000 	andi	v1,v1,0x0
9d0016b4:	00602021 	move	a0,v1
9d0016b8:	2403ff84 	li	v1,-124
9d0016bc:	00831825 	or	v1,a0,v1
9d0016c0:	a0430000 	sb	v1,0(v0)
9d0016c4:	90430001 	lbu	v1,1(v0)
9d0016c8:	30630000 	andi	v1,v1,0x0
9d0016cc:	a0430001 	sb	v1,1(v0)
9d0016d0:	0b400605 	j	9d001814 <USBCtrlEPAllowDataStage+0x544>
9d0016d4:	00000000 	nop
        }
    }
    else    // A module has claimed ownership of the control transfer session.
    {
		if (SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
9d0016d8:	93828058 	lbu	v0,-32680(gp)
9d0016dc:	304300ff 	andi	v1,v0,0xff
9d0016e0:	2402ff80 	li	v0,-128
9d0016e4:	00621024 	and	v0,v1,v0
9d0016e8:	304200ff 	andi	v0,v0,0xff
9d0016ec:	10400013 	beqz	v0,9d00173c <USBCtrlEPAllowDataStage+0x46c>
9d0016f0:	00000000 	nop
		{
			controlTransferState = CTRL_TRF_TX;
9d0016f4:	24020001 	li	v0,1
9d0016f8:	a3828034 	sb	v0,-32716(gp)
			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
			 *    is ready to begin sending the data, it should then call the 
			 *    USBCtrlEPAllowDataStage() function to start the data stage.
			 */
			if (USBDeferINDataStagePackets == FALSE)
9d0016fc:	9382802c 	lbu	v0,-32724(gp)
9d001700:	304200ff 	andi	v0,v0,0xff
9d001704:	14400003 	bnez	v0,9d001714 <USBCtrlEPAllowDataStage+0x444>
9d001708:	00000000 	nop
            {
                USBCtrlEPAllowDataStage();
9d00170c:	0f4004b4 	jal	9d0012d0 <USBCtrlEPAllowDataStage>
9d001710:	00000000 	nop
            //    status stage packet right now, even if the IN data is not ready yet.  This allows for
            //    immediate early termination, without adding unnecessary delay.  Therefore, it is generally not
            //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
            //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
            //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
            USBStatusStageEnabledFlag2 = FALSE;
9d001714:	a3808043 	sb	zero,-32701(gp)
            USBStatusStageEnabledFlag1 = FALSE;
9d001718:	a3808042 	sb	zero,-32702(gp)

            if (USBDeferStatusStagePacket == FALSE)
9d00171c:	93828071 	lbu	v0,-32655(gp)
9d001720:	304200ff 	andi	v0,v0,0xff
9d001724:	1440003b 	bnez	v0,9d001814 <USBCtrlEPAllowDataStage+0x544>
9d001728:	00000000 	nop
            {
                USBCtrlEPAllowStatusStage();
9d00172c:	0f400429 	jal	9d0010a4 <USBCtrlEPAllowStatusStage>
9d001730:	00000000 	nop
9d001734:	0b400605 	j	9d001814 <USBCtrlEPAllowDataStage+0x544>
9d001738:	00000000 	nop
				
			//Although the data direction is HOST_TO_DEVICE, there is no data stage
			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
			//an IN status stage.

			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
9d00173c:	24020002 	li	v0,2
9d001740:	a3828034 	sb	v0,-32716(gp)
			
			//1. Prepare OUT EP to receive the next SETUP packet.
			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9d001744:	8f828050 	lw	v0,-32688(gp)
9d001748:	90430002 	lbu	v1,2(v0)
9d00174c:	30630000 	andi	v1,v1,0x0
9d001750:	34630040 	ori	v1,v1,0x40
9d001754:	a0430002 	sb	v1,2(v0)
9d001758:	90440003 	lbu	a0,3(v0)
9d00175c:	2403fffc 	li	v1,-4
9d001760:	00831824 	and	v1,a0,v1
9d001764:	a0430003 	sb	v1,3(v0)
			pBDTEntryEP0OutNext->ADR = MConvertToPhysicalAddress(&SetupPkt);
9d001768:	8f828050 	lw	v0,-32688(gp)
9d00176c:	27838058 	addiu	v1,gp,-32680
9d001770:	7c63e000 	ext	v1,v1,0x0,0x1d
9d001774:	306400ff 	andi	a0,v1,0xff
9d001778:	90450004 	lbu	a1,4(v0)
9d00177c:	30a50000 	andi	a1,a1,0x0
9d001780:	00a42025 	or	a0,a1,a0
9d001784:	a0440004 	sb	a0,4(v0)
9d001788:	00032202 	srl	a0,v1,0x8
9d00178c:	308400ff 	andi	a0,a0,0xff
9d001790:	90450005 	lbu	a1,5(v0)
9d001794:	30a50000 	andi	a1,a1,0x0
9d001798:	00a42025 	or	a0,a1,a0
9d00179c:	a0440005 	sb	a0,5(v0)
9d0017a0:	00032402 	srl	a0,v1,0x10
9d0017a4:	308400ff 	andi	a0,a0,0xff
9d0017a8:	90450006 	lbu	a1,6(v0)
9d0017ac:	30a50000 	andi	a1,a1,0x0
9d0017b0:	00a42025 	or	a0,a1,a0
9d0017b4:	a0440006 	sb	a0,6(v0)
9d0017b8:	00031e02 	srl	v1,v1,0x18
9d0017bc:	90440007 	lbu	a0,7(v0)
9d0017c0:	30840000 	andi	a0,a0,0x0
9d0017c4:	00831825 	or	v1,a0,v1
9d0017c8:	a0430007 	sb	v1,7(v0)
			pBDTEntryEP0OutNext->STAT.Val = _USIE | _BSTALL;
9d0017cc:	8f828050 	lw	v0,-32688(gp)
9d0017d0:	90430000 	lbu	v1,0(v0)
9d0017d4:	30630000 	andi	v1,v1,0x0
9d0017d8:	00602021 	move	a0,v1
9d0017dc:	2403ff84 	li	v1,-124
9d0017e0:	00831825 	or	v1,a0,v1
9d0017e4:	a0430000 	sb	v1,0(v0)
9d0017e8:	90430001 	lbu	v1,1(v0)
9d0017ec:	30630000 	andi	v1,v1,0x0
9d0017f0:	a0430001 	sb	v1,1(v0)
				
			//2. Prepare for IN status stage of the control transfer
            USBStatusStageEnabledFlag2 = FALSE;
9d0017f4:	a3808043 	sb	zero,-32701(gp)
            USBStatusStageEnabledFlag1 = FALSE;
9d0017f8:	a3808042 	sb	zero,-32702(gp)

			if (USBDeferStatusStagePacket == FALSE)
9d0017fc:	93828071 	lbu	v0,-32655(gp)
9d001800:	304200ff 	andi	v0,v0,0xff
9d001804:	14400003 	bnez	v0,9d001814 <USBCtrlEPAllowDataStage+0x544>
9d001808:	00000000 	nop
            {
                USBCtrlEPAllowStatusStage();
9d00180c:	0f400429 	jal	9d0010a4 <USBCtrlEPAllowStatusStage>
9d001810:	00000000 	nop
            } 
		}
    }//end if(ctrl_trf_session_owner == MUID_NULL)
}//end USBCtrlEPServiceComplete
9d001814:	03c0e821 	move	sp,s8
9d001818:	8fbf0014 	lw	ra,20(sp)
9d00181c:	8fbe0010 	lw	s8,16(sp)
9d001820:	27bd0018 	addiu	sp,sp,24
9d001824:	03e00008 	jr	ra
9d001828:	00000000 	nop
 *                  USBCtrlTrfInHandler().
 *
 * Note:            
 *****************************************************************************/
static void USBCtrlTrfTxService(void)
{
9d00182c:	27bdfff0 	addiu	sp,sp,-16
9d001830:	afbe000c 	sw	s8,12(sp)
9d001834:	03a0f021 	move	s8,sp
    UINT8 byteToSend;

    //Figure out how many bytes of data to send in the next IN transaction.
    //Assume a full size packet, unless otherwise determined below.
    byteToSend = USB_EP0_BUFF_SIZE;
9d001838:	24020040 	li	v0,64
9d00183c:	a3c20000 	sb	v0,0(s8)

    if (inPipes[0].wCount < (UINT8)USB_EP0_BUFF_SIZE)
9d001840:	3c02a000 	lui	v0,0xa000
9d001844:	24420280 	addiu	v0,v0,640
9d001848:	94420008 	lhu	v0,8(v0)
9d00184c:	2c420040 	sltiu	v0,v0,64
9d001850:	10400012 	beqz	v0,9d00189c <USBCtrlEPAllowDataStage+0x5cc>
9d001854:	00000000 	nop
    {
        byteToSend = inPipes[0].wCount;
9d001858:	3c02a000 	lui	v0,0xa000
9d00185c:	24420280 	addiu	v0,v0,640
9d001860:	94420008 	lhu	v0,8(v0)
9d001864:	a3c20000 	sb	v0,0(s8)
        //Keep track of whether or not we have sent a "short packet" yet.
        //This is useful so that later on, we can configure EP0 IN to STALL,
        //after we have sent all of the intended data.  This makes sure the
        //hardware STALLs if the host erroneously tries to send more IN token 
        //packets, requesting more data than intended in the control transfer.
        if (shortPacketStatus == SHORT_PKT_NOT_USED)
9d001868:	93828062 	lbu	v0,-32670(gp)
9d00186c:	14400005 	bnez	v0,9d001884 <USBCtrlEPAllowDataStage+0x5b4>
9d001870:	00000000 	nop
        {
            shortPacketStatus = SHORT_PKT_PENDING;
9d001874:	24020001 	li	v0,1
9d001878:	a3828062 	sb	v0,-32670(gp)
9d00187c:	0b400627 	j	9d00189c <USBCtrlEPAllowDataStage+0x5cc>
9d001880:	00000000 	nop
        }
        else if (shortPacketStatus == SHORT_PKT_PENDING)
9d001884:	93838062 	lbu	v1,-32670(gp)
9d001888:	24020001 	li	v0,1
9d00188c:	14620003 	bne	v1,v0,9d00189c <USBCtrlEPAllowDataStage+0x5cc>
9d001890:	00000000 	nop
        {
            shortPacketStatus = SHORT_PKT_SENT;
9d001894:	24020002 	li	v0,2
9d001898:	a3828062 	sb	v0,-32670(gp)
        }
    }

    //Keep track of how many bytes remain to be sent in the transfer, by
    //subtracting the number of bytes about to be sent from the total.
    inPipes[0].wCount = inPipes[0].wCount - byteToSend;
9d00189c:	3c02a000 	lui	v0,0xa000
9d0018a0:	24420280 	addiu	v0,v0,640
9d0018a4:	94430008 	lhu	v1,8(v0)
9d0018a8:	93c20000 	lbu	v0,0(s8)
9d0018ac:	3042ffff 	andi	v0,v0,0xffff
9d0018b0:	00621023 	subu	v0,v1,v0
9d0018b4:	3043ffff 	andi	v1,v0,0xffff
9d0018b8:	3c02a000 	lui	v0,0xa000
9d0018bc:	24420280 	addiu	v0,v0,640
9d0018c0:	a4430008 	sh	v1,8(v0)
    
    //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
    //Note: Control endpoints may never have a max packet size of > 64 bytes.
    //Therefore, the BC8 and BC9 bits should always be maintained clear.
    pBDTEntryIn[0]->CNT = byteToSend;
9d0018c4:	8f828038 	lw	v0,-32712(gp)
9d0018c8:	93c30000 	lbu	v1,0(s8)
9d0018cc:	306303ff 	andi	v1,v1,0x3ff
9d0018d0:	3063ffff 	andi	v1,v1,0xffff
9d0018d4:	306400ff 	andi	a0,v1,0xff
9d0018d8:	90450002 	lbu	a1,2(v0)
9d0018dc:	30a50000 	andi	a1,a1,0x0
9d0018e0:	00a42025 	or	a0,a1,a0
9d0018e4:	a0440002 	sb	a0,2(v0)
9d0018e8:	00031a02 	srl	v1,v1,0x8
9d0018ec:	3063ffff 	andi	v1,v1,0xffff
9d0018f0:	30630003 	andi	v1,v1,0x3
9d0018f4:	30630003 	andi	v1,v1,0x3
9d0018f8:	90450003 	lbu	a1,3(v0)
9d0018fc:	2404fffc 	li	a0,-4
9d001900:	00a42024 	and	a0,a1,a0
9d001904:	00831825 	or	v1,a0,v1
9d001908:	a0430003 	sb	v1,3(v0)

    //Now copy the data from the source location, to the CtrlTrfData[] buffer,
    //which we will send to the host.
    pDst = (USB_VOLATILE UINT8*)CtrlTrfData;                // Set destination pointer
9d00190c:	3c02a000 	lui	v0,0xa000
9d001910:	24420240 	addiu	v0,v0,576
9d001914:	af828028 	sw	v0,-32728(gp)
    
    if (inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
9d001918:	3c02a000 	lui	v0,0xa000
9d00191c:	24420280 	addiu	v0,v0,640
9d001920:	8c420004 	lw	v0,4(v0)
9d001924:	30420001 	andi	v0,v0,0x1
9d001928:	14400022 	bnez	v0,9d0019b4 <USBCtrlEPAllowDataStage+0x6e4>
9d00192c:	00000000 	nop
    {
        while (byteToSend)
9d001930:	0b40065b 	j	9d00196c <USBCtrlEPAllowDataStage+0x69c>
9d001934:	00000000 	nop
        {
            *pDst++ = *inPipes[0].Source.pbRom++;
9d001938:	8f838028 	lw	v1,-32728(gp)
9d00193c:	3c02a000 	lui	v0,0xa000
9d001940:	8c420280 	lw	v0,640(v0)
9d001944:	90440000 	lbu	a0,0(v0)
9d001948:	a0640000 	sb	a0,0(v1)
9d00194c:	24630001 	addiu	v1,v1,1
9d001950:	af838028 	sw	v1,-32728(gp)
9d001954:	24430001 	addiu	v1,v0,1
9d001958:	3c02a000 	lui	v0,0xa000
9d00195c:	ac430280 	sw	v1,640(v0)

            byteToSend--;
9d001960:	93c20000 	lbu	v0,0(s8)
9d001964:	2442ffff 	addiu	v0,v0,-1
9d001968:	a3c20000 	sb	v0,0(s8)
    //which we will send to the host.
    pDst = (USB_VOLATILE UINT8*)CtrlTrfData;                // Set destination pointer
    
    if (inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
    {
        while (byteToSend)
9d00196c:	93c20000 	lbu	v0,0(s8)
9d001970:	1440fff1 	bnez	v0,9d001938 <USBCtrlEPAllowDataStage+0x668>
9d001974:	00000000 	nop
9d001978:	0b400670 	j	9d0019c0 <USBCtrlEPAllowDataStage+0x6f0>
9d00197c:	00000000 	nop
    }
    else  // RAM
    {
        while (byteToSend)
        {
            *pDst++ = *inPipes[0].Source.pbRam++;
9d001980:	8f838028 	lw	v1,-32728(gp)
9d001984:	3c02a000 	lui	v0,0xa000
9d001988:	8c420280 	lw	v0,640(v0)
9d00198c:	90440000 	lbu	a0,0(v0)
9d001990:	a0640000 	sb	a0,0(v1)
9d001994:	24630001 	addiu	v1,v1,1
9d001998:	af838028 	sw	v1,-32728(gp)
9d00199c:	24430001 	addiu	v1,v0,1
9d0019a0:	3c02a000 	lui	v0,0xa000
9d0019a4:	ac430280 	sw	v1,640(v0)

            byteToSend--;
9d0019a8:	93c20000 	lbu	v0,0(s8)
9d0019ac:	2442ffff 	addiu	v0,v0,-1
9d0019b0:	a3c20000 	sb	v0,0(s8)
            byteToSend--;
        }
    }
    else  // RAM
    {
        while (byteToSend)
9d0019b4:	93c20000 	lbu	v0,0(s8)
9d0019b8:	1440fff1 	bnez	v0,9d001980 <USBCtrlEPAllowDataStage+0x6b0>
9d0019bc:	00000000 	nop
            *pDst++ = *inPipes[0].Source.pbRam++;

            byteToSend--;
        }
    }//end if(usb_stat.ctrl_trf_mem == _ROM)
}//end USBCtrlTrfTxService
9d0019c0:	03c0e821 	move	sp,s8
9d0019c4:	8fbe000c 	lw	s8,12(sp)
9d0019c8:	27bd0010 	addiu	sp,sp,16
9d0019cc:	03e00008 	jr	ra
9d0019d0:	00000000 	nop
 *					intended target firmware.
 *
 * Note:            None
 *****************************************************************************/
static void USBCtrlTrfRxService(void)
{
9d0019d4:	27bdffe0 	addiu	sp,sp,-32
9d0019d8:	afbf001c 	sw	ra,28(sp)
9d0019dc:	afbe0018 	sw	s8,24(sp)
9d0019e0:	03a0f021 	move	s8,sp
    UINT8 byteToRead;
    UINT8 i;

    //Load byteToRead with the number of bytes the host just sent us in the 
    //last OUT transaction.
    byteToRead = pBDTEntryEP0OutCurrent->CNT;   
9d0019e4:	8f828064 	lw	v0,-32668(gp)
9d0019e8:	90430002 	lbu	v1,2(v0)
9d0019ec:	306300ff 	andi	v1,v1,0xff
9d0019f0:	90420003 	lbu	v0,3(v0)
9d0019f4:	304200ff 	andi	v0,v0,0xff
9d0019f8:	30420003 	andi	v0,v0,0x3
9d0019fc:	00021200 	sll	v0,v0,0x8
9d001a00:	00431025 	or	v0,v0,v1
9d001a04:	3042ffff 	andi	v0,v0,0xffff
9d001a08:	a3c20010 	sb	v0,16(s8)

    //Update the "outPipes[0].wCount.Val", which keeps track of the total number
    //of remaining bytes expected to be received from the host, in the control
    //transfer.  First check to see if the host sent us more bytes than the
    //application firmware was expecting to receive.
    if (byteToRead > outPipes[0].wCount)
9d001a0c:	93c20010 	lbu	v0,16(s8)
9d001a10:	3043ffff 	andi	v1,v0,0xffff
9d001a14:	3c02a000 	lui	v0,0xa000
9d001a18:	24420290 	addiu	v0,v0,656
9d001a1c:	8c420004 	lw	v0,4(v0)
9d001a20:	7c427a00 	ext	v0,v0,0x8,0x10
9d001a24:	3042ffff 	andi	v0,v0,0xffff
9d001a28:	0043102b 	sltu	v0,v0,v1
9d001a2c:	10400007 	beqz	v0,9d001a4c <USBCtrlEPAllowDataStage+0x77c>
9d001a30:	00000000 	nop
    {
        byteToRead = outPipes[0].wCount;
9d001a34:	3c02a000 	lui	v0,0xa000
9d001a38:	24420290 	addiu	v0,v0,656
9d001a3c:	8c420004 	lw	v0,4(v0)
9d001a40:	7c427a00 	ext	v0,v0,0x8,0x10
9d001a44:	3042ffff 	andi	v0,v0,0xffff
9d001a48:	a3c20010 	sb	v0,16(s8)
    }	

    //Reduce the number of remaining bytes by the number we just received.
	outPipes[0].wCount = outPipes[0].wCount - byteToRead;   
9d001a4c:	3c02a000 	lui	v0,0xa000
9d001a50:	24420290 	addiu	v0,v0,656
9d001a54:	8c420004 	lw	v0,4(v0)
9d001a58:	7c427a00 	ext	v0,v0,0x8,0x10
9d001a5c:	3043ffff 	andi	v1,v0,0xffff
9d001a60:	93c20010 	lbu	v0,16(s8)
9d001a64:	3042ffff 	andi	v0,v0,0xffff
9d001a68:	00621023 	subu	v0,v1,v0
9d001a6c:	3044ffff 	andi	a0,v0,0xffff
9d001a70:	3c02a000 	lui	v0,0xa000
9d001a74:	24430290 	addiu	v1,v0,656
9d001a78:	8c620004 	lw	v0,4(v1)
9d001a7c:	7c82ba04 	ins	v0,a0,0x8,0x10
9d001a80:	ac620004 	sw	v0,4(v1)

    //Copy the OUT DATAx packet bytes that we just received from the host,
    //into the user application buffer space.
    for (i = 0; i < byteToRead; i++)
9d001a84:	a3c00011 	sb	zero,17(s8)
9d001a88:	0b4006b3 	j	9d001acc <USBCtrlEPAllowDataStage+0x7fc>
9d001a8c:	00000000 	nop
    {
        *outPipes[0].pDst.pbRam++ = CtrlTrfData[i];
9d001a90:	3c02a000 	lui	v0,0xa000
9d001a94:	8c420290 	lw	v0,656(v0)
9d001a98:	93c40011 	lbu	a0,17(s8)
9d001a9c:	3c03a000 	lui	v1,0xa000
9d001aa0:	24630240 	addiu	v1,v1,576
9d001aa4:	00831821 	addu	v1,a0,v1
9d001aa8:	90630000 	lbu	v1,0(v1)
9d001aac:	306300ff 	andi	v1,v1,0xff
9d001ab0:	a0430000 	sb	v1,0(v0)
9d001ab4:	24430001 	addiu	v1,v0,1
9d001ab8:	3c02a000 	lui	v0,0xa000
9d001abc:	ac430290 	sw	v1,656(v0)
    //Reduce the number of remaining bytes by the number we just received.
	outPipes[0].wCount = outPipes[0].wCount - byteToRead;   

    //Copy the OUT DATAx packet bytes that we just received from the host,
    //into the user application buffer space.
    for (i = 0; i < byteToRead; i++)
9d001ac0:	93c20011 	lbu	v0,17(s8)
9d001ac4:	24420001 	addiu	v0,v0,1
9d001ac8:	a3c20011 	sb	v0,17(s8)
9d001acc:	93c30011 	lbu	v1,17(s8)
9d001ad0:	93c20010 	lbu	v0,16(s8)
9d001ad4:	0062102b 	sltu	v0,v1,v0
9d001ad8:	1440ffed 	bnez	v0,9d001a90 <USBCtrlEPAllowDataStage+0x7c0>
9d001adc:	00000000 	nop
        *outPipes[0].pDst.pbRam++ = CtrlTrfData[i];
    }//end while(byteToRead.Val)

    //If there is more data to receive, prepare EP0 OUT so that it can receive 
	//the next packet in the sequence.
    if (outPipes[0].wCount > 0)
9d001ae0:	3c02a000 	lui	v0,0xa000
9d001ae4:	24420290 	addiu	v0,v0,656
9d001ae8:	8c420004 	lw	v0,4(v0)
9d001aec:	7c427a00 	ext	v0,v0,0x8,0x10
9d001af0:	3042ffff 	andi	v0,v0,0xffff
9d001af4:	10400043 	beqz	v0,9d001c04 <USBCtrlEPAllowDataStage+0x934>
9d001af8:	00000000 	nop
    {
        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9d001afc:	8f828050 	lw	v0,-32688(gp)
9d001b00:	90430002 	lbu	v1,2(v0)
9d001b04:	30630000 	andi	v1,v1,0x0
9d001b08:	34630040 	ori	v1,v1,0x40
9d001b0c:	a0430002 	sb	v1,2(v0)
9d001b10:	90440003 	lbu	a0,3(v0)
9d001b14:	2403fffc 	li	v1,-4
9d001b18:	00831824 	and	v1,a0,v1
9d001b1c:	a0430003 	sb	v1,3(v0)
        pBDTEntryEP0OutNext->ADR = MConvertToPhysicalAddress(&CtrlTrfData);
9d001b20:	8f828050 	lw	v0,-32688(gp)
9d001b24:	3c03a000 	lui	v1,0xa000
9d001b28:	24630240 	addiu	v1,v1,576
9d001b2c:	7c63e000 	ext	v1,v1,0x0,0x1d
9d001b30:	306400ff 	andi	a0,v1,0xff
9d001b34:	90450004 	lbu	a1,4(v0)
9d001b38:	30a50000 	andi	a1,a1,0x0
9d001b3c:	00a42025 	or	a0,a1,a0
9d001b40:	a0440004 	sb	a0,4(v0)
9d001b44:	00032202 	srl	a0,v1,0x8
9d001b48:	308400ff 	andi	a0,a0,0xff
9d001b4c:	90450005 	lbu	a1,5(v0)
9d001b50:	30a50000 	andi	a1,a1,0x0
9d001b54:	00a42025 	or	a0,a1,a0
9d001b58:	a0440005 	sb	a0,5(v0)
9d001b5c:	00032402 	srl	a0,v1,0x10
9d001b60:	308400ff 	andi	a0,a0,0xff
9d001b64:	90450006 	lbu	a1,6(v0)
9d001b68:	30a50000 	andi	a1,a1,0x0
9d001b6c:	00a42025 	or	a0,a1,a0
9d001b70:	a0440006 	sb	a0,6(v0)
9d001b74:	00031e02 	srl	v1,v1,0x18
9d001b78:	90440007 	lbu	a0,7(v0)
9d001b7c:	30840000 	andi	a0,a0,0x0
9d001b80:	00831825 	or	v1,a0,v1
9d001b84:	a0430007 	sb	v1,7(v0)

        if (pBDTEntryEP0OutCurrent->STAT.DTS == 0)
9d001b88:	8f828064 	lw	v0,-32668(gp)
9d001b8c:	90420000 	lbu	v0,0(v0)
9d001b90:	304200ff 	andi	v0,v0,0xff
9d001b94:	30420040 	andi	v0,v0,0x40
9d001b98:	304200ff 	andi	v0,v0,0xff
9d001b9c:	1440000d 	bnez	v0,9d001bd4 <USBCtrlEPAllowDataStage+0x904>
9d001ba0:	00000000 	nop
        {
            pBDTEntryEP0OutNext->STAT.Val = _USIE | _DAT1 | (_DTSEN & _DTS_CHECKING_ENABLED);
9d001ba4:	8f828050 	lw	v0,-32688(gp)
9d001ba8:	90430000 	lbu	v1,0(v0)
9d001bac:	30630000 	andi	v1,v1,0x0
9d001bb0:	00602021 	move	a0,v1
9d001bb4:	2403ffc8 	li	v1,-56
9d001bb8:	00831825 	or	v1,a0,v1
9d001bbc:	a0430000 	sb	v1,0(v0)
9d001bc0:	90430001 	lbu	v1,1(v0)
9d001bc4:	30630000 	andi	v1,v1,0x0
9d001bc8:	a0430001 	sb	v1,1(v0)
9d001bcc:	0b400748 	j	9d001d20 <USBCtrlEPAllowDataStage+0xa50>
9d001bd0:	00000000 	nop
        }
        else
        {
            pBDTEntryEP0OutNext->STAT.Val = _USIE | _DAT0 | (_DTSEN & _DTS_CHECKING_ENABLED);
9d001bd4:	8f828050 	lw	v0,-32688(gp)
9d001bd8:	90430000 	lbu	v1,0(v0)
9d001bdc:	30630000 	andi	v1,v1,0x0
9d001be0:	00602021 	move	a0,v1
9d001be4:	2403ff88 	li	v1,-120
9d001be8:	00831825 	or	v1,a0,v1
9d001bec:	a0430000 	sb	v1,0(v0)
9d001bf0:	90430001 	lbu	v1,1(v0)
9d001bf4:	30630000 	andi	v1,v1,0x0
9d001bf8:	a0430001 	sb	v1,1(v0)
9d001bfc:	0b400748 	j	9d001d20 <USBCtrlEPAllowDataStage+0xa50>
9d001c00:	00000000 	nop
    else
    {
	    //We have received all OUT packets that we were expecting to
	    //receive for the control transfer.  Prepare EP0 OUT to receive
		//the next SETUP transaction that may arrive.
        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9d001c04:	8f828050 	lw	v0,-32688(gp)
9d001c08:	90430002 	lbu	v1,2(v0)
9d001c0c:	30630000 	andi	v1,v1,0x0
9d001c10:	34630040 	ori	v1,v1,0x40
9d001c14:	a0430002 	sb	v1,2(v0)
9d001c18:	90440003 	lbu	a0,3(v0)
9d001c1c:	2403fffc 	li	v1,-4
9d001c20:	00831824 	and	v1,a0,v1
9d001c24:	a0430003 	sb	v1,3(v0)
        pBDTEntryEP0OutNext->ADR = MConvertToPhysicalAddress(&SetupPkt);
9d001c28:	8f828050 	lw	v0,-32688(gp)
9d001c2c:	27838058 	addiu	v1,gp,-32680
9d001c30:	7c63e000 	ext	v1,v1,0x0,0x1d
9d001c34:	306400ff 	andi	a0,v1,0xff
9d001c38:	90450004 	lbu	a1,4(v0)
9d001c3c:	30a50000 	andi	a1,a1,0x0
9d001c40:	00a42025 	or	a0,a1,a0
9d001c44:	a0440004 	sb	a0,4(v0)
9d001c48:	00032202 	srl	a0,v1,0x8
9d001c4c:	308400ff 	andi	a0,a0,0xff
9d001c50:	90450005 	lbu	a1,5(v0)
9d001c54:	30a50000 	andi	a1,a1,0x0
9d001c58:	00a42025 	or	a0,a1,a0
9d001c5c:	a0440005 	sb	a0,5(v0)
9d001c60:	00032402 	srl	a0,v1,0x10
9d001c64:	308400ff 	andi	a0,a0,0xff
9d001c68:	90450006 	lbu	a1,6(v0)
9d001c6c:	30a50000 	andi	a1,a1,0x0
9d001c70:	00a42025 	or	a0,a1,a0
9d001c74:	a0440006 	sb	a0,6(v0)
9d001c78:	00031e02 	srl	v1,v1,0x18
9d001c7c:	90440007 	lbu	a0,7(v0)
9d001c80:	30840000 	andi	a0,a0,0x0
9d001c84:	00831825 	or	v1,a0,v1
9d001c88:	a0430007 	sb	v1,7(v0)
        //Configure EP0 OUT to receive the next SETUP transaction for any future
        //control transfers.  However, set BSTALL in case the host tries to send
        //more data than it claims it was going to send.
        pBDTEntryEP0OutNext->STAT.Val = _USIE | _BSTALL;
9d001c8c:	8f828050 	lw	v0,-32688(gp)
9d001c90:	90430000 	lbu	v1,0(v0)
9d001c94:	30630000 	andi	v1,v1,0x0
9d001c98:	00602021 	move	a0,v1
9d001c9c:	2403ff84 	li	v1,-124
9d001ca0:	00831825 	or	v1,a0,v1
9d001ca4:	a0430000 	sb	v1,0(v0)
9d001ca8:	90430001 	lbu	v1,1(v0)
9d001cac:	30630000 	andi	v1,v1,0x0
9d001cb0:	a0430001 	sb	v1,1(v0)
		//All data bytes for the host to device control write (OUT) have now been
		//received successfully.
		//Go ahead and call the user specified callback function, to use/consume
		//the control transfer data (ex: if the "void (*function)" parameter 
		//was non-NULL when USBEP0Receive() was called).
        if (outPipes[0].pFunc != NULL)
9d001cb4:	3c02a000 	lui	v0,0xa000
9d001cb8:	24420290 	addiu	v0,v0,656
9d001cbc:	8843000a 	lwl	v1,10(v0)
9d001cc0:	00602021 	move	a0,v1
9d001cc4:	98440007 	lwr	a0,7(v0)
9d001cc8:	00801021 	move	v0,a0
9d001ccc:	10400009 	beqz	v0,9d001cf4 <USBCtrlEPAllowDataStage+0xa24>
9d001cd0:	00000000 	nop
        {
            outPipes[0].pFunc();    //Call the user's callback function
9d001cd4:	3c02a000 	lui	v0,0xa000
9d001cd8:	24420290 	addiu	v0,v0,656
9d001cdc:	8843000a 	lwl	v1,10(v0)
9d001ce0:	00602021 	move	a0,v1
9d001ce4:	98440007 	lwr	a0,7(v0)
9d001ce8:	00801021 	move	v0,a0
9d001cec:	0040f809 	jalr	v0
9d001cf0:	00000000 	nop
        }

        outPipes[0].info.bits.busy = 0;    
9d001cf4:	3c02a000 	lui	v0,0xa000
9d001cf8:	24430290 	addiu	v1,v0,656
9d001cfc:	8c620004 	lw	v0,4(v1)
9d001d00:	7c0239c4 	ins	v0,zero,0x7,0x1
9d001d04:	ac620004 	sw	v0,4(v1)
        //Note: The application firmware must process the request and call
        //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
        //means either 50ms, 500ms, or 5 seconds, depending on the type of
        //control transfer.  See the USB 2.0 specification section 9.2.6 for
        //more details.
        if (USBDeferStatusStagePacket == FALSE)
9d001d08:	93828071 	lbu	v0,-32655(gp)
9d001d0c:	304200ff 	andi	v0,v0,0xff
9d001d10:	14400003 	bnez	v0,9d001d20 <USBCtrlEPAllowDataStage+0xa50>
9d001d14:	00000000 	nop
        {
            USBCtrlEPAllowStatusStage();
9d001d18:	0f400429 	jal	9d0010a4 <USBCtrlEPAllowStatusStage>
9d001d1c:	00000000 	nop
        }            
    }    
}//end USBCtrlTrfRxService
9d001d20:	03c0e821 	move	sp,s8
9d001d24:	8fbf001c 	lw	ra,28(sp)
9d001d28:	8fbe0018 	lw	s8,24(sp)
9d001d2c:	27bd0020 	addiu	sp,sp,32
9d001d30:	03e00008 	jr	ra
9d001d34:	00000000 	nop
 *                  function USBCBInitEP().
 *
 * Note:            None
 *******************************************************************/
static void USBStdSetCfgHandler(void)
{
9d001d38:	27bdffe0 	addiu	sp,sp,-32
9d001d3c:	afbf001c 	sw	ra,28(sp)
9d001d40:	afbe0018 	sw	s8,24(sp)
9d001d44:	03a0f021 	move	s8,sp
    UINT8 i;

    // This will generate a zero length packet
    inPipes[0].info.bits.busy = 1;            
9d001d48:	3c02a000 	lui	v0,0xa000
9d001d4c:	24430280 	addiu	v1,v0,640
9d001d50:	8c620004 	lw	v0,4(v1)
9d001d54:	24040001 	li	a0,1
9d001d58:	7c8239c4 	ins	v0,a0,0x7,0x1
9d001d5c:	ac620004 	sw	v0,4(v1)

    // Clear all of the endpoint control registers
    MDisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
9d001d60:	3c02bf88 	lui	v0,0xbf88
9d001d64:	24425310 	addiu	v0,v0,21264
9d001d68:	afc20014 	sw	v0,20(s8)
9d001d6c:	a3c00011 	sb	zero,17(s8)
9d001d70:	0b400766 	j	9d001d98 <USBCtrlEPAllowDataStage+0xac8>
9d001d74:	00000000 	nop
9d001d78:	8fc20014 	lw	v0,20(s8)
9d001d7c:	ac400000 	sw	zero,0(v0)
9d001d80:	8fc20014 	lw	v0,20(s8)
9d001d84:	24420010 	addiu	v0,v0,16
9d001d88:	afc20014 	sw	v0,20(s8)
9d001d8c:	93c20011 	lbu	v0,17(s8)
9d001d90:	24420001 	addiu	v0,v0,1
9d001d94:	a3c20011 	sb	v0,17(s8)
9d001d98:	93c20011 	lbu	v0,17(s8)
9d001d9c:	1040fff6 	beqz	v0,9d001d78 <USBCtrlEPAllowDataStage+0xaa8>
9d001da0:	00000000 	nop

    // Clear all of the BDT entries
    memset((void*)&BDT[0], 0x00, sizeof(BDT));
9d001da4:	3c02a000 	lui	v0,0xa000
9d001da8:	24440200 	addiu	a0,v0,512
9d001dac:	00002821 	move	a1,zero
9d001db0:	24060040 	li	a2,64
9d001db4:	0f401c3e 	jal	9d0070f8 <memset>
9d001db8:	00000000 	nop

    // Assert reset request to all of the Ping Pong buffer pointers
    USBPingPongBufferReset = 1;                                   
9d001dbc:	3c03bf88 	lui	v1,0xbf88
9d001dc0:	8c625250 	lw	v0,21072(v1)
9d001dc4:	24040001 	li	a0,1
9d001dc8:	7c820844 	ins	v0,a0,0x1,0x1
9d001dcc:	ac625250 	sw	v0,21072(v1)

	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
	//the EVEN buffer being the next one that will be used), since we are also 
	//doing a hardware ping pong pointer reset above.
	for (i = 0; i < (UINT8)(USB_MAX_EP_NUMBER + 1u); i++)
9d001dd0:	a3c00010 	sb	zero,16(s8)
9d001dd4:	0b400782 	j	9d001e08 <USBCtrlEPAllowDataStage+0xb38>
9d001dd8:	00000000 	nop
	{
		ep_data_in[i].Val = 0u;
9d001ddc:	93c30010 	lbu	v1,16(s8)
9d001de0:	27828060 	addiu	v0,gp,-32672
9d001de4:	00621021 	addu	v0,v1,v0
9d001de8:	a0400000 	sb	zero,0(v0)
        ep_data_out[i].Val = 0u;
9d001dec:	93c30010 	lbu	v1,16(s8)
9d001df0:	27828040 	addiu	v0,gp,-32704
9d001df4:	00621021 	addu	v0,v1,v0
9d001df8:	a0400000 	sb	zero,0(v0)
    USBPingPongBufferReset = 1;                                   

	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
	//the EVEN buffer being the next one that will be used), since we are also 
	//doing a hardware ping pong pointer reset above.
	for (i = 0; i < (UINT8)(USB_MAX_EP_NUMBER + 1u); i++)
9d001dfc:	93c20010 	lbu	v0,16(s8)
9d001e00:	24420001 	addiu	v0,v0,1
9d001e04:	a3c20010 	sb	v0,16(s8)
9d001e08:	93c20010 	lbu	v0,16(s8)
9d001e0c:	2c420002 	sltiu	v0,v0,2
9d001e10:	1440fff2 	bnez	v0,9d001ddc <USBCtrlEPAllowDataStage+0xb0c>
9d001e14:	00000000 	nop
		ep_data_in[i].Val = 0u;
        ep_data_out[i].Val = 0u;
	}

    //clear the alternate interface settings
    memset(&USBAlternateInterface, 0x00, USB_MAX_NUM_INT);
9d001e18:	27848070 	addiu	a0,gp,-32656
9d001e1c:	00002821 	move	a1,zero
9d001e20:	24060001 	li	a2,1
9d001e24:	0f401c3e 	jal	9d0070f8 <memset>
9d001e28:	00000000 	nop

    //Stop trying to reset ping pong buffer pointers
    USBPingPongBufferReset = 0;
9d001e2c:	3c03bf88 	lui	v1,0xbf88
9d001e30:	8c625250 	lw	v0,21072(v1)
9d001e34:	7c020844 	ins	v0,zero,0x1,0x1
9d001e38:	ac625250 	sw	v0,21072(v1)

    pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
9d001e3c:	3c02a000 	lui	v0,0xa000
9d001e40:	24420210 	addiu	v0,v0,528
9d001e44:	af828038 	sw	v0,-32712(gp)

	//Set the next out to the current out packet
    pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
9d001e48:	3c02a000 	lui	v0,0xa000
9d001e4c:	24420200 	addiu	v0,v0,512
9d001e50:	af828064 	sw	v0,-32668(gp)
    pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
9d001e54:	8f828064 	lw	v0,-32668(gp)
9d001e58:	af828050 	sw	v0,-32688(gp)

    //set the current configuration
    l_USBActiveConfiguration = SetupPkt.bConfigurationValue;
9d001e5c:	9382805a 	lbu	v0,-32678(gp)
9d001e60:	304200ff 	andi	v0,v0,0xff
9d001e64:	a3828010 	sb	v0,-32752(gp)

    //if the configuration value == 0
    if (l_USBActiveConfiguration == 0)
9d001e68:	93828010 	lbu	v0,-32752(gp)
9d001e6c:	14400005 	bnez	v0,9d001e84 <USBCtrlEPAllowDataStage+0xbb4>
9d001e70:	00000000 	nop
    {
        //Go back to the addressed state
        USBDeviceState = ADDRESS_STATE;
9d001e74:	24020010 	li	v0,16
9d001e78:	af828030 	sw	v0,-32720(gp)
9d001e7c:	0b4007a8 	j	9d001ea0 <USBCtrlEPAllowDataStage+0xbd0>
9d001e80:	00000000 	nop
    }
    else
    {
        //initialize the required endpoints
        USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED, (void*)&l_USBActiveConfiguration, 1);
9d001e84:	24040001 	li	a0,1
9d001e88:	27858010 	addiu	a1,gp,-32752
9d001e8c:	24060001 	li	a2,1
9d001e90:	0f4018f1 	jal	9d0063c4 <USER_USB_CALLBACK_EVENT_HANDLER>
9d001e94:	00000000 	nop

        //Otherwise go to the configured state.  Update the state variable last,
        //after performing all of the set configuration related initialization
        //tasks.
        USBDeviceState = CONFIGURED_STATE;		
9d001e98:	24020020 	li	v0,32
9d001e9c:	af828030 	sw	v0,-32720(gp)
    }//end if(SetupPkt.bConfigurationValue == 0)
}//end USBStdSetCfgHandler
9d001ea0:	03c0e821 	move	sp,s8
9d001ea4:	8fbf001c 	lw	ra,28(sp)
9d001ea8:	8fbe0018 	lw	s8,24(sp)
9d001eac:	27bd0020 	addiu	sp,sp,32
9d001eb0:	03e00008 	jr	ra
9d001eb4:	00000000 	nop
 *                  request.
 *
 * Note:            None
 *******************************************************************/
static void USBStdGetDscHandler(void)
{
9d001eb8:	27bdfff0 	addiu	sp,sp,-16
9d001ebc:	afbe000c 	sw	s8,12(sp)
9d001ec0:	03a0f021 	move	s8,sp
    if (SetupPkt.bmRequestType == 0x80)
9d001ec4:	93828058 	lbu	v0,-32680(gp)
9d001ec8:	304300ff 	andi	v1,v0,0xff
9d001ecc:	24020080 	li	v0,128
9d001ed0:	14620067 	bne	v1,v0,9d002070 <USBCtrlEPAllowDataStage+0xda0>
9d001ed4:	00000000 	nop
    {
        inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
9d001ed8:	3c02a000 	lui	v0,0xa000
9d001edc:	24420280 	addiu	v0,v0,640
9d001ee0:	2403ffc0 	li	v1,-64
9d001ee4:	a0430004 	sb	v1,4(v0)

        switch (SetupPkt.bDescriptorType)
9d001ee8:	9382805b 	lbu	v0,-32677(gp)
9d001eec:	304200ff 	andi	v0,v0,0xff
9d001ef0:	24030002 	li	v1,2
9d001ef4:	10430011 	beq	v0,v1,9d001f3c <USBCtrlEPAllowDataStage+0xc6c>
9d001ef8:	00000000 	nop
9d001efc:	24030003 	li	v1,3
9d001f00:	10430029 	beq	v0,v1,9d001fa8 <USBCtrlEPAllowDataStage+0xcd8>
9d001f04:	00000000 	nop
9d001f08:	24030001 	li	v1,1
9d001f0c:	14430054 	bne	v0,v1,9d002060 <USBCtrlEPAllowDataStage+0xd90>
9d001f10:	00000000 	nop
        {
            case USB_DESCRIPTOR_DEVICE:
                inPipes[0].Source.pbRom = (ROM UINT8*)&g_DeviceDescriptor;
9d001f14:	3c02a000 	lui	v0,0xa000
9d001f18:	3c039d00 	lui	v1,0x9d00
9d001f1c:	24636ed8 	addiu	v1,v1,28376
9d001f20:	ac430280 	sw	v1,640(v0)
                inPipes[0].wCount = sizeof(g_DeviceDescriptor);
9d001f24:	3c02a000 	lui	v0,0xa000
9d001f28:	24420280 	addiu	v0,v0,640
9d001f2c:	24030012 	li	v1,18
9d001f30:	a4430008 	sh	v1,8(v0)
                break;
9d001f34:	0b40081c 	j	9d002070 <USBCtrlEPAllowDataStage+0xda0>
9d001f38:	00000000 	nop
            case USB_DESCRIPTOR_CONFIGURATION:
                inPipes[0].Source.pbRom = *(USB_CD_Ptr + SetupPkt.bDscIndex);
9d001f3c:	9382805a 	lbu	v0,-32678(gp)
9d001f40:	304200ff 	andi	v0,v0,0xff
9d001f44:	00021880 	sll	v1,v0,0x2
9d001f48:	3c029d00 	lui	v0,0x9d00
9d001f4c:	24426f4c 	addiu	v0,v0,28492
9d001f50:	00621021 	addu	v0,v1,v0
9d001f54:	8c430000 	lw	v1,0(v0)
9d001f58:	3c02a000 	lui	v0,0xa000
9d001f5c:	ac430280 	sw	v1,640(v0)

                //This must be loaded using byte addressing.  The source pointer
                //  may not be word aligned for the 16 or 32 bit machines resulting
                //  in an address error on the dereference.

                UINT8* pCount = (UINT8*)(&inPipes[0].wCount);
9d001f60:	3c02a000 	lui	v0,0xa000
9d001f64:	24420288 	addiu	v0,v0,648
9d001f68:	afc20000 	sw	v0,0(s8)
                    
                *pCount = *(inPipes[0].Source.pbRom + 2);
9d001f6c:	3c02a000 	lui	v0,0xa000
9d001f70:	8c420280 	lw	v0,640(v0)
9d001f74:	24420002 	addiu	v0,v0,2
9d001f78:	90430000 	lbu	v1,0(v0)
9d001f7c:	8fc20000 	lw	v0,0(s8)
9d001f80:	a0430000 	sb	v1,0(v0)
                *(pCount + 1) = *(inPipes[0].Source.pbRom + 3);
9d001f84:	8fc20000 	lw	v0,0(s8)
9d001f88:	24420001 	addiu	v0,v0,1
9d001f8c:	3c03a000 	lui	v1,0xa000
9d001f90:	8c630280 	lw	v1,640(v1)
9d001f94:	24630003 	addiu	v1,v1,3
9d001f98:	90630000 	lbu	v1,0(v1)
9d001f9c:	a0430000 	sb	v1,0(v0)
                break;
9d001fa0:	0b40081c 	j	9d002070 <USBCtrlEPAllowDataStage+0xda0>
9d001fa4:	00000000 	nop
            case USB_DESCRIPTOR_STRING:
                // USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
                //  later it is now mandatory.  This should be defined in usb_config.h and should
                //  indicate the number of string descriptors.
                if (SetupPkt.bDscIndex < USB_NUM_STRING_DESCRIPTORS)
9d001fa8:	9382805a 	lbu	v0,-32678(gp)
9d001fac:	304200ff 	andi	v0,v0,0xff
9d001fb0:	2c420003 	sltiu	v0,v0,3
9d001fb4:	10400013 	beqz	v0,9d002004 <USBCtrlEPAllowDataStage+0xd34>
9d001fb8:	00000000 	nop
                {
                    //Get a pointer to the String descriptor requested
                    inPipes[0].Source.pbRom = *(USB_SD_Ptr + SetupPkt.bDscIndex);
9d001fbc:	9382805a 	lbu	v0,-32678(gp)
9d001fc0:	304200ff 	andi	v0,v0,0xff
9d001fc4:	00021880 	sll	v1,v0,0x2
9d001fc8:	3c029d00 	lui	v0,0x9d00
9d001fcc:	24426f50 	addiu	v0,v0,28496
9d001fd0:	00621021 	addu	v0,v1,v0
9d001fd4:	8c430000 	lw	v1,0(v0)
9d001fd8:	3c02a000 	lui	v0,0xa000
9d001fdc:	ac430280 	sw	v1,640(v0)
                    
                    // Set data count
                    inPipes[0].wCount = *inPipes[0].Source.pbRom;                    
9d001fe0:	3c02a000 	lui	v0,0xa000
9d001fe4:	8c420280 	lw	v0,640(v0)
9d001fe8:	90420000 	lbu	v0,0(v0)
9d001fec:	00401821 	move	v1,v0
9d001ff0:	3c02a000 	lui	v0,0xa000
9d001ff4:	24420280 	addiu	v0,v0,640
9d001ff8:	a4430008 	sh	v1,8(v0)
#endif
                else
                {
                    inPipes[0].info.Val = 0;
                }
                break;
9d001ffc:	0b40081c 	j	9d002070 <USBCtrlEPAllowDataStage+0xda0>
9d002000:	00000000 	nop
                    
                    // Set data count
                    inPipes[0].wCount = *inPipes[0].Source.pbRom;                    
                }
#if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
                else if (SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
9d002004:	9382805a 	lbu	v0,-32678(gp)
9d002008:	304300ff 	andi	v1,v0,0xff
9d00200c:	240200ee 	li	v0,238
9d002010:	1462000e 	bne	v1,v0,9d00204c <USBCtrlEPAllowDataStage+0xd7c>
9d002014:	00000000 	nop
                {
                    //Get a pointer to the special MS OS string descriptor requested
                    inPipes[0].Source.pbRom = (ROM UINT8*)&MSOSDescriptor;
9d002018:	3c02a000 	lui	v0,0xa000
9d00201c:	3c039d00 	lui	v1,0x9d00
9d002020:	24636f5c 	addiu	v1,v1,28508
9d002024:	ac430280 	sw	v1,640(v0)
                    
                    // Set data count
                    inPipes[0].wCount = *inPipes[0].Source.pbRom;                    
9d002028:	3c02a000 	lui	v0,0xa000
9d00202c:	8c420280 	lw	v0,640(v0)
9d002030:	90420000 	lbu	v0,0(v0)
9d002034:	00401821 	move	v1,v0
9d002038:	3c02a000 	lui	v0,0xa000
9d00203c:	24420280 	addiu	v0,v0,640
9d002040:	a4430008 	sh	v1,8(v0)
#endif
                else
                {
                    inPipes[0].info.Val = 0;
                }
                break;
9d002044:	0b40081c 	j	9d002070 <USBCtrlEPAllowDataStage+0xda0>
9d002048:	00000000 	nop
                    inPipes[0].wCount = *inPipes[0].Source.pbRom;                    
                }    
#endif
                else
                {
                    inPipes[0].info.Val = 0;
9d00204c:	3c02a000 	lui	v0,0xa000
9d002050:	24420280 	addiu	v0,v0,640
9d002054:	a0400004 	sb	zero,4(v0)
                }
                break;
9d002058:	0b40081c 	j	9d002070 <USBCtrlEPAllowDataStage+0xda0>
9d00205c:	00000000 	nop
            default:
                inPipes[0].info.Val = 0;
9d002060:	3c02a000 	lui	v0,0xa000
9d002064:	24420280 	addiu	v0,v0,640
9d002068:	a0400004 	sb	zero,4(v0)
                break;
9d00206c:	00000000 	nop
        }//end switch
    }//end if
}//end USBStdGetDscHandler
9d002070:	03c0e821 	move	sp,s8
9d002074:	8fbe000c 	lw	s8,12(sp)
9d002078:	27bd0010 	addiu	sp,sp,16
9d00207c:	03e00008 	jr	ra
9d002080:	00000000 	nop
 * Overview:        This routine handles the standard GET_STATUS request
 *
 * Note:            None
 *******************************************************************/
static void USBStdGetStatusHandler(void)
{
9d002084:	27bdfff0 	addiu	sp,sp,-16
9d002088:	afbe000c 	sw	s8,12(sp)
9d00208c:	03a0f021 	move	s8,sp
    CtrlTrfData[0] = 0;                 // Initialize content
9d002090:	3c02a000 	lui	v0,0xa000
9d002094:	a0400240 	sb	zero,576(v0)
    CtrlTrfData[1] = 0;
9d002098:	3c02a000 	lui	v0,0xa000
9d00209c:	24420240 	addiu	v0,v0,576
9d0020a0:	a0400001 	sb	zero,1(v0)

    switch (SetupPkt.Recipient)
9d0020a4:	8f828058 	lw	v0,-32680(gp)
9d0020a8:	7c422000 	ext	v0,v0,0x0,0x5
9d0020ac:	304200ff 	andi	v0,v0,0xff
9d0020b0:	24030001 	li	v1,1
9d0020b4:	10430019 	beq	v0,v1,9d00211c <USBCtrlEPAllowDataStage+0xe4c>
9d0020b8:	00000000 	nop
9d0020bc:	24030002 	li	v1,2
9d0020c0:	1043001e 	beq	v0,v1,9d00213c <USBCtrlEPAllowDataStage+0xe6c>
9d0020c4:	00000000 	nop
9d0020c8:	14400054 	bnez	v0,9d00221c <USBCtrlEPAllowDataStage+0xf4c>
9d0020cc:	00000000 	nop
    {
        case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
            inPipes[0].info.bits.busy = 1;
9d0020d0:	3c02a000 	lui	v0,0xa000
9d0020d4:	24430280 	addiu	v1,v0,640
9d0020d8:	8c620004 	lw	v0,4(v1)
9d0020dc:	24040001 	li	a0,1
9d0020e0:	7c8239c4 	ins	v0,a0,0x7,0x1
9d0020e4:	ac620004 	sw	v0,4(v1)
            /*if (self_power == 1) // self_power is defined in HardwareProfile.h
            {
                CtrlTrfData[0] |= 0x01;
            }*/

            if (RemoteWakeup == TRUE)
9d0020e8:	93838068 	lbu	v1,-32664(gp)
9d0020ec:	24020001 	li	v0,1
9d0020f0:	14620043 	bne	v1,v0,9d002200 <USBCtrlEPAllowDataStage+0xf30>
9d0020f4:	00000000 	nop
            {
                CtrlTrfData[0] |= 0x02;
9d0020f8:	3c02a000 	lui	v0,0xa000
9d0020fc:	90420240 	lbu	v0,576(v0)
9d002100:	304200ff 	andi	v0,v0,0xff
9d002104:	34420002 	ori	v0,v0,0x2
9d002108:	304300ff 	andi	v1,v0,0xff
9d00210c:	3c02a000 	lui	v0,0xa000
9d002110:	a0430240 	sb	v1,576(v0)
            }
            break;
9d002114:	0b400887 	j	9d00221c <USBCtrlEPAllowDataStage+0xf4c>
9d002118:	00000000 	nop
        case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
            inPipes[0].info.bits.busy = 1;     // No data to update
9d00211c:	3c02a000 	lui	v0,0xa000
9d002120:	24430280 	addiu	v1,v0,640
9d002124:	8c620004 	lw	v0,4(v1)
9d002128:	24040001 	li	a0,1
9d00212c:	7c8239c4 	ins	v0,a0,0x7,0x1
9d002130:	ac620004 	sw	v0,4(v1)
            break;
9d002134:	0b400887 	j	9d00221c <USBCtrlEPAllowDataStage+0xf4c>
9d002138:	00000000 	nop
        case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
            inPipes[0].info.bits.busy = 1;
9d00213c:	3c02a000 	lui	v0,0xa000
9d002140:	24430280 	addiu	v1,v0,640
9d002144:	8c620004 	lw	v0,4(v1)
9d002148:	24040001 	li	a0,1
9d00214c:	7c8239c4 	ins	v0,a0,0x7,0x1
9d002150:	ac620004 	sw	v0,4(v1)
             * [0]: bit0: Halt Status [0] Not Halted [1] Halted
             */
            {
                BDT_ENTRY *p;

                if (SetupPkt.EPDir == 0)
9d002154:	9382805c 	lbu	v0,-32676(gp)
9d002158:	304300ff 	andi	v1,v0,0xff
9d00215c:	2402ff80 	li	v0,-128
9d002160:	00621024 	and	v0,v1,v0
9d002164:	304200ff 	andi	v0,v0,0xff
9d002168:	1440000b 	bnez	v0,9d002198 <USBCtrlEPAllowDataStage+0xec8>
9d00216c:	00000000 	nop
                {
                    p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
9d002170:	8f82805c 	lw	v0,-32676(gp)
9d002174:	7c421800 	ext	v0,v0,0x0,0x4
9d002178:	304200ff 	andi	v0,v0,0xff
9d00217c:	00021880 	sll	v1,v0,0x2
9d002180:	27828044 	addiu	v0,gp,-32700
9d002184:	00621021 	addu	v0,v1,v0
9d002188:	8c420000 	lw	v0,0(v0)
9d00218c:	afc20000 	sw	v0,0(s8)
9d002190:	0b40086e 	j	9d0021b8 <USBCtrlEPAllowDataStage+0xee8>
9d002194:	00000000 	nop
                }
                else
                {
                    p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
9d002198:	8f82805c 	lw	v0,-32676(gp)
9d00219c:	7c421800 	ext	v0,v0,0x0,0x4
9d0021a0:	304200ff 	andi	v0,v0,0xff
9d0021a4:	00021880 	sll	v1,v0,0x2
9d0021a8:	27828038 	addiu	v0,gp,-32712
9d0021ac:	00621021 	addu	v0,v1,v0
9d0021b0:	8c420000 	lw	v0,0(v0)
9d0021b4:	afc20000 	sw	v0,0(s8)
                }

                if ((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
9d0021b8:	8fc20000 	lw	v0,0(s8)
9d0021bc:	90430000 	lbu	v1,0(v0)
9d0021c0:	2402ff80 	li	v0,-128
9d0021c4:	00621024 	and	v0,v1,v0
9d0021c8:	304200ff 	andi	v0,v0,0xff
9d0021cc:	1040000f 	beqz	v0,9d00220c <USBCtrlEPAllowDataStage+0xf3c>
9d0021d0:	00000000 	nop
9d0021d4:	8fc20000 	lw	v0,0(s8)
9d0021d8:	90420000 	lbu	v0,0(v0)
9d0021dc:	30420004 	andi	v0,v0,0x4
9d0021e0:	304200ff 	andi	v0,v0,0xff
9d0021e4:	1040000c 	beqz	v0,9d002218 <USBCtrlEPAllowDataStage+0xf48>
9d0021e8:	00000000 	nop
                {
                    CtrlTrfData[0]=0x01;    // Set bit0
9d0021ec:	3c02a000 	lui	v0,0xa000
9d0021f0:	24030001 	li	v1,1
9d0021f4:	a0430240 	sb	v1,576(v0)
                }
                break;
9d0021f8:	0b400887 	j	9d00221c <USBCtrlEPAllowDataStage+0xf4c>
9d0021fc:	00000000 	nop

            if (RemoteWakeup == TRUE)
            {
                CtrlTrfData[0] |= 0x02;
            }
            break;
9d002200:	00000000 	nop
9d002204:	0b400887 	j	9d00221c <USBCtrlEPAllowDataStage+0xf4c>
9d002208:	00000000 	nop

                if ((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
                {
                    CtrlTrfData[0]=0x01;    // Set bit0
                }
                break;
9d00220c:	00000000 	nop
9d002210:	0b400887 	j	9d00221c <USBCtrlEPAllowDataStage+0xf4c>
9d002214:	00000000 	nop
9d002218:	00000000 	nop
            }
    }//end switch

    if (inPipes[0].info.bits.busy == 1)
9d00221c:	3c02a000 	lui	v0,0xa000
9d002220:	24420280 	addiu	v0,v0,640
9d002224:	8c420004 	lw	v0,4(v0)
9d002228:	30420080 	andi	v0,v0,0x80
9d00222c:	1040000f 	beqz	v0,9d00226c <USBCtrlEPAllowDataStage+0xf9c>
9d002230:	00000000 	nop
    {
        inPipes[0].Source.pbRam = (UINT8*)&CtrlTrfData;  // Set Source
9d002234:	3c02a000 	lui	v0,0xa000
9d002238:	3c03a000 	lui	v1,0xa000
9d00223c:	24630240 	addiu	v1,v1,576
9d002240:	ac430280 	sw	v1,640(v0)
        inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM; // Set memory type
9d002244:	3c02a000 	lui	v0,0xa000
9d002248:	24430280 	addiu	v1,v0,640
9d00224c:	8c620004 	lw	v0,4(v1)
9d002250:	24040001 	li	a0,1
9d002254:	7c820004 	ins	v0,a0,0x0,0x1
9d002258:	ac620004 	sw	v0,4(v1)
        inPipes[0].wCount = 2;                           // set data count
9d00225c:	3c02a000 	lui	v0,0xa000
9d002260:	24420280 	addiu	v0,v0,640
9d002264:	24030002 	li	v1,2
9d002268:	a4430008 	sh	v1,8(v0)
    }
}//end USBStdGetStatusHandler
9d00226c:	03c0e821 	move	sp,s8
9d002270:	8fbe000c 	lw	s8,12(sp)
9d002274:	27bd0010 	addiu	sp,sp,16
9d002278:	03e00008 	jr	ra
9d00227c:	00000000 	nop
 *                  occuring on the bus
 *
 * Note:            None
 *******************************************************************/
static void USBStallHandler(void)
{
9d002280:	27bdfff8 	addiu	sp,sp,-8
9d002284:	afbe0004 	sw	s8,4(sp)
9d002288:	03a0f021 	move	s8,sp
     * When the Setup Transaction is serviced, the ownership
     * for EP0_IN will then be forced back to CPU by firmware.
     */

    /* v2b fix */
    if (U1EP0bits.EPSTALL == 1)
9d00228c:	3c02bf88 	lui	v0,0xbf88
9d002290:	8c425300 	lw	v0,21248(v0)
9d002294:	30420002 	andi	v0,v0,0x2
9d002298:	10400025 	beqz	v0,9d002330 <USBCtrlEPAllowDataStage+0x1060>
9d00229c:	00000000 	nop
    {
        // UOWN - if 0, owned by CPU, if 1, owned by SIE
        if ((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE | _BSTALL)))
9d0022a0:	8f828064 	lw	v0,-32668(gp)
9d0022a4:	90430000 	lbu	v1,0(v0)
9d0022a8:	306300ff 	andi	v1,v1,0xff
9d0022ac:	90420001 	lbu	v0,1(v0)
9d0022b0:	304200ff 	andi	v0,v0,0xff
9d0022b4:	00021200 	sll	v0,v0,0x8
9d0022b8:	00431025 	or	v0,v0,v1
9d0022bc:	3043ffff 	andi	v1,v0,0xffff
9d0022c0:	24020080 	li	v0,128
9d0022c4:	14620016 	bne	v1,v0,9d002320 <USBCtrlEPAllowDataStage+0x1050>
9d0022c8:	00000000 	nop
9d0022cc:	8f828038 	lw	v0,-32712(gp)
9d0022d0:	90430000 	lbu	v1,0(v0)
9d0022d4:	306300ff 	andi	v1,v1,0xff
9d0022d8:	90420001 	lbu	v0,1(v0)
9d0022dc:	304200ff 	andi	v0,v0,0xff
9d0022e0:	00021200 	sll	v0,v0,0x8
9d0022e4:	00431025 	or	v0,v0,v1
9d0022e8:	3043ffff 	andi	v1,v0,0xffff
9d0022ec:	24020084 	li	v0,132
9d0022f0:	1462000b 	bne	v1,v0,9d002320 <USBCtrlEPAllowDataStage+0x1050>
9d0022f4:	00000000 	nop
        {
            // Set ep0 to stall also
            pBDTEntryEP0OutCurrent->STAT.Val = _USIE | _DAT0 | (_DTSEN & _DTS_CHECKING_ENABLED) | _BSTALL;
9d0022f8:	8f828064 	lw	v0,-32668(gp)
9d0022fc:	90430000 	lbu	v1,0(v0)
9d002300:	30630000 	andi	v1,v1,0x0
9d002304:	00602021 	move	a0,v1
9d002308:	2403ff8c 	li	v1,-116
9d00230c:	00831825 	or	v1,a0,v1
9d002310:	a0430000 	sb	v1,0(v0)
9d002314:	90430001 	lbu	v1,1(v0)
9d002318:	30630000 	andi	v1,v1,0x0
9d00231c:	a0430001 	sb	v1,1(v0)
        }//end if

        U1EP0bits.EPSTALL = 0;               // Clear stall status
9d002320:	3c03bf88 	lui	v1,0xbf88
9d002324:	8c625300 	lw	v0,21248(v1)
9d002328:	7c020844 	ins	v0,zero,0x1,0x1
9d00232c:	ac625300 	sw	v0,21248(v1)
    }//end if

    USBClearInterruptFlag(USBStallIFReg, USBStallIFBitNum);
9d002330:	3c02bf88 	lui	v0,0xbf88
9d002334:	24030080 	li	v1,128
9d002338:	ac435200 	sw	v1,20992(v0)
}
9d00233c:	03c0e821 	move	sp,s8
9d002340:	8fbe0004 	lw	s8,4(sp)
9d002344:	27bd0008 	addiu	sp,sp,8
9d002348:	03e00008 	jr	ra
9d00234c:	00000000 	nop
 *                  suspend the device
 *
 * Note:            None
 *******************************************************************/
static void USBSuspend(void)
{
9d002350:	27bdffe8 	addiu	sp,sp,-24
9d002354:	afbf0014 	sw	ra,20(sp)
9d002358:	afbe0010 	sw	s8,16(sp)
9d00235c:	03a0f021 	move	s8,sp
     *                          because ACTIVIE=0.
     *                          If this routine clears the only ACTIVIF,
     *                          then it can never get out of the suspend
     *                          mode.
     */
    USBActivityIE = 1;                     // Enable bus activity interrupt
9d002360:	3c03bf88 	lui	v1,0xbf88
9d002364:	8c625050 	lw	v0,20560(v1)
9d002368:	24040001 	li	a0,1
9d00236c:	7c822104 	ins	v0,a0,0x4,0x1
9d002370:	ac625050 	sw	v0,20560(v1)
    USBClearInterruptFlag(USBIdleIFReg, USBIdleIFBitNum);
9d002374:	3c02bf88 	lui	v0,0xbf88
9d002378:	24030010 	li	v1,16
9d00237c:	ac435200 	sw	v1,20992(v0)

    USBBusIsSuspended = TRUE;
9d002380:	24020001 	li	v0,1
9d002384:	a3828054 	sb	v0,-32684(gp)
    /*
     * At this point the PIC can go into sleep,idle, or
     * switch to a slower clock, etc.  This should be done in the
     * USBCBSuspend() if necessary.
     */
    USB_SUSPEND_HANDLER(EVENT_SUSPEND, 0, 0);
9d002388:	24040075 	li	a0,117
9d00238c:	00002821 	move	a1,zero
9d002390:	00003021 	move	a2,zero
9d002394:	0f4018f1 	jal	9d0063c4 <USER_USB_CALLBACK_EVENT_HANDLER>
9d002398:	00000000 	nop
}
9d00239c:	03c0e821 	move	sp,s8
9d0023a0:	8fbf0014 	lw	ra,20(sp)
9d0023a4:	8fbe0010 	lw	s8,16(sp)
9d0023a8:	27bd0018 	addiu	sp,sp,24
9d0023ac:	03e00008 	jr	ra
9d0023b0:	00000000 	nop
 * Overview:
 *
 * Note:            None
 *******************************************************************/
static void USBWakeFromSuspend(void)
{
9d0023b4:	27bdffe8 	addiu	sp,sp,-24
9d0023b8:	afbf0014 	sw	ra,20(sp)
9d0023bc:	afbe0010 	sw	s8,16(sp)
9d0023c0:	03a0f021 	move	s8,sp
    USBBusIsSuspended = FALSE;
9d0023c4:	a3808054 	sb	zero,-32684(gp)

    /*
     * If using clock switching, the place to restore the original
     * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
     */
    USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME, 0, 0);
9d0023c8:	24040074 	li	a0,116
9d0023cc:	00002821 	move	a1,zero
9d0023d0:	00003021 	move	a2,zero
9d0023d4:	0f4018f1 	jal	9d0063c4 <USER_USB_CALLBACK_EVENT_HANDLER>
9d0023d8:	00000000 	nop

    USBActivityIE = 0;
9d0023dc:	3c03bf88 	lui	v1,0xbf88
9d0023e0:	8c625050 	lw	v0,20560(v1)
9d0023e4:	7c022104 	ins	v0,zero,0x4,0x1
9d0023e8:	ac625050 	sw	v0,20560(v1)
    module may not be immediately operational while waiting for the 96 MHz
    PLL to lock.
    ********************************************************************/

    // UIRbits.ACTVIF = 0;                      // Removed
    USBClearInterruptFlag(USBActivityIFReg, USBActivityIFBitNum);
9d0023ec:	3c02bf88 	lui	v0,0xbf88
9d0023f0:	24030010 	li	v1,16
9d0023f4:	ac435040 	sw	v1,20544(v0)
}//end USBWakeFromSuspend
9d0023f8:	03c0e821 	move	sp,s8
9d0023fc:	8fbf0014 	lw	ra,20(sp)
9d002400:	8fbe0010 	lw	s8,16(sp)
9d002404:	27bd0018 	addiu	sp,sp,24
9d002408:	03e00008 	jr	ra
9d00240c:	00000000 	nop
 *                  It ignores all other types (i.e. EP1, EP2, etc.)
 *
 * Note:            None
 *******************************************************************/
static void USBCtrlEPService(void)
{
9d002410:	27bdffe0 	addiu	sp,sp,-32
9d002414:	afbf001c 	sw	ra,28(sp)
9d002418:	afbe0018 	sw	s8,24(sp)
9d00241c:	03a0f021 	move	s8,sp
    //If we get to here, that means a successful transaction has just occurred 
    //on EP0.  This means "progress" has occurred in the currently pending 
    //control transfer, so we should re-initialize our timeout counter.
#if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
    USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
9d002420:	2402002d 	li	v0,45
9d002424:	a3828055 	sb	v0,-32683(gp)
#endif
	
	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
    if ((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
9d002428:	9382806c 	lbu	v0,-32660(gp)
9d00242c:	00401821 	move	v1,v0
9d002430:	2402fffb 	li	v0,-5
9d002434:	00621024 	and	v0,v1,v0
9d002438:	14400081 	bnez	v0,9d002640 <USBCtrlEPAllowDataStage+0x1370>
9d00243c:	00000000 	nop
    {
		//Point to the EP0 OUT buffer of the buffer that arrived
        pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK) >> 2];
9d002440:	9382806c 	lbu	v0,-32660(gp)
9d002444:	00021082 	srl	v0,v0,0x2
9d002448:	304200ff 	andi	v0,v0,0xff
9d00244c:	000218c0 	sll	v1,v0,0x3
9d002450:	3c02a000 	lui	v0,0xa000
9d002454:	24420200 	addiu	v0,v0,512
9d002458:	00621021 	addu	v0,v1,v0
9d00245c:	af828064 	sw	v0,-32668(gp)

		//Set the next out to the current out packet
        pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
9d002460:	8f828064 	lw	v0,-32668(gp)
9d002464:	af828050 	sw	v0,-32688(gp)
		//Toggle it to the next ping pong buffer (if applicable)
        *((UINT8*)&pBDTEntryEP0OutNext) ^= USB_NEXT_EP0_OUT_PING_PONG;
9d002468:	27828050 	addiu	v0,gp,-32688
9d00246c:	27838050 	addiu	v1,gp,-32688
9d002470:	90630000 	lbu	v1,0(v1)
9d002474:	38630008 	xori	v1,v1,0x8
9d002478:	306300ff 	andi	v1,v1,0xff
9d00247c:	a0430000 	sb	v1,0(v0)

		//If the current EP0 OUT buffer has a SETUP packet
        if (pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
9d002480:	8f828064 	lw	v0,-32668(gp)
9d002484:	90420000 	lbu	v0,0(v0)
9d002488:	304200ff 	andi	v0,v0,0xff
9d00248c:	3042003c 	andi	v0,v0,0x3c
9d002490:	304300ff 	andi	v1,v0,0xff
9d002494:	24020034 	li	v0,52
9d002498:	14620065 	bne	v1,v0,9d002630 <USBCtrlEPAllowDataStage+0x1360>
9d00249c:	00000000 	nop

	        //The SETUP transaction data may have gone into the the CtrlTrfData 
	        //buffer, or elsewhere, depending upon how the BDT was prepared
	        //before the transaction.  Therefore, we should copy the data to the 
	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
            for(setup_cnt = 0; setup_cnt < 8u; setup_cnt++) //SETUP data packets always contain exactly 8 bytes.
9d0024a0:	a3c00010 	sb	zero,16(s8)
9d0024a4:	0b40096b 	j	9d0025ac <USBCtrlEPAllowDataStage+0x12dc>
9d0024a8:	00000000 	nop
            {
                *(UINT8*)((UINT8*)&SetupPkt + setup_cnt) = *(UINT8*)MConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR);
9d0024ac:	93c30010 	lbu	v1,16(s8)
9d0024b0:	27828058 	addiu	v0,gp,-32680
9d0024b4:	00621821 	addu	v1,v1,v0
9d0024b8:	8f828064 	lw	v0,-32668(gp)
9d0024bc:	90440004 	lbu	a0,4(v0)
9d0024c0:	308400ff 	andi	a0,a0,0xff
9d0024c4:	90450005 	lbu	a1,5(v0)
9d0024c8:	30a500ff 	andi	a1,a1,0xff
9d0024cc:	00052a00 	sll	a1,a1,0x8
9d0024d0:	00a42025 	or	a0,a1,a0
9d0024d4:	90450006 	lbu	a1,6(v0)
9d0024d8:	30a500ff 	andi	a1,a1,0xff
9d0024dc:	00052c00 	sll	a1,a1,0x10
9d0024e0:	00a42025 	or	a0,a1,a0
9d0024e4:	90420007 	lbu	v0,7(v0)
9d0024e8:	304200ff 	andi	v0,v0,0xff
9d0024ec:	00021600 	sll	v0,v0,0x18
9d0024f0:	00441025 	or	v0,v0,a0
9d0024f4:	00402021 	move	a0,v0
9d0024f8:	3c02a000 	lui	v0,0xa000
9d0024fc:	00821025 	or	v0,a0,v0
9d002500:	90420000 	lbu	v0,0(v0)
9d002504:	a0620000 	sb	v0,0(v1)

                pBDTEntryEP0OutCurrent->ADR++;
9d002508:	8f828064 	lw	v0,-32668(gp)
9d00250c:	90430004 	lbu	v1,4(v0)
9d002510:	306300ff 	andi	v1,v1,0xff
9d002514:	90440005 	lbu	a0,5(v0)
9d002518:	308400ff 	andi	a0,a0,0xff
9d00251c:	00042200 	sll	a0,a0,0x8
9d002520:	00831825 	or	v1,a0,v1
9d002524:	90440006 	lbu	a0,6(v0)
9d002528:	308400ff 	andi	a0,a0,0xff
9d00252c:	00042400 	sll	a0,a0,0x10
9d002530:	00831825 	or	v1,a0,v1
9d002534:	90440007 	lbu	a0,7(v0)
9d002538:	308400ff 	andi	a0,a0,0xff
9d00253c:	00042600 	sll	a0,a0,0x18
9d002540:	00831825 	or	v1,a0,v1
9d002544:	24630001 	addiu	v1,v1,1
9d002548:	306400ff 	andi	a0,v1,0xff
9d00254c:	90450004 	lbu	a1,4(v0)
9d002550:	30a50000 	andi	a1,a1,0x0
9d002554:	00a42025 	or	a0,a1,a0
9d002558:	a0440004 	sb	a0,4(v0)
9d00255c:	00032202 	srl	a0,v1,0x8
9d002560:	308400ff 	andi	a0,a0,0xff
9d002564:	90450005 	lbu	a1,5(v0)
9d002568:	30a50000 	andi	a1,a1,0x0
9d00256c:	00a42025 	or	a0,a1,a0
9d002570:	a0440005 	sb	a0,5(v0)
9d002574:	00032402 	srl	a0,v1,0x10
9d002578:	308400ff 	andi	a0,a0,0xff
9d00257c:	90450006 	lbu	a1,6(v0)
9d002580:	30a50000 	andi	a1,a1,0x0
9d002584:	00a42025 	or	a0,a1,a0
9d002588:	a0440006 	sb	a0,6(v0)
9d00258c:	00031e02 	srl	v1,v1,0x18
9d002590:	90440007 	lbu	a0,7(v0)
9d002594:	30840000 	andi	a0,a0,0x0
9d002598:	00831825 	or	v1,a0,v1
9d00259c:	a0430007 	sb	v1,7(v0)

	        //The SETUP transaction data may have gone into the the CtrlTrfData 
	        //buffer, or elsewhere, depending upon how the BDT was prepared
	        //before the transaction.  Therefore, we should copy the data to the 
	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
            for(setup_cnt = 0; setup_cnt < 8u; setup_cnt++) //SETUP data packets always contain exactly 8 bytes.
9d0025a0:	93c20010 	lbu	v0,16(s8)
9d0025a4:	24420001 	addiu	v0,v0,1
9d0025a8:	a3c20010 	sb	v0,16(s8)
9d0025ac:	93c20010 	lbu	v0,16(s8)
9d0025b0:	2c420008 	sltiu	v0,v0,8
9d0025b4:	1440ffbd 	bnez	v0,9d0024ac <USBCtrlEPAllowDataStage+0x11dc>
9d0025b8:	00000000 	nop
                *(UINT8*)((UINT8*)&SetupPkt + setup_cnt) = *(UINT8*)MConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR);

                pBDTEntryEP0OutCurrent->ADR++;
            }    

            pBDTEntryEP0OutCurrent->ADR = MConvertToPhysicalAddress(&SetupPkt);
9d0025bc:	8f828064 	lw	v0,-32668(gp)
9d0025c0:	27838058 	addiu	v1,gp,-32680
9d0025c4:	7c63e000 	ext	v1,v1,0x0,0x1d
9d0025c8:	306400ff 	andi	a0,v1,0xff
9d0025cc:	90450004 	lbu	a1,4(v0)
9d0025d0:	30a50000 	andi	a1,a1,0x0
9d0025d4:	00a42025 	or	a0,a1,a0
9d0025d8:	a0440004 	sb	a0,4(v0)
9d0025dc:	00032202 	srl	a0,v1,0x8
9d0025e0:	308400ff 	andi	a0,a0,0xff
9d0025e4:	90450005 	lbu	a1,5(v0)
9d0025e8:	30a50000 	andi	a1,a1,0x0
9d0025ec:	00a42025 	or	a0,a1,a0
9d0025f0:	a0440005 	sb	a0,5(v0)
9d0025f4:	00032402 	srl	a0,v1,0x10
9d0025f8:	308400ff 	andi	a0,a0,0xff
9d0025fc:	90450006 	lbu	a1,6(v0)
9d002600:	30a50000 	andi	a1,a1,0x0
9d002604:	00a42025 	or	a0,a1,a0
9d002608:	a0440006 	sb	a0,6(v0)
9d00260c:	00031e02 	srl	v1,v1,0x18
9d002610:	90440007 	lbu	a0,7(v0)
9d002614:	30840000 	andi	a0,a0,0x0
9d002618:	00831825 	or	v1,a0,v1
9d00261c:	a0430007 	sb	v1,7(v0)

			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
            USBCtrlTrfSetupHandler();
9d002620:	0f40099f 	jal	9d00267c <USBCtrlEPAllowDataStage+0x13ac>
9d002624:	00000000 	nop
9d002628:	0b400999 	j	9d002664 <USBCtrlEPAllowDataStage+0x1394>
9d00262c:	00000000 	nop
        }
        else
        {
			//Handle the DATA transfer
            USBCtrlTrfOutHandler();
9d002630:	0f400a17 	jal	9d00285c <USBCtrlEPAllowDataStage+0x158c>
9d002634:	00000000 	nop
9d002638:	0b400999 	j	9d002664 <USBCtrlEPAllowDataStage+0x1394>
9d00263c:	00000000 	nop
        }
    }
    else if ((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
9d002640:	9382806c 	lbu	v0,-32660(gp)
9d002644:	00401821 	move	v1,v0
9d002648:	2402fffb 	li	v0,-5
9d00264c:	00621824 	and	v1,v1,v0
9d002650:	24020008 	li	v0,8
9d002654:	14620003 	bne	v1,v0,9d002664 <USBCtrlEPAllowDataStage+0x1394>
9d002658:	00000000 	nop
    {
		//Otherwise the transmission was and EP0 IN
		//  so take care of the IN transfer
        USBCtrlTrfInHandler();
9d00265c:	0f400a5c 	jal	9d002970 <USBCtrlEPAllowDataStage+0x16a0>
9d002660:	00000000 	nop
    }
}//end USBCtrlEPService
9d002664:	03c0e821 	move	sp,s8
9d002668:	8fbf001c 	lw	ra,28(sp)
9d00266c:	8fbe0018 	lw	s8,24(sp)
9d002670:	27bd0020 	addiu	sp,sp,32
9d002674:	03e00008 	jr	ra
9d002678:	00000000 	nop
 *                  stored in pSrc,pDst, and wCount. A flag is used to
 *                  note if the data source is from ROM or RAM.
 *
 *******************************************************************/
static void USBCtrlTrfSetupHandler(void)
{
9d00267c:	27bdffe8 	addiu	sp,sp,-24
9d002680:	afbf0014 	sw	ra,20(sp)
9d002684:	afbe0010 	sw	s8,16(sp)
9d002688:	03a0f021 	move	s8,sp
    //--------------------------------------------------------------------------
    //1. Re-initialize state tracking variables related to control transfers.
    //--------------------------------------------------------------------------
    shortPacketStatus = SHORT_PKT_NOT_USED;  
9d00268c:	a3808062 	sb	zero,-32670(gp)
    USBDeferStatusStagePacket = FALSE;
9d002690:	a3808071 	sb	zero,-32655(gp)
    USBDeferINDataStagePackets = FALSE;
9d002694:	a380802c 	sb	zero,-32724(gp)
    USBDeferOUTDataStagePackets = FALSE;
9d002698:	a380802d 	sb	zero,-32723(gp)
    BothEP0OutUOWNsSet = FALSE;    
9d00269c:	a380804c 	sb	zero,-32692(gp)
    controlTransferState = WAIT_SETUP;
9d0026a0:	a3808034 	sb	zero,-32716(gp)
    //transfer would have completed successfully prior to the host sending the next
    //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
    //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
    //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
    //by the class request handler that will be called next.
    pBDTEntryIn[0]->STAT.Val &= ~(_USIE);     
9d0026a4:	8f828038 	lw	v0,-32712(gp)
9d0026a8:	8f838038 	lw	v1,-32712(gp)
9d0026ac:	90640000 	lbu	a0,0(v1)
9d0026b0:	308400ff 	andi	a0,a0,0xff
9d0026b4:	90630001 	lbu	v1,1(v1)
9d0026b8:	306300ff 	andi	v1,v1,0xff
9d0026bc:	00031a00 	sll	v1,v1,0x8
9d0026c0:	00641825 	or	v1,v1,a0
9d0026c4:	3064ffff 	andi	a0,v1,0xffff
9d0026c8:	2403ff7f 	li	v1,-129
9d0026cc:	00831824 	and	v1,a0,v1
9d0026d0:	3063ffff 	andi	v1,v1,0xffff
9d0026d4:	306400ff 	andi	a0,v1,0xff
9d0026d8:	90450000 	lbu	a1,0(v0)
9d0026dc:	30a50000 	andi	a1,a1,0x0
9d0026e0:	00a42025 	or	a0,a1,a0
9d0026e4:	a0440000 	sb	a0,0(v0)
9d0026e8:	00031a02 	srl	v1,v1,0x8
9d0026ec:	3063ffff 	andi	v1,v1,0xffff
9d0026f0:	90440001 	lbu	a0,1(v0)
9d0026f4:	30840000 	andi	a0,a0,0x0
9d0026f8:	00831825 	or	v1,a0,v1
9d0026fc:	a0430001 	sb	v1,1(v0)
    *((UINT8*)&pBDTEntryIn[0]) ^= USB_NEXT_EP0_IN_PING_PONG;
9d002700:	27828038 	addiu	v0,gp,-32712
9d002704:	27838038 	addiu	v1,gp,-32712
9d002708:	90630000 	lbu	v1,0(v1)
9d00270c:	38630008 	xori	v1,v1,0x8
9d002710:	306300ff 	andi	v1,v1,0xff
9d002714:	a0430000 	sb	v1,0(v0)
    pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
9d002718:	8f828038 	lw	v0,-32712(gp)
9d00271c:	8f838038 	lw	v1,-32712(gp)
9d002720:	90640000 	lbu	a0,0(v1)
9d002724:	308400ff 	andi	a0,a0,0xff
9d002728:	90630001 	lbu	v1,1(v1)
9d00272c:	306300ff 	andi	v1,v1,0xff
9d002730:	00031a00 	sll	v1,v1,0x8
9d002734:	00641825 	or	v1,v1,a0
9d002738:	3064ffff 	andi	a0,v1,0xffff
9d00273c:	2403ff7f 	li	v1,-129
9d002740:	00831824 	and	v1,a0,v1
9d002744:	3063ffff 	andi	v1,v1,0xffff
9d002748:	306400ff 	andi	a0,v1,0xff
9d00274c:	90450000 	lbu	a1,0(v0)
9d002750:	30a50000 	andi	a1,a1,0x0
9d002754:	00a42025 	or	a0,a1,a0
9d002758:	a0440000 	sb	a0,0(v0)
9d00275c:	00031a02 	srl	v1,v1,0x8
9d002760:	3063ffff 	andi	v1,v1,0xffff
9d002764:	90440001 	lbu	a0,1(v0)
9d002768:	30840000 	andi	a0,a0,0x0
9d00276c:	00831825 	or	v1,a0,v1
9d002770:	a0430001 	sb	v1,1(v0)
    *((UINT8*)&pBDTEntryIn[0]) ^= USB_NEXT_EP0_IN_PING_PONG;
9d002774:	27828038 	addiu	v0,gp,-32712
9d002778:	27838038 	addiu	v1,gp,-32712
9d00277c:	90630000 	lbu	v1,0(v1)
9d002780:	38630008 	xori	v1,v1,0x8
9d002784:	306300ff 	andi	v1,v1,0xff
9d002788:	a0430000 	sb	v1,0(v0)
    pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
9d00278c:	8f828050 	lw	v0,-32688(gp)
9d002790:	8f838050 	lw	v1,-32688(gp)
9d002794:	90640000 	lbu	a0,0(v1)
9d002798:	308400ff 	andi	a0,a0,0xff
9d00279c:	90630001 	lbu	v1,1(v1)
9d0027a0:	306300ff 	andi	v1,v1,0xff
9d0027a4:	00031a00 	sll	v1,v1,0x8
9d0027a8:	00641825 	or	v1,v1,a0
9d0027ac:	3064ffff 	andi	a0,v1,0xffff
9d0027b0:	2403ff7f 	li	v1,-129
9d0027b4:	00831824 	and	v1,a0,v1
9d0027b8:	3063ffff 	andi	v1,v1,0xffff
9d0027bc:	306400ff 	andi	a0,v1,0xff
9d0027c0:	90450000 	lbu	a1,0(v0)
9d0027c4:	30a50000 	andi	a1,a1,0x0
9d0027c8:	00a42025 	or	a0,a1,a0
9d0027cc:	a0440000 	sb	a0,0(v0)
9d0027d0:	00031a02 	srl	v1,v1,0x8
9d0027d4:	3063ffff 	andi	v1,v1,0xffff
9d0027d8:	90440001 	lbu	a0,1(v0)
9d0027dc:	30840000 	andi	a0,a0,0x0
9d0027e0:	00831825 	or	v1,a0,v1
9d0027e4:	a0430001 	sb	v1,1(v0)

    inPipes[0].info.Val = 0;
9d0027e8:	3c02a000 	lui	v0,0xa000
9d0027ec:	24420280 	addiu	v0,v0,640
9d0027f0:	a0400004 	sb	zero,4(v0)
    inPipes[0].wCount = 0;
9d0027f4:	3c02a000 	lui	v0,0xa000
9d0027f8:	24420280 	addiu	v0,v0,640
9d0027fc:	a4400008 	sh	zero,8(v0)
    outPipes[0].info.Val = 0;
9d002800:	3c02a000 	lui	v0,0xa000
9d002804:	24420290 	addiu	v0,v0,656
9d002808:	a0400004 	sb	zero,4(v0)
    outPipes[0].wCount = 0;
9d00280c:	3c02a000 	lui	v0,0xa000
9d002810:	24430290 	addiu	v1,v0,656
9d002814:	8c620004 	lw	v0,4(v1)
9d002818:	7c02ba04 	ins	v0,zero,0x8,0x10
9d00281c:	ac620004 	sw	v0,4(v1)

    //--------------------------------------------------------------------------
    //2. Now find out what was in the SETUP packet, and begin handling the request.
    //--------------------------------------------------------------------------
    USBCheckStdRequest();                                         //Check for standard USB "Chapter 9" requests.
9d002820:	0f400aed 	jal	9d002bb4 <USBCtrlEPAllowDataStage+0x18e4>
9d002824:	00000000 	nop
    USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST, 0, 0); //Check for USB device class specific requests
9d002828:	24040003 	li	a0,3
9d00282c:	00002821 	move	a1,zero
9d002830:	00003021 	move	a2,zero
9d002834:	0f4018f1 	jal	9d0063c4 <USER_USB_CALLBACK_EVENT_HANDLER>
9d002838:	00000000 	nop
    //   USBCtrlEPServiceComplete() function know how and which endpoints to 
    //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
    //   process the request.  In this case, the default behavior will be to
    //   perform protocol STALL on EP0.
    //-------------------------------------------------------------------------- 
    USBCtrlEPServiceComplete();
9d00283c:	0f40055c 	jal	9d001570 <USBCtrlEPAllowDataStage+0x2a0>
9d002840:	00000000 	nop
}//end USBCtrlTrfSetupHandler
9d002844:	03c0e821 	move	sp,s8
9d002848:	8fbf0014 	lw	ra,20(sp)
9d00284c:	8fbe0010 	lw	s8,16(sp)
9d002850:	27bd0018 	addiu	sp,sp,24
9d002854:	03e00008 	jr	ra
9d002858:	00000000 	nop
 *                  at the end of each OUT transaction to service the
 *                  received data.
 *
 *****************************************************************************/
static void USBCtrlTrfOutHandler(void)
{
9d00285c:	27bdffe8 	addiu	sp,sp,-24
9d002860:	afbf0014 	sw	ra,20(sp)
9d002864:	afbe0010 	sw	s8,16(sp)
9d002868:	03a0f021 	move	s8,sp
    if (controlTransferState == CTRL_TRF_RX)
9d00286c:	93838034 	lbu	v1,-32716(gp)
9d002870:	24020002 	li	v0,2
9d002874:	14620005 	bne	v1,v0,9d00288c <USBCtrlEPAllowDataStage+0x15bc>
9d002878:	00000000 	nop
    {
        USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
9d00287c:	0f400675 	jal	9d0019d4 <USBCtrlEPAllowDataStage+0x704>
9d002880:	00000000 	nop
9d002884:	0b400a56 	j	9d002958 <USBCtrlEPAllowDataStage+0x1688>
9d002888:	00000000 	nop
    }
    else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
    {
        //If the status stage is complete, this means we are done with the 
        //control transfer.  Go back to the idle "WAIT_SETUP" state.
        controlTransferState = WAIT_SETUP;
9d00288c:	a3808034 	sb	zero,-32716(gp)
	    //Prepare EP0 OUT for the next SETUP transaction, however, it may have
	    //already been prepared if ping-pong buffering was enabled on EP0 OUT,
	    //and the last control transfer was of direction: device to host, see
	    //USBCtrlEPServiceComplete().  If it was already prepared, do not want
	    //to do anything to the BDT.
		if (BothEP0OutUOWNsSet == FALSE)
9d002890:	9382804c 	lbu	v0,-32692(gp)
9d002894:	1440002f 	bnez	v0,9d002954 <USBCtrlEPAllowDataStage+0x1684>
9d002898:	00000000 	nop
		{
	        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
9d00289c:	8f828050 	lw	v0,-32688(gp)
9d0028a0:	90430002 	lbu	v1,2(v0)
9d0028a4:	30630000 	andi	v1,v1,0x0
9d0028a8:	34630040 	ori	v1,v1,0x40
9d0028ac:	a0430002 	sb	v1,2(v0)
9d0028b0:	90440003 	lbu	a0,3(v0)
9d0028b4:	2403fffc 	li	v1,-4
9d0028b8:	00831824 	and	v1,a0,v1
9d0028bc:	a0430003 	sb	v1,3(v0)
	        pBDTEntryEP0OutNext->ADR = MConvertToPhysicalAddress(&SetupPkt);
9d0028c0:	8f828050 	lw	v0,-32688(gp)
9d0028c4:	27838058 	addiu	v1,gp,-32680
9d0028c8:	7c63e000 	ext	v1,v1,0x0,0x1d
9d0028cc:	306400ff 	andi	a0,v1,0xff
9d0028d0:	90450004 	lbu	a1,4(v0)
9d0028d4:	30a50000 	andi	a1,a1,0x0
9d0028d8:	00a42025 	or	a0,a1,a0
9d0028dc:	a0440004 	sb	a0,4(v0)
9d0028e0:	00032202 	srl	a0,v1,0x8
9d0028e4:	308400ff 	andi	a0,a0,0xff
9d0028e8:	90450005 	lbu	a1,5(v0)
9d0028ec:	30a50000 	andi	a1,a1,0x0
9d0028f0:	00a42025 	or	a0,a1,a0
9d0028f4:	a0440005 	sb	a0,5(v0)
9d0028f8:	00032402 	srl	a0,v1,0x10
9d0028fc:	308400ff 	andi	a0,a0,0xff
9d002900:	90450006 	lbu	a1,6(v0)
9d002904:	30a50000 	andi	a1,a1,0x0
9d002908:	00a42025 	or	a0,a1,a0
9d00290c:	a0440006 	sb	a0,6(v0)
9d002910:	00031e02 	srl	v1,v1,0x18
9d002914:	90440007 	lbu	a0,7(v0)
9d002918:	30840000 	andi	a0,a0,0x0
9d00291c:	00831825 	or	v1,a0,v1
9d002920:	a0430007 	sb	v1,7(v0)
	        pBDTEntryEP0OutNext->STAT.Val = _USIE | _DAT0 | (_DTSEN & _DTS_CHECKING_ENABLED) | _BSTALL;			
9d002924:	8f828050 	lw	v0,-32688(gp)
9d002928:	90430000 	lbu	v1,0(v0)
9d00292c:	30630000 	andi	v1,v1,0x0
9d002930:	00602021 	move	a0,v1
9d002934:	2403ff8c 	li	v1,-116
9d002938:	00831825 	or	v1,a0,v1
9d00293c:	a0430000 	sb	v1,0(v0)
9d002940:	90430001 	lbu	v1,1(v0)
9d002944:	30630000 	andi	v1,v1,0x0
9d002948:	a0430001 	sb	v1,1(v0)
9d00294c:	0b400a56 	j	9d002958 <USBCtrlEPAllowDataStage+0x1688>
9d002950:	00000000 	nop
		}
		else
		{
			BothEP0OutUOWNsSet = FALSE;
9d002954:	a380804c 	sb	zero,-32692(gp)
		}
    }
}
9d002958:	03c0e821 	move	sp,s8
9d00295c:	8fbf0014 	lw	ra,20(sp)
9d002960:	8fbe0010 	lw	s8,16(sp)
9d002964:	27bd0018 	addiu	sp,sp,24
9d002968:	03e00008 	jr	ra
9d00296c:	00000000 	nop
 *                  right. Macro mUSBCheckAdrPendingState is defined in
 *                  usb9.h and its function is to specifically service this
 *                  event.
 *****************************************************************************/
static void USBCtrlTrfInHandler(void)
{
9d002970:	27bdffe0 	addiu	sp,sp,-32
9d002974:	afbf001c 	sw	ra,28(sp)
9d002978:	afbe0018 	sw	s8,24(sp)
9d00297c:	03a0f021 	move	s8,sp
    UINT8 lastDTS;

    lastDTS = pBDTEntryIn[0]->STAT.DTS;
9d002980:	8f828038 	lw	v0,-32712(gp)
9d002984:	90420000 	lbu	v0,0(v0)
9d002988:	7c420180 	ext	v0,v0,0x6,0x1
9d00298c:	304200ff 	andi	v0,v0,0xff
9d002990:	a3c20010 	sb	v0,16(s8)

    //switch to the next ping pong buffer
    *((UINT8*)&pBDTEntryIn[0]) ^= USB_NEXT_EP0_IN_PING_PONG;
9d002994:	27828038 	addiu	v0,gp,-32712
9d002998:	27838038 	addiu	v1,gp,-32712
9d00299c:	90630000 	lbu	v1,0(v1)
9d0029a0:	38630008 	xori	v1,v1,0x8
9d0029a4:	306300ff 	andi	v1,v1,0xff
9d0029a8:	a0430000 	sb	v1,0(v0)

    //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
    //now, since the IN status stage of the (set address) control transfer has 
    //evidently completed successfully.
    if (USBDeviceState == ADR_PENDING_STATE)
9d0029ac:	8f838030 	lw	v1,-32720(gp)
9d0029b0:	24020008 	li	v0,8
9d0029b4:	14620010 	bne	v1,v0,9d0029f8 <USBCtrlEPAllowDataStage+0x1728>
9d0029b8:	00000000 	nop
    {
        U1ADDR = SetupPkt.bDevADR;
9d0029bc:	9382805a 	lbu	v0,-32678(gp)
9d0029c0:	304200ff 	andi	v0,v0,0xff
9d0029c4:	00401821 	move	v1,v0
9d0029c8:	3c02bf88 	lui	v0,0xbf88
9d0029cc:	ac435260 	sw	v1,21088(v0)

        if (U1ADDR != 0u)
9d0029d0:	3c02bf88 	lui	v0,0xbf88
9d0029d4:	8c425260 	lw	v0,21088(v0)
9d0029d8:	10400005 	beqz	v0,9d0029f0 <USBCtrlEPAllowDataStage+0x1720>
9d0029dc:	00000000 	nop
        {
            USBDeviceState = ADDRESS_STATE;
9d0029e0:	24020010 	li	v0,16
9d0029e4:	af828030 	sw	v0,-32720(gp)
9d0029e8:	0b400a7e 	j	9d0029f8 <USBCtrlEPAllowDataStage+0x1728>
9d0029ec:	00000000 	nop
        }
        else
        {
            USBDeviceState = DEFAULT_STATE;
9d0029f0:	24020004 	li	v0,4
9d0029f4:	af828030 	sw	v0,-32720(gp)
        }
    }//end if


    if (controlTransferState == CTRL_TRF_TX)
9d0029f8:	93838034 	lbu	v1,-32716(gp)
9d0029fc:	24020001 	li	v0,1
9d002a00:	14620048 	bne	v1,v0,9d002b24 <USBCtrlEPAllowDataStage+0x1854>
9d002a04:	00000000 	nop
    {
        pBDTEntryIn[0]->ADR = MConvertToPhysicalAddress(CtrlTrfData);
9d002a08:	8f828038 	lw	v0,-32712(gp)
9d002a0c:	3c03a000 	lui	v1,0xa000
9d002a10:	24630240 	addiu	v1,v1,576
9d002a14:	7c63e000 	ext	v1,v1,0x0,0x1d
9d002a18:	306400ff 	andi	a0,v1,0xff
9d002a1c:	90450004 	lbu	a1,4(v0)
9d002a20:	30a50000 	andi	a1,a1,0x0
9d002a24:	00a42025 	or	a0,a1,a0
9d002a28:	a0440004 	sb	a0,4(v0)
9d002a2c:	00032202 	srl	a0,v1,0x8
9d002a30:	308400ff 	andi	a0,a0,0xff
9d002a34:	90450005 	lbu	a1,5(v0)
9d002a38:	30a50000 	andi	a1,a1,0x0
9d002a3c:	00a42025 	or	a0,a1,a0
9d002a40:	a0440005 	sb	a0,5(v0)
9d002a44:	00032402 	srl	a0,v1,0x10
9d002a48:	308400ff 	andi	a0,a0,0xff
9d002a4c:	90450006 	lbu	a1,6(v0)
9d002a50:	30a50000 	andi	a1,a1,0x0
9d002a54:	00a42025 	or	a0,a1,a0
9d002a58:	a0440006 	sb	a0,6(v0)
9d002a5c:	00031e02 	srl	v1,v1,0x18
9d002a60:	90440007 	lbu	a0,7(v0)
9d002a64:	30840000 	andi	a0,a0,0x0
9d002a68:	00831825 	or	v1,a0,v1
9d002a6c:	a0430007 	sb	v1,7(v0)
        
        USBCtrlTrfTxService();
9d002a70:	0f40060b 	jal	9d00182c <USBCtrlEPAllowDataStage+0x55c>
9d002a74:	00000000 	nop

        //Check if we have already sent a short packet.  If so, configure
        //the endpoint to STALL in response to any further IN tokens (in the
        //case that the host erroneously tries to receive more data than it
        //should).
        if (shortPacketStatus == SHORT_PKT_SENT)
9d002a78:	93838062 	lbu	v1,-32670(gp)
9d002a7c:	24020002 	li	v0,2
9d002a80:	1462000d 	bne	v1,v0,9d002ab8 <USBCtrlEPAllowDataStage+0x17e8>
9d002a84:	00000000 	nop
        {
            // If a short packet has been sent, don't want to send any more,
            // stall next time if host is still trying to read.
            pBDTEntryIn[0]->STAT.Val = _USIE | _BSTALL;
9d002a88:	8f828038 	lw	v0,-32712(gp)
9d002a8c:	90430000 	lbu	v1,0(v0)
9d002a90:	30630000 	andi	v1,v1,0x0
9d002a94:	00602021 	move	a0,v1
9d002a98:	2403ff84 	li	v1,-124
9d002a9c:	00831825 	or	v1,a0,v1
9d002aa0:	a0430000 	sb	v1,0(v0)
9d002aa4:	90430001 	lbu	v1,1(v0)
9d002aa8:	30630000 	andi	v1,v1,0x0
9d002aac:	a0430001 	sb	v1,1(v0)
9d002ab0:	0b400ae7 	j	9d002b9c <USBCtrlEPAllowDataStage+0x18cc>
9d002ab4:	00000000 	nop
        }
        else
        {
            if (lastDTS == 0)
9d002ab8:	93c20010 	lbu	v0,16(s8)
9d002abc:	1440000d 	bnez	v0,9d002af4 <USBCtrlEPAllowDataStage+0x1824>
9d002ac0:	00000000 	nop
            {
                pBDTEntryIn[0]->STAT.Val = _USIE | _DAT1 | (_DTSEN & _DTS_CHECKING_ENABLED);
9d002ac4:	8f828038 	lw	v0,-32712(gp)
9d002ac8:	90430000 	lbu	v1,0(v0)
9d002acc:	30630000 	andi	v1,v1,0x0
9d002ad0:	00602021 	move	a0,v1
9d002ad4:	2403ffc8 	li	v1,-56
9d002ad8:	00831825 	or	v1,a0,v1
9d002adc:	a0430000 	sb	v1,0(v0)
9d002ae0:	90430001 	lbu	v1,1(v0)
9d002ae4:	30630000 	andi	v1,v1,0x0
9d002ae8:	a0430001 	sb	v1,1(v0)
9d002aec:	0b400ae7 	j	9d002b9c <USBCtrlEPAllowDataStage+0x18cc>
9d002af0:	00000000 	nop
            }
            else
            {
                pBDTEntryIn[0]->STAT.Val = _USIE | _DAT0 | (_DTSEN & _DTS_CHECKING_ENABLED);
9d002af4:	8f828038 	lw	v0,-32712(gp)
9d002af8:	90430000 	lbu	v1,0(v0)
9d002afc:	30630000 	andi	v1,v1,0x0
9d002b00:	00602021 	move	a0,v1
9d002b04:	2403ff88 	li	v1,-120
9d002b08:	00831825 	or	v1,a0,v1
9d002b0c:	a0430000 	sb	v1,0(v0)
9d002b10:	90430001 	lbu	v1,1(v0)
9d002b14:	30630000 	andi	v1,v1,0x0
9d002b18:	a0430001 	sb	v1,1(v0)
9d002b1c:	0b400ae7 	j	9d002b9c <USBCtrlEPAllowDataStage+0x18cc>
9d002b20:	00000000 	nop
	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
	{
        //if someone is still expecting data from the control transfer
        //  then make sure to terminate that request and let them know that
        //  they are done
        if (outPipes[0].info.bits.busy == 1)
9d002b24:	3c02a000 	lui	v0,0xa000
9d002b28:	24420290 	addiu	v0,v0,656
9d002b2c:	90430004 	lbu	v1,4(v0)
9d002b30:	2402ff80 	li	v0,-128
9d002b34:	00621024 	and	v0,v1,v0
9d002b38:	304200ff 	andi	v0,v0,0xff
9d002b3c:	10400016 	beqz	v0,9d002b98 <USBCtrlEPAllowDataStage+0x18c8>
9d002b40:	00000000 	nop
        {
            if (outPipes[0].pFunc != NULL)
9d002b44:	3c02a000 	lui	v0,0xa000
9d002b48:	24420290 	addiu	v0,v0,656
9d002b4c:	8843000a 	lwl	v1,10(v0)
9d002b50:	00602021 	move	a0,v1
9d002b54:	98440007 	lwr	a0,7(v0)
9d002b58:	00801021 	move	v0,a0
9d002b5c:	10400009 	beqz	v0,9d002b84 <USBCtrlEPAllowDataStage+0x18b4>
9d002b60:	00000000 	nop
            {
                outPipes[0].pFunc();
9d002b64:	3c02a000 	lui	v0,0xa000
9d002b68:	24420290 	addiu	v0,v0,656
9d002b6c:	8843000a 	lwl	v1,10(v0)
9d002b70:	00602021 	move	a0,v1
9d002b74:	98440007 	lwr	a0,7(v0)
9d002b78:	00801021 	move	v0,a0
9d002b7c:	0040f809 	jalr	v0
9d002b80:	00000000 	nop
            }

            outPipes[0].info.bits.busy = 0;
9d002b84:	3c02a000 	lui	v0,0xa000
9d002b88:	24430290 	addiu	v1,v0,656
9d002b8c:	8c620004 	lw	v0,4(v1)
9d002b90:	7c0239c4 	ins	v0,zero,0x7,0x1
9d002b94:	ac620004 	sw	v0,4(v1)
        }
    	
        controlTransferState = WAIT_SETUP;
9d002b98:	a3808034 	sb	zero,-32716(gp)
        //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
        //got processed by the USBCtrlTrfRxService() handler.
	}	
}
9d002b9c:	03c0e821 	move	sp,s8
9d002ba0:	8fbf001c 	lw	ra,28(sp)
9d002ba4:	8fbe0018 	lw	s8,24(sp)
9d002ba8:	27bd0020 	addiu	sp,sp,32
9d002bac:	03e00008 	jr	ra
9d002bb0:	00000000 	nop
 *                  if it knows how to handle it
 *
 * Note:            None
 *******************************************************************/
static void USBCheckStdRequest(void)
{
9d002bb4:	27bdffe8 	addiu	sp,sp,-24
9d002bb8:	afbf0014 	sw	ra,20(sp)
9d002bbc:	afbe0010 	sw	s8,16(sp)
9d002bc0:	03a0f021 	move	s8,sp
    if (SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD)
9d002bc4:	93828058 	lbu	v0,-32680(gp)
9d002bc8:	304200ff 	andi	v0,v0,0xff
9d002bcc:	30420060 	andi	v0,v0,0x60
9d002bd0:	304200ff 	andi	v0,v0,0xff
9d002bd4:	14400078 	bnez	v0,9d002db8 <USBCtrlEPAllowDataStage+0x1ae8>
9d002bd8:	00000000 	nop
    {
        return;
    }

    switch (SetupPkt.bRequest)
9d002bdc:	93828059 	lbu	v0,-32679(gp)
9d002be0:	304200ff 	andi	v0,v0,0xff
9d002be4:	2c43000c 	sltiu	v1,v0,12
9d002be8:	10600076 	beqz	v1,9d002dc4 <USBCtrlEPAllowDataStage+0x1af4>
9d002bec:	00000000 	nop
9d002bf0:	00021880 	sll	v1,v0,0x2
9d002bf4:	3c029d00 	lui	v0,0x9d00
9d002bf8:	24422c0c 	addiu	v0,v0,11276
9d002bfc:	00621021 	addu	v0,v1,v0
9d002c00:	8c420000 	lw	v0,0(v0)
9d002c04:	00400008 	jr	v0
9d002c08:	00000000 	nop
9d002c0c:	9d002cd8 	0x9d002cd8
9d002c10:	9d002ce8 	0x9d002ce8
9d002c14:	9d002dd0 	0x9d002dd0
9d002c18:	9d002ce8 	0x9d002ce8
9d002c1c:	9d002dd0 	0x9d002dd0
9d002c20:	9d002c3c 	0x9d002c3c
9d002c24:	9d002c64 	0x9d002c64
9d002c28:	9d002d9c 	0x9d002d9c
9d002c2c:	9d002c84 	0x9d002c84
9d002c30:	9d002c74 	0x9d002c74
9d002c34:	9d002cf8 	0x9d002cf8
9d002c38:	9d002d5c 	0x9d002d5c
    {
        case USB_REQUEST_SET_ADDRESS:
            inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
9d002c3c:	3c02a000 	lui	v0,0xa000
9d002c40:	24430280 	addiu	v1,v0,640
9d002c44:	8c620004 	lw	v0,4(v1)
9d002c48:	24040001 	li	a0,1
9d002c4c:	7c8239c4 	ins	v0,a0,0x7,0x1
9d002c50:	ac620004 	sw	v0,4(v1)
            USBDeviceState = ADR_PENDING_STATE;       // Update state only
9d002c54:	24020008 	li	v0,8
9d002c58:	af828030 	sw	v0,-32720(gp)
            /* See USBCtrlTrfInHandler() for the next step */
            break;
9d002c5c:	0b400b75 	j	9d002dd4 <USBCtrlEPAllowDataStage+0x1b04>
9d002c60:	00000000 	nop
        case USB_REQUEST_GET_DESCRIPTOR:
            USBStdGetDscHandler();
9d002c64:	0f4007ae 	jal	9d001eb8 <USBCtrlEPAllowDataStage+0xbe8>
9d002c68:	00000000 	nop
            break;
9d002c6c:	0b400b75 	j	9d002dd4 <USBCtrlEPAllowDataStage+0x1b04>
9d002c70:	00000000 	nop
        case USB_REQUEST_SET_CONFIGURATION:
            USBStdSetCfgHandler();
9d002c74:	0f40074e 	jal	9d001d38 <USBCtrlEPAllowDataStage+0xa68>
9d002c78:	00000000 	nop
            break;
9d002c7c:	0b400b75 	j	9d002dd4 <USBCtrlEPAllowDataStage+0x1b04>
9d002c80:	00000000 	nop
        case USB_REQUEST_GET_CONFIGURATION:
            inPipes[0].Source.pbRam = (UINT8*)&l_USBActiveConfiguration; // Set Source
9d002c84:	3c02a000 	lui	v0,0xa000
9d002c88:	27838010 	addiu	v1,gp,-32752
9d002c8c:	ac430280 	sw	v1,640(v0)
            inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;             // Set memory type
9d002c90:	3c02a000 	lui	v0,0xa000
9d002c94:	24430280 	addiu	v1,v0,640
9d002c98:	8c620004 	lw	v0,4(v1)
9d002c9c:	24040001 	li	a0,1
9d002ca0:	7c820004 	ins	v0,a0,0x0,0x1
9d002ca4:	ac620004 	sw	v0,4(v1)
            inPipes[0].wCount = 1;                                       // Set data count
9d002ca8:	3c02a000 	lui	v0,0xa000
9d002cac:	24420280 	addiu	v0,v0,640
9d002cb0:	24030001 	li	v1,1
9d002cb4:	a4430008 	sh	v1,8(v0)
            inPipes[0].info.bits.busy = 1;
9d002cb8:	3c02a000 	lui	v0,0xa000
9d002cbc:	24430280 	addiu	v1,v0,640
9d002cc0:	8c620004 	lw	v0,4(v1)
9d002cc4:	24040001 	li	a0,1
9d002cc8:	7c8239c4 	ins	v0,a0,0x7,0x1
9d002ccc:	ac620004 	sw	v0,4(v1)
            break;
9d002cd0:	0b400b75 	j	9d002dd4 <USBCtrlEPAllowDataStage+0x1b04>
9d002cd4:	00000000 	nop
        case USB_REQUEST_GET_STATUS:
            USBStdGetStatusHandler();
9d002cd8:	0f400821 	jal	9d002084 <USBCtrlEPAllowDataStage+0xdb4>
9d002cdc:	00000000 	nop
            break;
9d002ce0:	0b400b75 	j	9d002dd4 <USBCtrlEPAllowDataStage+0x1b04>
9d002ce4:	00000000 	nop
        case USB_REQUEST_CLEAR_FEATURE:
        case USB_REQUEST_SET_FEATURE:
            USBStdFeatureReqHandler();
9d002ce8:	0f400b7b 	jal	9d002dec <USBCtrlEPAllowDataStage+0x1b1c>
9d002cec:	00000000 	nop
            break;
9d002cf0:	0b400b75 	j	9d002dd4 <USBCtrlEPAllowDataStage+0x1b04>
9d002cf4:	00000000 	nop
        case USB_REQUEST_GET_INTERFACE:
            inPipes[0].Source.pbRam = (UINT8*)&USBAlternateInterface[SetupPkt.bIntfID]; // Set source
9d002cf8:	9382805c 	lbu	v0,-32676(gp)
9d002cfc:	304200ff 	andi	v0,v0,0xff
9d002d00:	00401821 	move	v1,v0
9d002d04:	27828070 	addiu	v0,gp,-32656
9d002d08:	00621821 	addu	v1,v1,v0
9d002d0c:	3c02a000 	lui	v0,0xa000
9d002d10:	ac430280 	sw	v1,640(v0)
            inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;                            // Set memory type
9d002d14:	3c02a000 	lui	v0,0xa000
9d002d18:	24430280 	addiu	v1,v0,640
9d002d1c:	8c620004 	lw	v0,4(v1)
9d002d20:	24040001 	li	a0,1
9d002d24:	7c820004 	ins	v0,a0,0x0,0x1
9d002d28:	ac620004 	sw	v0,4(v1)
            inPipes[0].wCount = 1;                                                      // Set data count
9d002d2c:	3c02a000 	lui	v0,0xa000
9d002d30:	24420280 	addiu	v0,v0,640
9d002d34:	24030001 	li	v1,1
9d002d38:	a4430008 	sh	v1,8(v0)
            inPipes[0].info.bits.busy = 1;
9d002d3c:	3c02a000 	lui	v0,0xa000
9d002d40:	24430280 	addiu	v1,v0,640
9d002d44:	8c620004 	lw	v0,4(v1)
9d002d48:	24040001 	li	a0,1
9d002d4c:	7c8239c4 	ins	v0,a0,0x7,0x1
9d002d50:	ac620004 	sw	v0,4(v1)
            break;
9d002d54:	0b400b75 	j	9d002dd4 <USBCtrlEPAllowDataStage+0x1b04>
9d002d58:	00000000 	nop
        case USB_REQUEST_SET_INTERFACE:
            inPipes[0].info.bits.busy = 1;
9d002d5c:	3c02a000 	lui	v0,0xa000
9d002d60:	24430280 	addiu	v1,v0,640
9d002d64:	8c620004 	lw	v0,4(v1)
9d002d68:	24040001 	li	a0,1
9d002d6c:	7c8239c4 	ins	v0,a0,0x7,0x1
9d002d70:	ac620004 	sw	v0,4(v1)
            
            USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
9d002d74:	9382805c 	lbu	v0,-32676(gp)
9d002d78:	304200ff 	andi	v0,v0,0xff
9d002d7c:	00402021 	move	a0,v0
9d002d80:	9382805a 	lbu	v0,-32678(gp)
9d002d84:	304300ff 	andi	v1,v0,0xff
9d002d88:	27828070 	addiu	v0,gp,-32656
9d002d8c:	00821021 	addu	v0,a0,v0
9d002d90:	a0430000 	sb	v1,0(v0)
            break;
9d002d94:	0b400b75 	j	9d002dd4 <USBCtrlEPAllowDataStage+0x1b04>
9d002d98:	00000000 	nop
        case USB_REQUEST_SET_DESCRIPTOR:
            USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR, 0, 0);
9d002d9c:	24040002 	li	a0,2
9d002da0:	00002821 	move	a1,zero
9d002da4:	00003021 	move	a2,zero
9d002da8:	0f4018f1 	jal	9d0063c4 <USER_USB_CALLBACK_EVENT_HANDLER>
9d002dac:	00000000 	nop
            break;
9d002db0:	0b400b75 	j	9d002dd4 <USBCtrlEPAllowDataStage+0x1b04>
9d002db4:	00000000 	nop
 *******************************************************************/
static void USBCheckStdRequest(void)
{
    if (SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD)
    {
        return;
9d002db8:	00000000 	nop
9d002dbc:	0b400b75 	j	9d002dd4 <USBCtrlEPAllowDataStage+0x1b04>
9d002dc0:	00000000 	nop
        case USB_REQUEST_SET_DESCRIPTOR:
            USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR, 0, 0);
            break;
        case USB_REQUEST_SYNCH_FRAME:
        default:
            break;
9d002dc4:	00000000 	nop
9d002dc8:	0b400b75 	j	9d002dd4 <USBCtrlEPAllowDataStage+0x1b04>
9d002dcc:	00000000 	nop
9d002dd0:	00000000 	nop
    }//end switch
}//end USBCheckStdRequest
9d002dd4:	03c0e821 	move	sp,s8
9d002dd8:	8fbf0014 	lw	ra,20(sp)
9d002ddc:	8fbe0010 	lw	s8,16(sp)
9d002de0:	27bd0018 	addiu	sp,sp,24
9d002de4:	03e00008 	jr	ra
9d002de8:	00000000 	nop
 * Note:            This is a private function, intended for internal 
 *                  use by the USB stack, when processing SET/CLEAR
 *                  feature requests.  
 *******************************************************************/
static void USBStdFeatureReqHandler(void)
{
9d002dec:	27bdffd8 	addiu	sp,sp,-40
9d002df0:	afbf0024 	sw	ra,36(sp)
9d002df4:	afbe0020 	sw	s8,32(sp)
9d002df8:	03a0f021 	move	s8,sp
    BDT_ENTRY *p;
    TEndPointStatus current_ep_data;
    UINT32* pUEP;

    //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
    if ((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP) &&
9d002dfc:	9382805a 	lbu	v0,-32678(gp)
9d002e00:	304300ff 	andi	v1,v0,0xff
9d002e04:	24020001 	li	v0,1
9d002e08:	14620017 	bne	v1,v0,9d002e68 <USBCtrlEPAllowDataStage+0x1b98>
9d002e0c:	00000000 	nop
        (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
9d002e10:	93828058 	lbu	v0,-32680(gp)
9d002e14:	304200ff 	andi	v0,v0,0xff
9d002e18:	3042001f 	andi	v0,v0,0x1f
9d002e1c:	304200ff 	andi	v0,v0,0xff
    BDT_ENTRY *p;
    TEndPointStatus current_ep_data;
    UINT32* pUEP;

    //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
    if ((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP) &&
9d002e20:	14400011 	bnez	v0,9d002e68 <USBCtrlEPAllowDataStage+0x1b98>
9d002e24:	00000000 	nop
        (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
    {
        inPipes[0].info.bits.busy = 1;
9d002e28:	3c02a000 	lui	v0,0xa000
9d002e2c:	24430280 	addiu	v1,v0,640
9d002e30:	8c620004 	lw	v0,4(v1)
9d002e34:	24040001 	li	a0,1
9d002e38:	7c8239c4 	ins	v0,a0,0x7,0x1
9d002e3c:	ac620004 	sw	v0,4(v1)
        
        if (SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
9d002e40:	93828059 	lbu	v0,-32679(gp)
9d002e44:	304300ff 	andi	v1,v0,0xff
9d002e48:	24020003 	li	v0,3
9d002e4c:	14620005 	bne	v1,v0,9d002e64 <USBCtrlEPAllowDataStage+0x1b94>
9d002e50:	00000000 	nop
        {
            RemoteWakeup = TRUE;
9d002e54:	24020001 	li	v0,1
9d002e58:	a3828068 	sb	v0,-32664(gp)
9d002e5c:	0b400b9a 	j	9d002e68 <USBCtrlEPAllowDataStage+0x1b98>
9d002e60:	00000000 	nop
        }
        else
        {
            RemoteWakeup = FALSE;
9d002e64:	a3808068 	sb	zero,-32664(gp)
        }
    }//end if

    //Check if the host sent a valid SET or CLEAR endpoint halt request.
    if ((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT) &&
9d002e68:	9382805a 	lbu	v0,-32678(gp)
9d002e6c:	304200ff 	andi	v0,v0,0xff
9d002e70:	14400174 	bnez	v0,9d003444 <USBCtrlEPAllowDataStage+0x2174>
9d002e74:	00000000 	nop
        (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD) &&
9d002e78:	93828058 	lbu	v0,-32680(gp)
9d002e7c:	304200ff 	andi	v0,v0,0xff
9d002e80:	3042001f 	andi	v0,v0,0x1f
9d002e84:	304300ff 	andi	v1,v0,0xff
            RemoteWakeup = FALSE;
        }
    }//end if

    //Check if the host sent a valid SET or CLEAR endpoint halt request.
    if ((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT) &&
9d002e88:	24020002 	li	v0,2
9d002e8c:	1462016d 	bne	v1,v0,9d003444 <USBCtrlEPAllowDataStage+0x2174>
9d002e90:	00000000 	nop
        (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD) &&
        (SetupPkt.EPNum != 0) &&
9d002e94:	9382805c 	lbu	v0,-32676(gp)
9d002e98:	304200ff 	andi	v0,v0,0xff
9d002e9c:	3042000f 	andi	v0,v0,0xf
9d002ea0:	304200ff 	andi	v0,v0,0xff
        }
    }//end if

    //Check if the host sent a valid SET or CLEAR endpoint halt request.
    if ((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT) &&
        (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD) &&
9d002ea4:	10400167 	beqz	v0,9d003444 <USBCtrlEPAllowDataStage+0x2174>
9d002ea8:	00000000 	nop
        (SetupPkt.EPNum != 0) &&
        (SetupPkt.EPNum <= USB_MAX_EP_NUMBER) &&
9d002eac:	8f82805c 	lw	v0,-32676(gp)
9d002eb0:	7c421800 	ext	v0,v0,0x0,0x4
9d002eb4:	304200ff 	andi	v0,v0,0xff
    }//end if

    //Check if the host sent a valid SET or CLEAR endpoint halt request.
    if ((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT) &&
        (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD) &&
        (SetupPkt.EPNum != 0) &&
9d002eb8:	28420002 	slti	v0,v0,2
9d002ebc:	10400161 	beqz	v0,9d003444 <USBCtrlEPAllowDataStage+0x2174>
9d002ec0:	00000000 	nop
        (SetupPkt.EPNum <= USB_MAX_EP_NUMBER) &&
        (USBDeviceState == CONFIGURED_STATE))
9d002ec4:	8f838030 	lw	v1,-32720(gp)

    //Check if the host sent a valid SET or CLEAR endpoint halt request.
    if ((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT) &&
        (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD) &&
        (SetupPkt.EPNum != 0) &&
        (SetupPkt.EPNum <= USB_MAX_EP_NUMBER) &&
9d002ec8:	24020020 	li	v0,32
9d002ecc:	1462015d 	bne	v1,v0,9d003444 <USBCtrlEPAllowDataStage+0x2174>
9d002ed0:	00000000 	nop
        (USBDeviceState == CONFIGURED_STATE))
    {
		//The request was valid.  Take control of the control transfer and
		//perform the host requested action.
		inPipes[0].info.bits.busy = 1;
9d002ed4:	3c02a000 	lui	v0,0xa000
9d002ed8:	24430280 	addiu	v1,v0,640
9d002edc:	8c620004 	lw	v0,4(v1)
9d002ee0:	24040001 	li	a0,1
9d002ee4:	7c8239c4 	ins	v0,a0,0x7,0x1
9d002ee8:	ac620004 	sw	v0,4(v1)

        //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
        if (SetupPkt.EPDir == OUT_FROM_HOST)
9d002eec:	9382805c 	lbu	v0,-32676(gp)
9d002ef0:	304300ff 	andi	v1,v0,0xff
9d002ef4:	2402ff80 	li	v0,-128
9d002ef8:	00621024 	and	v0,v1,v0
9d002efc:	304200ff 	andi	v0,v0,0xff
9d002f00:	14400013 	bnez	v0,9d002f50 <USBCtrlEPAllowDataStage+0x1c80>
9d002f04:	00000000 	nop
        {
            p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
9d002f08:	8f82805c 	lw	v0,-32676(gp)
9d002f0c:	7c421800 	ext	v0,v0,0x0,0x4
9d002f10:	304200ff 	andi	v0,v0,0xff
9d002f14:	00021880 	sll	v1,v0,0x2
9d002f18:	27828044 	addiu	v0,gp,-32700
9d002f1c:	00621021 	addu	v0,v1,v0
9d002f20:	8c420000 	lw	v0,0(v0)
9d002f24:	afc20014 	sw	v0,20(s8)

            current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
9d002f28:	8f82805c 	lw	v0,-32676(gp)
9d002f2c:	7c421800 	ext	v0,v0,0x0,0x4
9d002f30:	304200ff 	andi	v0,v0,0xff
9d002f34:	00401821 	move	v1,v0
9d002f38:	27828040 	addiu	v0,gp,-32704
9d002f3c:	00621021 	addu	v0,v1,v0
9d002f40:	90420000 	lbu	v0,0(v0)
9d002f44:	a3c20018 	sb	v0,24(s8)
9d002f48:	0b400be4 	j	9d002f90 <USBCtrlEPAllowDataStage+0x1cc0>
9d002f4c:	00000000 	nop
        }
        else
        {
            p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
9d002f50:	8f82805c 	lw	v0,-32676(gp)
9d002f54:	7c421800 	ext	v0,v0,0x0,0x4
9d002f58:	304200ff 	andi	v0,v0,0xff
9d002f5c:	00021880 	sll	v1,v0,0x2
9d002f60:	27828038 	addiu	v0,gp,-32712
9d002f64:	00621021 	addu	v0,v1,v0
9d002f68:	8c420000 	lw	v0,0(v0)
9d002f6c:	afc20014 	sw	v0,20(s8)

            current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
9d002f70:	8f82805c 	lw	v0,-32676(gp)
9d002f74:	7c421800 	ext	v0,v0,0x0,0x4
9d002f78:	304200ff 	andi	v0,v0,0xff
9d002f7c:	00401821 	move	v1,v0
9d002f80:	27828060 	addiu	v0,gp,-32672
9d002f84:	00621021 	addu	v0,v1,v0
9d002f88:	90420000 	lbu	v0,0(v0)
9d002f8c:	a3c20018 	sb	v0,24(s8)

        //If ping pong buffering is enabled on the requested endpoint, need 
        //to point to the one that is the active BDT entry which the SIE will 
        //use for the next attempted transaction on that EP number.
#if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
        if (current_ep_data.bits.ping_pong_state == 0) //Check if even
9d002f90:	93c20018 	lbu	v0,24(s8)
9d002f94:	30420001 	andi	v0,v0,0x1
9d002f98:	304200ff 	andi	v0,v0,0xff
9d002f9c:	1440000a 	bnez	v0,9d002fc8 <USBCtrlEPAllowDataStage+0x1cf8>
9d002fa0:	00000000 	nop
        {
            USBHALPingPongSetToEven(&p);
9d002fa4:	27c20014 	addiu	v0,s8,20
9d002fa8:	27c30014 	addiu	v1,s8,20
9d002fac:	90640000 	lbu	a0,0(v1)
9d002fb0:	2403fff7 	li	v1,-9
9d002fb4:	00831824 	and	v1,a0,v1
9d002fb8:	306300ff 	andi	v1,v1,0xff
9d002fbc:	a0430000 	sb	v1,0(v0)
9d002fc0:	0b400bf8 	j	9d002fe0 <USBCtrlEPAllowDataStage+0x1d10>
9d002fc4:	00000000 	nop
        }
        else //else must have been odd
        {
            USBHALPingPongSetToOdd(&p);
9d002fc8:	27c20014 	addiu	v0,s8,20
9d002fcc:	27c30014 	addiu	v1,s8,20
9d002fd0:	90630000 	lbu	v1,0(v1)
9d002fd4:	34630008 	ori	v1,v1,0x8
9d002fd8:	306300ff 	andi	v1,v1,0xff
9d002fdc:	a0430000 	sb	v1,0(v0)
        }
#endif
        
        //Update the BDT pointers with the new, next entry based on the feature
        //  request
        if (SetupPkt.EPDir == OUT_FROM_HOST)
9d002fe0:	9382805c 	lbu	v0,-32676(gp)
9d002fe4:	304300ff 	andi	v1,v0,0xff
9d002fe8:	2402ff80 	li	v0,-128
9d002fec:	00621024 	and	v0,v1,v0
9d002ff0:	304200ff 	andi	v0,v0,0xff
9d002ff4:	1440000b 	bnez	v0,9d003024 <USBCtrlEPAllowDataStage+0x1d54>
9d002ff8:	00000000 	nop
        {
            pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
9d002ffc:	8f82805c 	lw	v0,-32676(gp)
9d003000:	7c421800 	ext	v0,v0,0x0,0x4
9d003004:	304200ff 	andi	v0,v0,0xff
9d003008:	8fc30014 	lw	v1,20(s8)
9d00300c:	00022080 	sll	a0,v0,0x2
9d003010:	27828044 	addiu	v0,gp,-32700
9d003014:	00821021 	addu	v0,a0,v0
9d003018:	ac430000 	sw	v1,0(v0)
9d00301c:	0b400c11 	j	9d003044 <USBCtrlEPAllowDataStage+0x1d74>
9d003020:	00000000 	nop
        }
        else
        {
            pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
9d003024:	8f82805c 	lw	v0,-32676(gp)
9d003028:	7c421800 	ext	v0,v0,0x0,0x4
9d00302c:	304200ff 	andi	v0,v0,0xff
9d003030:	8fc30014 	lw	v1,20(s8)
9d003034:	00022080 	sll	a0,v0,0x2
9d003038:	27828038 	addiu	v0,gp,-32712
9d00303c:	00821021 	addu	v0,a0,v0
9d003040:	ac430000 	sw	v1,0(v0)
        }

		//Check if it was a SET_FEATURE endpoint halt request
        if (SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
9d003044:	93828059 	lbu	v0,-32679(gp)
9d003048:	304300ff 	andi	v1,v0,0xff
9d00304c:	24020003 	li	v0,3
9d003050:	1462003b 	bne	v1,v0,9d003140 <USBCtrlEPAllowDataStage+0x1e70>
9d003054:	00000000 	nop
        {
            if (p->STAT.UOWN == 1)
9d003058:	8fc20014 	lw	v0,20(s8)
9d00305c:	90430000 	lbu	v1,0(v0)
9d003060:	2402ff80 	li	v0,-128
9d003064:	00621024 	and	v0,v1,v0
9d003068:	304200ff 	andi	v0,v0,0xff
9d00306c:	1040001e 	beqz	v0,9d0030e8 <USBCtrlEPAllowDataStage+0x1e18>
9d003070:	00000000 	nop
            {
                //Mark that we are terminating this transfer and that the user
                //  needs to be notified later
                if (SetupPkt.EPDir == OUT_FROM_HOST)
9d003074:	9382805c 	lbu	v0,-32676(gp)
9d003078:	304300ff 	andi	v1,v0,0xff
9d00307c:	2402ff80 	li	v0,-128
9d003080:	00621024 	and	v0,v1,v0
9d003084:	304200ff 	andi	v0,v0,0xff
9d003088:	1440000d 	bnez	v0,9d0030c0 <USBCtrlEPAllowDataStage+0x1df0>
9d00308c:	00000000 	nop
                {
                    ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
9d003090:	8f82805c 	lw	v0,-32676(gp)
9d003094:	7c421800 	ext	v0,v0,0x0,0x4
9d003098:	304200ff 	andi	v0,v0,0xff
9d00309c:	00401821 	move	v1,v0
9d0030a0:	27828040 	addiu	v0,gp,-32704
9d0030a4:	00621821 	addu	v1,v1,v0
9d0030a8:	90620000 	lbu	v0,0(v1)
9d0030ac:	24040001 	li	a0,1
9d0030b0:	7c820844 	ins	v0,a0,0x1,0x1
9d0030b4:	a0620000 	sb	v0,0(v1)
9d0030b8:	0b400c3a 	j	9d0030e8 <USBCtrlEPAllowDataStage+0x1e18>
9d0030bc:	00000000 	nop
                }
                else
                {
                    ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
9d0030c0:	8f82805c 	lw	v0,-32676(gp)
9d0030c4:	7c421800 	ext	v0,v0,0x0,0x4
9d0030c8:	304200ff 	andi	v0,v0,0xff
9d0030cc:	00401821 	move	v1,v0
9d0030d0:	27828060 	addiu	v0,gp,-32672
9d0030d4:	00621821 	addu	v1,v1,v0
9d0030d8:	90620000 	lbu	v0,0(v1)
9d0030dc:	24040001 	li	a0,1
9d0030e0:	7c820844 	ins	v0,a0,0x1,0x1
9d0030e4:	a0620000 	sb	v0,0(v1)
                }
            }

			//Then STALL the endpoint
            p->STAT.Val |= _USIE | _BSTALL;
9d0030e8:	8fc20014 	lw	v0,20(s8)
9d0030ec:	8fc30014 	lw	v1,20(s8)
9d0030f0:	90640000 	lbu	a0,0(v1)
9d0030f4:	90630001 	lbu	v1,1(v1)
9d0030f8:	00031a00 	sll	v1,v1,0x8
9d0030fc:	00641825 	or	v1,v1,a0
9d003100:	3063ffff 	andi	v1,v1,0xffff
9d003104:	34630084 	ori	v1,v1,0x84
9d003108:	3063ffff 	andi	v1,v1,0xffff
9d00310c:	306400ff 	andi	a0,v1,0xff
9d003110:	90450000 	lbu	a1,0(v0)
9d003114:	30a50000 	andi	a1,a1,0x0
9d003118:	00a42025 	or	a0,a1,a0
9d00311c:	a0440000 	sb	a0,0(v0)
9d003120:	00031a02 	srl	v1,v1,0x8
9d003124:	3063ffff 	andi	v1,v1,0xffff
9d003128:	90440001 	lbu	a0,1(v0)
9d00312c:	30840000 	andi	a0,a0,0x0
9d003130:	00831825 	or	v1,a0,v1
9d003134:	a0430001 	sb	v1,1(v0)
9d003138:	0b400d11 	j	9d003444 <USBCtrlEPAllowDataStage+0x2174>
9d00313c:	00000000 	nop
        else
        {
			//Else the request must have been a CLEAR_FEATURE endpoint halt.
#if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
            //toggle over the to the non-active BDT
            USBAdvancePingPongBuffer(&p);  
9d003140:	27c20014 	addiu	v0,s8,20
9d003144:	27c30014 	addiu	v1,s8,20
9d003148:	90630000 	lbu	v1,0(v1)
9d00314c:	38630008 	xori	v1,v1,0x8
9d003150:	306300ff 	andi	v1,v1,0xff
9d003154:	a0430000 	sb	v1,0(v0)

            if (p->STAT.UOWN == 1)
9d003158:	8fc20014 	lw	v0,20(s8)
9d00315c:	90430000 	lbu	v1,0(v0)
9d003160:	2402ff80 	li	v0,-128
9d003164:	00621024 	and	v0,v1,v0
9d003168:	304200ff 	andi	v0,v0,0xff
9d00316c:	10400032 	beqz	v0,9d003238 <USBCtrlEPAllowDataStage+0x1f68>
9d003170:	00000000 	nop
            {
                //Clear UOWN and set DTS state so it will be correct the next time
                //the application firmware uses USBTransferOnePacket() on the EP.
                p->STAT.Val &= (~_USIE);    //Clear UOWN bit
9d003174:	8fc20014 	lw	v0,20(s8)
9d003178:	8fc30014 	lw	v1,20(s8)
9d00317c:	90640000 	lbu	a0,0(v1)
9d003180:	90630001 	lbu	v1,1(v1)
9d003184:	00031a00 	sll	v1,v1,0x8
9d003188:	00641825 	or	v1,v1,a0
9d00318c:	3064ffff 	andi	a0,v1,0xffff
9d003190:	2403ff7f 	li	v1,-129
9d003194:	00831824 	and	v1,a0,v1
9d003198:	3063ffff 	andi	v1,v1,0xffff
9d00319c:	306400ff 	andi	a0,v1,0xff
9d0031a0:	90450000 	lbu	a1,0(v0)
9d0031a4:	30a50000 	andi	a1,a1,0x0
9d0031a8:	00a42025 	or	a0,a1,a0
9d0031ac:	a0440000 	sb	a0,0(v0)
9d0031b0:	00031a02 	srl	v1,v1,0x8
9d0031b4:	3063ffff 	andi	v1,v1,0xffff
9d0031b8:	90440001 	lbu	a0,1(v0)
9d0031bc:	30840000 	andi	a0,a0,0x0
9d0031c0:	00831825 	or	v1,a0,v1
9d0031c4:	a0430001 	sb	v1,1(v0)
                p->STAT.Val |= _DAT1;       //Set DTS to DATA1
9d0031c8:	8fc20014 	lw	v0,20(s8)
9d0031cc:	8fc30014 	lw	v1,20(s8)
9d0031d0:	90640000 	lbu	a0,0(v1)
9d0031d4:	90630001 	lbu	v1,1(v1)
9d0031d8:	00031a00 	sll	v1,v1,0x8
9d0031dc:	00641825 	or	v1,v1,a0
9d0031e0:	3063ffff 	andi	v1,v1,0xffff
9d0031e4:	34630040 	ori	v1,v1,0x40
9d0031e8:	3063ffff 	andi	v1,v1,0xffff
9d0031ec:	306400ff 	andi	a0,v1,0xff
9d0031f0:	90450000 	lbu	a1,0(v0)
9d0031f4:	30a50000 	andi	a1,a1,0x0
9d0031f8:	00a42025 	or	a0,a1,a0
9d0031fc:	a0440000 	sb	a0,0(v0)
9d003200:	00031a02 	srl	v1,v1,0x8
9d003204:	3063ffff 	andi	v1,v1,0xffff
9d003208:	90440001 	lbu	a0,1(v0)
9d00320c:	30840000 	andi	a0,a0,0x0
9d003210:	00831825 	or	v1,a0,v1
9d003214:	a0430001 	sb	v1,1(v0)

                USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED, p, sizeof(p));
9d003218:	8fc20014 	lw	v0,20(s8)
9d00321c:	24040005 	li	a0,5
9d003220:	00402821 	move	a1,v0
9d003224:	24060004 	li	a2,4
9d003228:	0f4018f1 	jal	9d0063c4 <USER_USB_CALLBACK_EVENT_HANDLER>
9d00322c:	00000000 	nop
9d003230:	0b400ca2 	j	9d003288 <USBCtrlEPAllowDataStage+0x1fb8>
9d003234:	00000000 	nop
            }
            else
            {
                //UOWN already clear, but still need to set DTS to DATA1     
                p->STAT.Val |= _DAT1;
9d003238:	8fc20014 	lw	v0,20(s8)
9d00323c:	8fc30014 	lw	v1,20(s8)
9d003240:	90640000 	lbu	a0,0(v1)
9d003244:	90630001 	lbu	v1,1(v1)
9d003248:	00031a00 	sll	v1,v1,0x8
9d00324c:	00641825 	or	v1,v1,a0
9d003250:	3063ffff 	andi	v1,v1,0xffff
9d003254:	34630040 	ori	v1,v1,0x40
9d003258:	3063ffff 	andi	v1,v1,0xffff
9d00325c:	306400ff 	andi	a0,v1,0xff
9d003260:	90450000 	lbu	a1,0(v0)
9d003264:	30a50000 	andi	a1,a1,0x0
9d003268:	00a42025 	or	a0,a1,a0
9d00326c:	a0440000 	sb	a0,0(v0)
9d003270:	00031a02 	srl	v1,v1,0x8
9d003274:	3063ffff 	andi	v1,v1,0xffff
9d003278:	90440001 	lbu	a0,1(v0)
9d00327c:	30840000 	andi	a0,a0,0x0
9d003280:	00831825 	or	v1,a0,v1
9d003284:	a0430001 	sb	v1,1(v0)
            }

            //toggle back to the active BDT (the one the SIE is currently looking at
            //and will use for the next successful transaction to take place on the EP
            USBAdvancePingPongBuffer(&p);    
9d003288:	27c20014 	addiu	v0,s8,20
9d00328c:	27c30014 	addiu	v1,s8,20
9d003290:	90630000 	lbu	v1,0(v1)
9d003294:	38630008 	xori	v1,v1,0x8
9d003298:	306300ff 	andi	v1,v1,0xff
9d00329c:	a0430000 	sb	v1,0(v0)
                
            //Check if we are currently terminating, or have previously terminated
            //a transaction on the given endpoint.  If so, need to clear UOWN,
            //set DTS to the proper state, and call the application callback
            //function.
            if ((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
9d0032a0:	93c20018 	lbu	v0,24(s8)
9d0032a4:	30420002 	andi	v0,v0,0x2
9d0032a8:	304200ff 	andi	v0,v0,0xff
9d0032ac:	14400008 	bnez	v0,9d0032d0 <USBCtrlEPAllowDataStage+0x2000>
9d0032b0:	00000000 	nop
9d0032b4:	8fc20014 	lw	v0,20(s8)
9d0032b8:	90430000 	lbu	v1,0(v0)
9d0032bc:	2402ff80 	li	v0,-128
9d0032c0:	00621024 	and	v0,v1,v0
9d0032c4:	304200ff 	andi	v0,v0,0xff
9d0032c8:	10400039 	beqz	v0,9d0033b0 <USBCtrlEPAllowDataStage+0x20e0>
9d0032cc:	00000000 	nop
            {
                if(SetupPkt.EPDir == OUT_FROM_HOST)
9d0032d0:	9382805c 	lbu	v0,-32676(gp)
9d0032d4:	304300ff 	andi	v1,v0,0xff
9d0032d8:	2402ff80 	li	v0,-128
9d0032dc:	00621024 	and	v0,v1,v0
9d0032e0:	304200ff 	andi	v0,v0,0xff
9d0032e4:	1440000c 	bnez	v0,9d003318 <USBCtrlEPAllowDataStage+0x2048>
9d0032e8:	00000000 	nop
                {
                    ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
9d0032ec:	8f82805c 	lw	v0,-32676(gp)
9d0032f0:	7c421800 	ext	v0,v0,0x0,0x4
9d0032f4:	304200ff 	andi	v0,v0,0xff
9d0032f8:	00401821 	move	v1,v0
9d0032fc:	27828040 	addiu	v0,gp,-32704
9d003300:	00621821 	addu	v1,v1,v0
9d003304:	90620000 	lbu	v0,0(v1)
9d003308:	7c020844 	ins	v0,zero,0x1,0x1
9d00330c:	a0620000 	sb	v0,0(v1)
9d003310:	0b400ccf 	j	9d00333c <USBCtrlEPAllowDataStage+0x206c>
9d003314:	00000000 	nop
                }
                else
                {
                    ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
9d003318:	8f82805c 	lw	v0,-32676(gp)
9d00331c:	7c421800 	ext	v0,v0,0x0,0x4
9d003320:	304200ff 	andi	v0,v0,0xff
9d003324:	00401821 	move	v1,v0
9d003328:	27828060 	addiu	v0,gp,-32672
9d00332c:	00621821 	addu	v1,v1,v0
9d003330:	90620000 	lbu	v0,0(v1)
9d003334:	7c020844 	ins	v0,zero,0x1,0x1
9d003338:	a0620000 	sb	v0,0(v1)
                }

                //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
                p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
9d00333c:	8fc20014 	lw	v0,20(s8)
9d003340:	8fc30014 	lw	v1,20(s8)
9d003344:	90640000 	lbu	a0,0(v1)
9d003348:	90630001 	lbu	v1,1(v1)
9d00334c:	00031a00 	sll	v1,v1,0x8
9d003350:	00641825 	or	v1,v1,a0
9d003354:	3064ffff 	andi	a0,v1,0xffff
9d003358:	2403ff3b 	li	v1,-197
9d00335c:	00831824 	and	v1,a0,v1
9d003360:	3063ffff 	andi	v1,v1,0xffff
9d003364:	306400ff 	andi	a0,v1,0xff
9d003368:	90450000 	lbu	a1,0(v0)
9d00336c:	30a50000 	andi	a1,a1,0x0
9d003370:	00a42025 	or	a0,a1,a0
9d003374:	a0440000 	sb	a0,0(v0)
9d003378:	00031a02 	srl	v1,v1,0x8
9d00337c:	3063ffff 	andi	v1,v1,0xffff
9d003380:	90440001 	lbu	a0,1(v0)
9d003384:	30840000 	andi	a0,a0,0x0
9d003388:	00831825 	or	v1,a0,v1
9d00338c:	a0430001 	sb	v1,1(v0)

                //Call the application event handler callback function, so it can 
                //decide if the endpoint should get re-armed again or not.
                USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED, p, sizeof(p));
9d003390:	8fc20014 	lw	v0,20(s8)
9d003394:	24040005 	li	a0,5
9d003398:	00402821 	move	a1,v0
9d00339c:	24060004 	li	a2,4
9d0033a0:	0f4018f1 	jal	9d0063c4 <USER_USB_CALLBACK_EVENT_HANDLER>
9d0033a4:	00000000 	nop
9d0033a8:	0b400d01 	j	9d003404 <USBCtrlEPAllowDataStage+0x2134>
9d0033ac:	00000000 	nop
            }
            else
            {
                //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
                p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
9d0033b0:	8fc20014 	lw	v0,20(s8)
9d0033b4:	8fc30014 	lw	v1,20(s8)
9d0033b8:	90640000 	lbu	a0,0(v1)
9d0033bc:	90630001 	lbu	v1,1(v1)
9d0033c0:	00031a00 	sll	v1,v1,0x8
9d0033c4:	00641825 	or	v1,v1,a0
9d0033c8:	3064ffff 	andi	a0,v1,0xffff
9d0033cc:	2403ff3b 	li	v1,-197
9d0033d0:	00831824 	and	v1,a0,v1
9d0033d4:	3063ffff 	andi	v1,v1,0xffff
9d0033d8:	306400ff 	andi	a0,v1,0xff
9d0033dc:	90450000 	lbu	a1,0(v0)
9d0033e0:	30a50000 	andi	a1,a1,0x0
9d0033e4:	00a42025 	or	a0,a1,a0
9d0033e8:	a0440000 	sb	a0,0(v0)
9d0033ec:	00031a02 	srl	v1,v1,0x8
9d0033f0:	3063ffff 	andi	v1,v1,0xffff
9d0033f4:	90440001 	lbu	a0,1(v0)
9d0033f8:	30840000 	andi	a0,a0,0x0
9d0033fc:	00831825 	or	v1,a0,v1
9d003400:	a0430001 	sb	v1,1(v0)
                p->STAT.Val |= _DAT1;
            } 
#endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
            
			//Get a pointer to the appropriate UEPn register
            pUEP = (UINT32*)(&U1EP0);
9d003404:	3c02bf88 	lui	v0,0xbf88
9d003408:	24425300 	addiu	v0,v0,21248
9d00340c:	afc20010 	sw	v0,16(s8)
            pUEP += (SetupPkt.EPNum * 4);
9d003410:	8f82805c 	lw	v0,-32676(gp)
9d003414:	7c421800 	ext	v0,v0,0x0,0x4
9d003418:	304200ff 	andi	v0,v0,0xff
9d00341c:	00021100 	sll	v0,v0,0x4
9d003420:	8fc30010 	lw	v1,16(s8)
9d003424:	00621021 	addu	v0,v1,v0
9d003428:	afc20010 	sw	v0,16(s8)

			//Clear the STALL bit in the UEP register
            *pUEP &= ~UEP_STALL;            
9d00342c:	8fc20010 	lw	v0,16(s8)
9d003430:	8c430000 	lw	v1,0(v0)
9d003434:	2402fffd 	li	v0,-3
9d003438:	00621824 	and	v1,v1,v0
9d00343c:	8fc20010 	lw	v0,16(s8)
9d003440:	ac430000 	sw	v1,0(v0)
        }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
    }//end if (lots of checks for set/clear endpoint halt)
}//end USBStdFeatureReqHandler
9d003444:	03c0e821 	move	sp,s8
9d003448:	8fbf0024 	lw	ra,36(sp)
9d00344c:	8fbe0020 	lw	s8,32(sp)
9d003450:	27bd0028 	addiu	sp,sp,40
9d003454:	03e00008 	jr	ra
9d003458:	00000000 	nop
_IRQL_requires_max_(PASSIVE_LEVEL)
static BOOLEAN lWritePortData(
  _In_ TUtPepLogicData* pLogicData,
  _In_ UINT8 nData,
  _In_ UINT8 nUnit)
{
9d00345c:	27bdffe0 	addiu	sp,sp,-32
9d003460:	afbf001c 	sw	ra,28(sp)
9d003464:	afbe0018 	sw	s8,24(sp)
9d003468:	03a0f021 	move	s8,sp
9d00346c:	afc40020 	sw	a0,32(s8)
9d003470:	00a01821 	move	v1,a1
9d003474:	00c01021 	move	v0,a2
9d003478:	a3c30024 	sb	v1,36(s8)
9d00347c:	a3c20028 	sb	v0,40(s8)
    BOOLEAN bResult = FALSE;
9d003480:	a3c00010 	sb	zero,16(s8)
    pLogicData->pLogFunc("lWritePortData entering.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif
#endif

    nTmpData[0] = MPortData(nData, nUnit, CUnitOff);
9d003484:	83c20024 	lb	v0,36(s8)
9d003488:	3042000f 	andi	v0,v0,0xf
9d00348c:	7c021c20 	seb	v1,v0
9d003490:	93c20028 	lbu	v0,40(s8)
9d003494:	30420007 	andi	v0,v0,0x7
9d003498:	00021100 	sll	v0,v0,0x4
9d00349c:	7c021420 	seb	v0,v0
9d0034a0:	00621025 	or	v0,v1,v0
9d0034a4:	7c021420 	seb	v0,v0
9d0034a8:	304200ff 	andi	v0,v0,0xff
9d0034ac:	a3c20014 	sb	v0,20(s8)
    nTmpData[1] = MPortData(nData, nUnit, CUnitOn);
9d0034b0:	83c20024 	lb	v0,36(s8)
9d0034b4:	3042000f 	andi	v0,v0,0xf
9d0034b8:	7c021c20 	seb	v1,v0
9d0034bc:	93c20028 	lbu	v0,40(s8)
9d0034c0:	30420007 	andi	v0,v0,0x7
9d0034c4:	00021100 	sll	v0,v0,0x4
9d0034c8:	7c021420 	seb	v0,v0
9d0034cc:	00621025 	or	v0,v1,v0
9d0034d0:	7c021c20 	seb	v1,v0
9d0034d4:	2402ff80 	li	v0,-128
9d0034d8:	00621025 	or	v0,v1,v0
9d0034dc:	7c021420 	seb	v0,v0
9d0034e0:	304200ff 	andi	v0,v0,0xff
9d0034e4:	a3c20015 	sb	v0,21(s8)
    nTmpData[2] = MPortData(nData, nUnit, CUnitOff);
9d0034e8:	83c20024 	lb	v0,36(s8)
9d0034ec:	3042000f 	andi	v0,v0,0xf
9d0034f0:	7c021c20 	seb	v1,v0
9d0034f4:	93c20028 	lbu	v0,40(s8)
9d0034f8:	30420007 	andi	v0,v0,0x7
9d0034fc:	00021100 	sll	v0,v0,0x4
9d003500:	7c021420 	seb	v0,v0
9d003504:	00621025 	or	v0,v1,v0
9d003508:	7c021420 	seb	v0,v0
9d00350c:	304200ff 	andi	v0,v0,0xff
9d003510:	a3c20016 	sb	v0,22(s8)

    bResult = pLogicData->pWritePortFunc(
9d003514:	8fc20020 	lw	v0,32(s8)
9d003518:	8c420004 	lw	v0,4(v0)
9d00351c:	27c30014 	addiu	v1,s8,20
9d003520:	00602021 	move	a0,v1
9d003524:	24050003 	li	a1,3
9d003528:	2406000a 	li	a2,10
9d00352c:	0040f809 	jalr	v0
9d003530:	00000000 	nop
9d003534:	a3c20010 	sb	v0,16(s8)
	pLogicData->pLogFunc("lWritePortData leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif
#endif

	return bResult;
9d003538:	93c20010 	lbu	v0,16(s8)
}
9d00353c:	03c0e821 	move	sp,s8
9d003540:	8fbf001c 	lw	ra,28(sp)
9d003544:	8fbe0018 	lw	s8,24(sp)
9d003548:	27bd0020 	addiu	sp,sp,32
9d00354c:	03e00008 	jr	ra
9d003550:	00000000 	nop

_IRQL_requires_max_(PASSIVE_LEVEL)
static BOOLEAN lReadByteFromProgrammer(
  _In_ TUtPepLogicData* pLogicData,
  _Out_ UINT8* pnByte)
{
9d003554:	27bdffe0 	addiu	sp,sp,-32
9d003558:	afbf001c 	sw	ra,28(sp)
9d00355c:	afbe0018 	sw	s8,24(sp)
9d003560:	03a0f021 	move	s8,sp
9d003564:	afc40020 	sw	a0,32(s8)
9d003568:	afc50024 	sw	a1,36(s8)
    UINT8 nBitPosition = 0;
9d00356c:	a3c00010 	sb	zero,16(s8)
    UINT8 nData = 0;
9d003570:	a3c00011 	sb	zero,17(s8)

#if defined(BUILD_DRIVER_LIB)
	PAGED_CODE()
#endif

    *pnByte = 0;
9d003574:	8fc20024 	lw	v0,36(s8)
9d003578:	a0400000 	sb	zero,0(v0)

    while (nBitPosition < 8)
9d00357c:	0b400d8c 	j	9d003630 <USBCtrlEPAllowDataStage+0x2360>
9d003580:	00000000 	nop
    {
        nTmpData = MPortData(nBitPosition, CUnit_DontCare, CUnitOff);
9d003584:	93c20010 	lbu	v0,16(s8)
9d003588:	3042000f 	andi	v0,v0,0xf
9d00358c:	304200ff 	andi	v0,v0,0xff
9d003590:	a3c20013 	sb	v0,19(s8)

		if (!pLogicData->pWritePortFunc(
9d003594:	8fc20020 	lw	v0,32(s8)
9d003598:	8c420004 	lw	v0,4(v0)
9d00359c:	27c30013 	addiu	v1,s8,19
9d0035a0:	00602021 	move	a0,v1
9d0035a4:	24050001 	li	a1,1
9d0035a8:	2406000a 	li	a2,10
9d0035ac:	0040f809 	jalr	v0
9d0035b0:	00000000 	nop
9d0035b4:	14400004 	bnez	v0,9d0035c8 <USBCtrlEPAllowDataStage+0x22f8>
9d0035b8:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lReadByteFromProgrammer leaving.  (Write port failed)  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

			return FALSE;
9d0035bc:	00001021 	move	v0,zero
9d0035c0:	0b400d97 	j	9d00365c <USBCtrlEPAllowDataStage+0x238c>
9d0035c4:	00000000 	nop
		}

		if (!pLogicData->pReadBitPortFunc(
9d0035c8:	8fc20020 	lw	v0,32(s8)
9d0035cc:	8c420000 	lw	v0,0(v0)
9d0035d0:	27c30014 	addiu	v1,s8,20
9d0035d4:	00602021 	move	a0,v1
9d0035d8:	0040f809 	jalr	v0
9d0035dc:	00000000 	nop
9d0035e0:	14400004 	bnez	v0,9d0035f4 <USBCtrlEPAllowDataStage+0x2324>
9d0035e4:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lReadByteFromProgrammer leaving.  (Read bit from port failed)  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif
			
			return FALSE;
9d0035e8:	00001021 	move	v0,zero
9d0035ec:	0b400d97 	j	9d00365c <USBCtrlEPAllowDataStage+0x238c>
9d0035f0:	00000000 	nop
        }

        nPortOutput = (bValue == TRUE) ? 0x01 : 0x00;
9d0035f4:	93c20014 	lbu	v0,20(s8)
9d0035f8:	38420001 	xori	v0,v0,0x1
9d0035fc:	2c420001 	sltiu	v0,v0,1
9d003600:	a3c20012 	sb	v0,18(s8)

        nPortOutput <<= nBitPosition;
9d003604:	93c30012 	lbu	v1,18(s8)
9d003608:	93c20010 	lbu	v0,16(s8)
9d00360c:	00431004 	sllv	v0,v1,v0
9d003610:	a3c20012 	sb	v0,18(s8)

        nData |= nPortOutput;
9d003614:	93c30011 	lbu	v1,17(s8)
9d003618:	93c20012 	lbu	v0,18(s8)
9d00361c:	00621025 	or	v0,v1,v0
9d003620:	a3c20011 	sb	v0,17(s8)

        ++nBitPosition;
9d003624:	93c20010 	lbu	v0,16(s8)
9d003628:	24420001 	addiu	v0,v0,1
9d00362c:	a3c20010 	sb	v0,16(s8)
	PAGED_CODE()
#endif

    *pnByte = 0;

    while (nBitPosition < 8)
9d003630:	93c20010 	lbu	v0,16(s8)
9d003634:	2c420008 	sltiu	v0,v0,8
9d003638:	1440ffd2 	bnez	v0,9d003584 <USBCtrlEPAllowDataStage+0x22b4>
9d00363c:	00000000 	nop
        nData |= nPortOutput;

        ++nBitPosition;
    }

    nData = ~nData;
9d003640:	93c20011 	lbu	v0,17(s8)
9d003644:	00021027 	nor	v0,zero,v0
9d003648:	a3c20011 	sb	v0,17(s8)
#if defined(ENABLE_LOGGING) 
    pLogicData->pLogFunc("lReadByteFromProgrammer - Retrieved the byte 0x%X.  (Thread: 0x%p)\n",
		                 (ULONG)nData, MCurrentThreadId());
#endif

    *pnByte = nData;
9d00364c:	8fc20024 	lw	v0,36(s8)
9d003650:	93c30011 	lbu	v1,17(s8)
9d003654:	a0430000 	sb	v1,0(v0)
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("lReadByteFromProgrammer leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

    return TRUE;
9d003658:	24020001 	li	v0,1
}
9d00365c:	03c0e821 	move	sp,s8
9d003660:	8fbf001c 	lw	ra,28(sp)
9d003664:	8fbe0018 	lw	s8,24(sp)
9d003668:	27bd0020 	addiu	sp,sp,32
9d00366c:	03e00008 	jr	ra
9d003670:	00000000 	nop

_IRQL_requires_max_(PASSIVE_LEVEL)
static BOOLEAN lWriteByteToProgrammer(
  _In_ TUtPepLogicData* pLogicData,
  _In_ UINT8 nByte)
{
9d003674:	27bdffe0 	addiu	sp,sp,-32
9d003678:	afbf001c 	sw	ra,28(sp)
9d00367c:	afbe0018 	sw	s8,24(sp)
9d003680:	03a0f021 	move	s8,sp
9d003684:	afc40020 	sw	a0,32(s8)
9d003688:	00a01021 	move	v0,a1
9d00368c:	a3c20024 	sb	v0,36(s8)
    UINT8 nDataLow = nByte & 0x0F;
9d003690:	93c20024 	lbu	v0,36(s8)
9d003694:	3042000f 	andi	v0,v0,0xf
9d003698:	a3c20010 	sb	v0,16(s8)
    UINT8 nDataHigh = nByte >> 4;
9d00369c:	93c20024 	lbu	v0,36(s8)
9d0036a0:	00021102 	srl	v0,v0,0x4
9d0036a4:	a3c20011 	sb	v0,17(s8)
#if defined(ENABLE_LOGGING) 
    pLogicData->pLogFunc("lWriteByteToProgrammer - Writing the byte 0x%X.  (Thread: 0x%p)\n",
		                 (ULONG)nByte, MCurrentThreadId());
#endif

    if (lWritePortData(pLogicData, nDataLow, CUnit0_DataBits0To3) &&
9d0036a8:	93c20010 	lbu	v0,16(s8)
9d0036ac:	8fc40020 	lw	a0,32(s8)
9d0036b0:	00402821 	move	a1,v0
9d0036b4:	00003021 	move	a2,zero
9d0036b8:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d0036bc:	00000000 	nop
9d0036c0:	1040000c 	beqz	v0,9d0036f4 <USBCtrlEPAllowDataStage+0x2424>
9d0036c4:	00000000 	nop
        lWritePortData(pLogicData, nDataHigh, CUnit1_DataBits4To7))
9d0036c8:	93c20011 	lbu	v0,17(s8)
9d0036cc:	8fc40020 	lw	a0,32(s8)
9d0036d0:	00402821 	move	a1,v0
9d0036d4:	24060001 	li	a2,1
9d0036d8:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d0036dc:	00000000 	nop
#if defined(ENABLE_LOGGING) 
    pLogicData->pLogFunc("lWriteByteToProgrammer - Writing the byte 0x%X.  (Thread: 0x%p)\n",
		                 (ULONG)nByte, MCurrentThreadId());
#endif

    if (lWritePortData(pLogicData, nDataLow, CUnit0_DataBits0To3) &&
9d0036e0:	10400004 	beqz	v0,9d0036f4 <USBCtrlEPAllowDataStage+0x2424>
9d0036e4:	00000000 	nop
#if defined(ENABLE_LOGGING) 
		pLogicData->pLogFunc("lWriteByteToProgrammer leaving.  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif
		
		return TRUE;
9d0036e8:	24020001 	li	v0,1
9d0036ec:	0b400dbe 	j	9d0036f8 <USBCtrlEPAllowDataStage+0x2428>
9d0036f0:	00000000 	nop
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("lWriteByteToProgrammer leaving.  (Write port data failed)  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

    return FALSE;
9d0036f4:	00001021 	move	v0,zero
}
9d0036f8:	03c0e821 	move	sp,s8
9d0036fc:	8fbf001c 	lw	ra,28(sp)
9d003700:	8fbe0018 	lw	s8,24(sp)
9d003704:	27bd0020 	addiu	sp,sp,32
9d003708:	03e00008 	jr	ra
9d00370c:	00000000 	nop

_IRQL_requires_max_(PASSIVE_LEVEL)
static BOOLEAN lSetProgrammerAddress(
  _In_ TUtPepLogicData* pLogicData,
  _In_ UINT32 nAddress)
{
9d003710:	27bdffd8 	addiu	sp,sp,-40
9d003714:	afbf0024 	sw	ra,36(sp)
9d003718:	afbe0020 	sw	s8,32(sp)
9d00371c:	03a0f021 	move	s8,sp
9d003720:	afc40028 	sw	a0,40(s8)
9d003724:	afc5002c 	sw	a1,44(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d003728:	8fc20028 	lw	v0,40(s8)
9d00372c:	8c420008 	lw	v0,8(v0)
9d003730:	afc20014 	sw	v0,20(s8)
    UINT32 nLastAddress = pData->nLastAddress;
9d003734:	8fc20014 	lw	v0,20(s8)
9d003738:	8c420000 	lw	v0,0(v0)
9d00373c:	afc20018 	sw	v0,24(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    pData->nLastAddress = nAddress;
9d003740:	8fc20014 	lw	v0,20(s8)
9d003744:	8fc3002c 	lw	v1,44(s8)
9d003748:	ac430000 	sw	v1,0(v0)
#if defined(ENABLE_LOGGING) 
    pLogicData->pLogFunc("lSetProgrammerAddress - Setting Programmer Address to 0x%X.  (Thread: 0x%p)\n",
		                 nAddress, MCurrentThreadId());
#endif

    if ((nLastAddress & 0x0F) != (nAddress & 0x0F))
9d00374c:	8fc30018 	lw	v1,24(s8)
9d003750:	8fc2002c 	lw	v0,44(s8)
9d003754:	00621026 	xor	v0,v1,v0
9d003758:	3042000f 	andi	v0,v0,0xf
9d00375c:	1040000d 	beqz	v0,9d003794 <USBCtrlEPAllowDataStage+0x24c4>
9d003760:	00000000 	nop
#if defined(ENABLE_LOGGING) 
        pLogicData->pLogFunc("lSetProgrammerAddress - Setting Address lines 0 - 3.  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif

        if (!lWritePortData(pLogicData, (UINT8)nAddress, CUnit2_AddressLines0To3))
9d003764:	8fc2002c 	lw	v0,44(s8)
9d003768:	304200ff 	andi	v0,v0,0xff
9d00376c:	8fc40028 	lw	a0,40(s8)
9d003770:	00402821 	move	a1,v0
9d003774:	24060002 	li	a2,2
9d003778:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d00377c:	00000000 	nop
9d003780:	14400004 	bnez	v0,9d003794 <USBCtrlEPAllowDataStage+0x24c4>
9d003784:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lSetProgrammerAddress leaving.  (Write port data failed)  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            return FALSE;
9d003788:	00001021 	move	v0,zero
9d00378c:	0b400e88 	j	9d003a20 <USBCtrlEPAllowDataStage+0x2750>
9d003790:	00000000 	nop
        }
    }

    nLastAddress >>= 4;
9d003794:	8fc20018 	lw	v0,24(s8)
9d003798:	00021102 	srl	v0,v0,0x4
9d00379c:	afc20018 	sw	v0,24(s8)
    nAddress >>= 4;
9d0037a0:	8fc2002c 	lw	v0,44(s8)
9d0037a4:	00021102 	srl	v0,v0,0x4
9d0037a8:	afc2002c 	sw	v0,44(s8)

    if ((nLastAddress & 0x0F) != (nAddress & 0x0F))
9d0037ac:	8fc30018 	lw	v1,24(s8)
9d0037b0:	8fc2002c 	lw	v0,44(s8)
9d0037b4:	00621026 	xor	v0,v1,v0
9d0037b8:	3042000f 	andi	v0,v0,0xf
9d0037bc:	1040000d 	beqz	v0,9d0037f4 <USBCtrlEPAllowDataStage+0x2524>
9d0037c0:	00000000 	nop
#if defined(ENABLE_LOGGING) 
        pLogicData->pLogFunc("lSetProgrammerAddress - Setting Address lines 4 - 7.  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif

        if (!lWritePortData(pLogicData, (UINT8)nAddress, CUnit3_AddressLines4To7))
9d0037c4:	8fc2002c 	lw	v0,44(s8)
9d0037c8:	304200ff 	andi	v0,v0,0xff
9d0037cc:	8fc40028 	lw	a0,40(s8)
9d0037d0:	00402821 	move	a1,v0
9d0037d4:	24060003 	li	a2,3
9d0037d8:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d0037dc:	00000000 	nop
9d0037e0:	14400004 	bnez	v0,9d0037f4 <USBCtrlEPAllowDataStage+0x2524>
9d0037e4:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lSetProgrammerAddress leaving.  (Write port data failed)  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            return FALSE;
9d0037e8:	00001021 	move	v0,zero
9d0037ec:	0b400e88 	j	9d003a20 <USBCtrlEPAllowDataStage+0x2750>
9d0037f0:	00000000 	nop
        }
    }

    nLastAddress >>= 4;
9d0037f4:	8fc20018 	lw	v0,24(s8)
9d0037f8:	00021102 	srl	v0,v0,0x4
9d0037fc:	afc20018 	sw	v0,24(s8)
    nAddress >>= 4;
9d003800:	8fc2002c 	lw	v0,44(s8)
9d003804:	00021102 	srl	v0,v0,0x4
9d003808:	afc2002c 	sw	v0,44(s8)

    if ((nLastAddress & 0x0F) != (nAddress & 0x0F))
9d00380c:	8fc30018 	lw	v1,24(s8)
9d003810:	8fc2002c 	lw	v0,44(s8)
9d003814:	00621026 	xor	v0,v1,v0
9d003818:	3042000f 	andi	v0,v0,0xf
9d00381c:	1040000d 	beqz	v0,9d003854 <USBCtrlEPAllowDataStage+0x2584>
9d003820:	00000000 	nop
#if defined(ENABLE_LOGGING) 
        pLogicData->pLogFunc("lSetProgrammerAddress - Setting Address lines 8 - 11.  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif

        if (!lWritePortData(pLogicData, (UINT8)nAddress, CUnit4_AddressLines8To11))
9d003824:	8fc2002c 	lw	v0,44(s8)
9d003828:	304200ff 	andi	v0,v0,0xff
9d00382c:	8fc40028 	lw	a0,40(s8)
9d003830:	00402821 	move	a1,v0
9d003834:	24060004 	li	a2,4
9d003838:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d00383c:	00000000 	nop
9d003840:	14400004 	bnez	v0,9d003854 <USBCtrlEPAllowDataStage+0x2584>
9d003844:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lSetProgrammerAddress leaving.  (Write port data failed)  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            return FALSE;
9d003848:	00001021 	move	v0,zero
9d00384c:	0b400e88 	j	9d003a20 <USBCtrlEPAllowDataStage+0x2750>
9d003850:	00000000 	nop
        }
    }

    nLastAddress >>= 4;
9d003854:	8fc20018 	lw	v0,24(s8)
9d003858:	00021102 	srl	v0,v0,0x4
9d00385c:	afc20018 	sw	v0,24(s8)
    nAddress >>= 4;
9d003860:	8fc2002c 	lw	v0,44(s8)
9d003864:	00021102 	srl	v0,v0,0x4
9d003868:	afc2002c 	sw	v0,44(s8)

    if (nLastAddress != nAddress)
9d00386c:	8fc30018 	lw	v1,24(s8)
9d003870:	8fc2002c 	lw	v0,44(s8)
9d003874:	10620069 	beq	v1,v0,9d003a1c <USBCtrlEPAllowDataStage+0x274c>
9d003878:	00000000 	nop
    {
        nAddress = MSwapByte(nAddress);
9d00387c:	8fc2002c 	lw	v0,44(s8)
9d003880:	30420080 	andi	v0,v0,0x80
9d003884:	000211c2 	srl	v0,v0,0x7
9d003888:	304300ff 	andi	v1,v0,0xff
9d00388c:	8fc2002c 	lw	v0,44(s8)
9d003890:	30420040 	andi	v0,v0,0x40
9d003894:	00021142 	srl	v0,v0,0x5
9d003898:	304200ff 	andi	v0,v0,0xff
9d00389c:	00621025 	or	v0,v1,v0
9d0038a0:	304300ff 	andi	v1,v0,0xff
9d0038a4:	8fc2002c 	lw	v0,44(s8)
9d0038a8:	30420020 	andi	v0,v0,0x20
9d0038ac:	000210c2 	srl	v0,v0,0x3
9d0038b0:	304200ff 	andi	v0,v0,0xff
9d0038b4:	00621025 	or	v0,v1,v0
9d0038b8:	304300ff 	andi	v1,v0,0xff
9d0038bc:	8fc2002c 	lw	v0,44(s8)
9d0038c0:	30420010 	andi	v0,v0,0x10
9d0038c4:	00021042 	srl	v0,v0,0x1
9d0038c8:	304200ff 	andi	v0,v0,0xff
9d0038cc:	00621025 	or	v0,v1,v0
9d0038d0:	304300ff 	andi	v1,v0,0xff
9d0038d4:	8fc2002c 	lw	v0,44(s8)
9d0038d8:	304200ff 	andi	v0,v0,0xff
9d0038dc:	30420008 	andi	v0,v0,0x8
9d0038e0:	304200ff 	andi	v0,v0,0xff
9d0038e4:	00021040 	sll	v0,v0,0x1
9d0038e8:	304200ff 	andi	v0,v0,0xff
9d0038ec:	00621025 	or	v0,v1,v0
9d0038f0:	304300ff 	andi	v1,v0,0xff
9d0038f4:	8fc2002c 	lw	v0,44(s8)
9d0038f8:	304200ff 	andi	v0,v0,0xff
9d0038fc:	30420004 	andi	v0,v0,0x4
9d003900:	304200ff 	andi	v0,v0,0xff
9d003904:	000210c0 	sll	v0,v0,0x3
9d003908:	304200ff 	andi	v0,v0,0xff
9d00390c:	00621025 	or	v0,v1,v0
9d003910:	304300ff 	andi	v1,v0,0xff
9d003914:	8fc2002c 	lw	v0,44(s8)
9d003918:	304200ff 	andi	v0,v0,0xff
9d00391c:	30420002 	andi	v0,v0,0x2
9d003920:	304200ff 	andi	v0,v0,0xff
9d003924:	00021140 	sll	v0,v0,0x5
9d003928:	304200ff 	andi	v0,v0,0xff
9d00392c:	00621025 	or	v0,v1,v0
9d003930:	304300ff 	andi	v1,v0,0xff
9d003934:	8fc2002c 	lw	v0,44(s8)
9d003938:	304200ff 	andi	v0,v0,0xff
9d00393c:	000211c0 	sll	v0,v0,0x7
9d003940:	304200ff 	andi	v0,v0,0xff
9d003944:	00621025 	or	v0,v1,v0
9d003948:	304200ff 	andi	v0,v0,0xff
9d00394c:	afc2002c 	sw	v0,44(s8)
        nData = lVppModeToData(pLogicData, pData->Modes.nVppMode);
9d003950:	8fc20014 	lw	v0,20(s8)
9d003954:	8c420014 	lw	v0,20(v0)
9d003958:	8fc40028 	lw	a0,40(s8)
9d00395c:	00402821 	move	a1,v0
9d003960:	0f400edc 	jal	9d003b70 <USBCtrlEPAllowDataStage+0x28a0>
9d003964:	00000000 	nop
9d003968:	a3c2001c 	sb	v0,28(s8)

	    for (nIndex = 0; nIndex < 8; ++nIndex)
9d00396c:	afc00010 	sw	zero,16(s8)
9d003970:	0b400e83 	j	9d003a0c <USBCtrlEPAllowDataStage+0x273c>
9d003974:	00000000 	nop
	    {
		    nEnable = (nAddress & 1) ? CAddressLines12To19On : CAddressLines12To19Off;
9d003978:	8fc2002c 	lw	v0,44(s8)
9d00397c:	304200ff 	andi	v0,v0,0xff
9d003980:	30420001 	andi	v0,v0,0x1
9d003984:	a3c2001d 	sb	v0,29(s8)
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("lSetProgrammerAddress - Setting Address line %d.  (Thread: 0x%p)\n",
				                 nIndex + 12, MCurrentThreadId());
#endif

            if (!lWritePortData(pLogicData,
9d003988:	93c3001d 	lbu	v1,29(s8)
9d00398c:	93c2001c 	lbu	v0,28(s8)
9d003990:	00621025 	or	v0,v1,v0
9d003994:	304200ff 	andi	v0,v0,0xff
9d003998:	8fc40028 	lw	a0,40(s8)
9d00399c:	00402821 	move	a1,v0
9d0039a0:	24060005 	li	a2,5
9d0039a4:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d0039a8:	00000000 	nop
9d0039ac:	1040000e 	beqz	v0,9d0039e8 <USBCtrlEPAllowDataStage+0x2718>
9d0039b0:	00000000 	nop
                                CDisableAddressLines12To19Unit | nEnable | nData,
                                CUnit5_AddressLines12To19AndVppMode) ||
                !lWritePortData(pLogicData,
9d0039b4:	93c3001d 	lbu	v1,29(s8)
9d0039b8:	93c2001c 	lbu	v0,28(s8)
9d0039bc:	00621025 	or	v0,v1,v0
9d0039c0:	304200ff 	andi	v0,v0,0xff
9d0039c4:	34420002 	ori	v0,v0,0x2
9d0039c8:	304200ff 	andi	v0,v0,0xff
9d0039cc:	8fc40028 	lw	a0,40(s8)
9d0039d0:	00402821 	move	a1,v0
9d0039d4:	24060005 	li	a2,5
9d0039d8:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d0039dc:	00000000 	nop
				                 nIndex + 12, MCurrentThreadId());
#endif

            if (!lWritePortData(pLogicData,
                                CDisableAddressLines12To19Unit | nEnable | nData,
                                CUnit5_AddressLines12To19AndVppMode) ||
9d0039e0:	14400004 	bnez	v0,9d0039f4 <USBCtrlEPAllowDataStage+0x2724>
9d0039e4:	00000000 	nop
#if defined(ENABLE_LOGGING) 
				pLogicData->pLogFunc("lSetProgrammerAddress leaving.  (Write port data failed)  (Thread: 0x%p)\n",
					                 MCurrentThreadId());
#endif

                return FALSE;
9d0039e8:	00001021 	move	v0,zero
9d0039ec:	0b400e88 	j	9d003a20 <USBCtrlEPAllowDataStage+0x2750>
9d0039f0:	00000000 	nop
            }

            nAddress >>= 1;
9d0039f4:	8fc2002c 	lw	v0,44(s8)
9d0039f8:	00021042 	srl	v0,v0,0x1
9d0039fc:	afc2002c 	sw	v0,44(s8)
    if (nLastAddress != nAddress)
    {
        nAddress = MSwapByte(nAddress);
        nData = lVppModeToData(pLogicData, pData->Modes.nVppMode);

	    for (nIndex = 0; nIndex < 8; ++nIndex)
9d003a00:	8fc20010 	lw	v0,16(s8)
9d003a04:	24420001 	addiu	v0,v0,1
9d003a08:	afc20010 	sw	v0,16(s8)
9d003a0c:	8fc20010 	lw	v0,16(s8)
9d003a10:	2c420008 	sltiu	v0,v0,8
9d003a14:	1440ffd8 	bnez	v0,9d003978 <USBCtrlEPAllowDataStage+0x26a8>
9d003a18:	00000000 	nop
#if defined(ENABLE_LOGGING) 
    pLogicData->pLogFunc("lSetProgrammerAddress leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

    return TRUE;
9d003a1c:	24020001 	li	v0,1
}
9d003a20:	03c0e821 	move	sp,s8
9d003a24:	8fbf0024 	lw	ra,36(sp)
9d003a28:	8fbe0020 	lw	s8,32(sp)
9d003a2c:	27bd0028 	addiu	sp,sp,40
9d003a30:	03e00008 	jr	ra
9d003a34:	00000000 	nop

_IRQL_requires_max_(PASSIVE_LEVEL)
static BOOLEAN lSetProgrammerVppMode(
  _In_ TUtPepLogicData* pLogicData)
{
9d003a38:	27bdffe0 	addiu	sp,sp,-32
9d003a3c:	afbf001c 	sw	ra,28(sp)
9d003a40:	afbe0018 	sw	s8,24(sp)
9d003a44:	03a0f021 	move	s8,sp
9d003a48:	afc40020 	sw	a0,32(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d003a4c:	8fc20020 	lw	v0,32(s8)
9d003a50:	8c420008 	lw	v0,8(v0)
9d003a54:	afc20010 	sw	v0,16(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    nData = lVppModeToData(pLogicData, pData->Modes.nVppMode);
9d003a58:	8fc20010 	lw	v0,16(s8)
9d003a5c:	8c420014 	lw	v0,20(v0)
9d003a60:	8fc40020 	lw	a0,32(s8)
9d003a64:	00402821 	move	a1,v0
9d003a68:	0f400edc 	jal	9d003b70 <USBCtrlEPAllowDataStage+0x28a0>
9d003a6c:	00000000 	nop
9d003a70:	a3c20014 	sb	v0,20(s8)

	bResult = lWritePortData(pLogicData, CDisableAddressLines12To19Unit | nData,
9d003a74:	93c20014 	lbu	v0,20(s8)
9d003a78:	8fc40020 	lw	a0,32(s8)
9d003a7c:	00402821 	move	a1,v0
9d003a80:	24060005 	li	a2,5
9d003a84:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d003a88:	00000000 	nop
9d003a8c:	a3c20015 	sb	v0,21(s8)
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("lSetProgrammerVppMode leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

	return bResult;
9d003a90:	93c20015 	lbu	v0,21(s8)
}
9d003a94:	03c0e821 	move	sp,s8
9d003a98:	8fbf001c 	lw	ra,28(sp)
9d003a9c:	8fbe0018 	lw	s8,24(sp)
9d003aa0:	27bd0020 	addiu	sp,sp,32
9d003aa4:	03e00008 	jr	ra
9d003aa8:	00000000 	nop

_IRQL_requires_max_(PASSIVE_LEVEL)
static UINT8 lPinPulseModeToData(
  _In_ TUtPepLogicData* pLogicData,
  _In_ UINT32 nPinPulseMode)
{
9d003aac:	27bdfff0 	addiu	sp,sp,-16
9d003ab0:	afbe000c 	sw	s8,12(sp)
9d003ab4:	03a0f021 	move	s8,sp
9d003ab8:	afc40010 	sw	a0,16(s8)
9d003abc:	afc50014 	sw	a1,20(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    switch (nPinPulseMode)
9d003ac0:	8fc20014 	lw	v0,20(s8)
9d003ac4:	24030002 	li	v1,2
9d003ac8:	10430014 	beq	v0,v1,9d003b1c <USBCtrlEPAllowDataStage+0x284c>
9d003acc:	00000000 	nop
9d003ad0:	2c430003 	sltiu	v1,v0,3
9d003ad4:	10600006 	beqz	v1,9d003af0 <USBCtrlEPAllowDataStage+0x2820>
9d003ad8:	00000000 	nop
9d003adc:	24030001 	li	v1,1
9d003ae0:	1043000b 	beq	v0,v1,9d003b10 <USBCtrlEPAllowDataStage+0x2840>
9d003ae4:	00000000 	nop
9d003ae8:	0b400ed3 	j	9d003b4c <USBCtrlEPAllowDataStage+0x287c>
9d003aec:	00000000 	nop
9d003af0:	24030003 	li	v1,3
9d003af4:	1043000d 	beq	v0,v1,9d003b2c <USBCtrlEPAllowDataStage+0x285c>
9d003af8:	00000000 	nop
9d003afc:	24030004 	li	v1,4
9d003b00:	1043000e 	beq	v0,v1,9d003b3c <USBCtrlEPAllowDataStage+0x286c>
9d003b04:	00000000 	nop
9d003b08:	0b400ed3 	j	9d003b4c <USBCtrlEPAllowDataStage+0x287c>
9d003b0c:	00000000 	nop
    {
        case CUtPepLogicPinPulse1Mode:
            nData = 0;
9d003b10:	a3c00000 	sb	zero,0(s8)
			break;
9d003b14:	0b400ed6 	j	9d003b58 <USBCtrlEPAllowDataStage+0x2888>
9d003b18:	00000000 	nop
        case CUtPepLogicPinPulse2Mode:
            nData = CN0;
9d003b1c:	24020001 	li	v0,1
9d003b20:	a3c20000 	sb	v0,0(s8)
			break;
9d003b24:	0b400ed6 	j	9d003b58 <USBCtrlEPAllowDataStage+0x2888>
9d003b28:	00000000 	nop
        case CUtPepLogicPinPulse3Mode:
            nData = CN1;
9d003b2c:	24020002 	li	v0,2
9d003b30:	a3c20000 	sb	v0,0(s8)
			break;
9d003b34:	0b400ed6 	j	9d003b58 <USBCtrlEPAllowDataStage+0x2888>
9d003b38:	00000000 	nop
        case CUtPepLogicPinPulse4Mode:
			nData = CN0 | CN1;
9d003b3c:	24020003 	li	v0,3
9d003b40:	a3c20000 	sb	v0,0(s8)
			break;
9d003b44:	0b400ed6 	j	9d003b58 <USBCtrlEPAllowDataStage+0x2888>
9d003b48:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lPinPulseModeToData - Unknown pin pulse mode: 0x%X.  (Thread: 0x%p)\n",
				                 nPinPulseMode, MCurrentThreadId());
#endif

			nData = CN0 | CN1;
9d003b4c:	24020003 	li	v0,3
9d003b50:	a3c20000 	sb	v0,0(s8)
			break;
9d003b54:	00000000 	nop
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("lPinPulseModeToData leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

	return nData;
9d003b58:	93c20000 	lbu	v0,0(s8)
}
9d003b5c:	03c0e821 	move	sp,s8
9d003b60:	8fbe000c 	lw	s8,12(sp)
9d003b64:	27bd0010 	addiu	sp,sp,16
9d003b68:	03e00008 	jr	ra
9d003b6c:	00000000 	nop

_IRQL_requires_max_(PASSIVE_LEVEL)
static UINT8 lVppModeToData(
  _In_ TUtPepLogicData* pLogicData,
  _In_ UINT32 nVppMode)
{
9d003b70:	27bdfff0 	addiu	sp,sp,-16
9d003b74:	afbe000c 	sw	s8,12(sp)
9d003b78:	03a0f021 	move	s8,sp
9d003b7c:	afc40010 	sw	a0,16(s8)
9d003b80:	afc50014 	sw	a1,20(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    switch (nVppMode)
9d003b84:	8fc20014 	lw	v0,20(s8)
9d003b88:	24030002 	li	v1,2
9d003b8c:	1043000b 	beq	v0,v1,9d003bbc <USBCtrlEPAllowDataStage+0x28ec>
9d003b90:	00000000 	nop
9d003b94:	24030004 	li	v1,4
9d003b98:	1043000c 	beq	v0,v1,9d003bcc <USBCtrlEPAllowDataStage+0x28fc>
9d003b9c:	00000000 	nop
9d003ba0:	24030001 	li	v1,1
9d003ba4:	1443000c 	bne	v0,v1,9d003bd8 <USBCtrlEPAllowDataStage+0x2908>
9d003ba8:	00000000 	nop
    {
        case CUtPepLogic12VDCVppMode:
            nData = CEnable12Vpp;
9d003bac:	24020004 	li	v0,4
9d003bb0:	a3c20000 	sb	v0,0(s8)
			break;
9d003bb4:	0b400ef9 	j	9d003be4 <USBCtrlEPAllowDataStage+0x2914>
9d003bb8:	00000000 	nop
        case CUtPepLogic21VDCVppMode:
            nData = CEnable21Vpp;
9d003bbc:	24020008 	li	v0,8
9d003bc0:	a3c20000 	sb	v0,0(s8)
			break;
9d003bc4:	0b400ef9 	j	9d003be4 <USBCtrlEPAllowDataStage+0x2914>
9d003bc8:	00000000 	nop
        case CUtPepLogic25VDCVppMode:
            nData = CEnable25Vpp;
9d003bcc:	a3c00000 	sb	zero,0(s8)
			break;
9d003bd0:	0b400ef9 	j	9d003be4 <USBCtrlEPAllowDataStage+0x2914>
9d003bd4:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lVppModeToData - Unknown Vpp mode: 0x%X.  (Thread: 0x%p)\n",
				                 nVppMode, MCurrentThreadId());
#endif

			nData = CUtPepLogic12VDCVppMode;
9d003bd8:	24020001 	li	v0,1
9d003bdc:	a3c20000 	sb	v0,0(s8)
			break;
9d003be0:	00000000 	nop
#if defined(ENABLE_LOGGING) 
    pLogicData->pLogFunc("lVppModeToData leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

    return nData;
9d003be4:	93c20000 	lbu	v0,0(s8)
}
9d003be8:	03c0e821 	move	sp,s8
9d003bec:	8fbe000c 	lw	s8,12(sp)
9d003bf0:	27bd0010 	addiu	sp,sp,16
9d003bf4:	03e00008 	jr	ra
9d003bf8:	00000000 	nop

_IRQL_requires_max_(PASSIVE_LEVEL)
static BOOLEAN lResetProgrammerState(
  _In_ TUtPepLogicData* pLogicData)
{
9d003bfc:	27bdffe0 	addiu	sp,sp,-32
9d003c00:	afbf001c 	sw	ra,28(sp)
9d003c04:	afbe0018 	sw	s8,24(sp)
9d003c08:	03a0f021 	move	s8,sp
9d003c0c:	afc40020 	sw	a0,32(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d003c10:	8fc20020 	lw	v0,32(s8)
9d003c14:	8c420008 	lw	v0,8(v0)
9d003c18:	afc20010 	sw	v0,16(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    if (lWritePortData(pLogicData,
9d003c1c:	8fc40020 	lw	a0,32(s8)
9d003c20:	24050002 	li	a1,2
9d003c24:	24060007 	li	a2,7
9d003c28:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d003c2c:	00000000 	nop
9d003c30:	10400011 	beqz	v0,9d003c78 <USBCtrlEPAllowDataStage+0x29a8>
9d003c34:	00000000 	nop
                       MEnableTriggerProgramPulse(FALSE) |
                           MEnableResetProgramPulse(TRUE) |
                           MSelectVccMode(CUtPepLogic5VDCMode) |
                           MEnableVpp(FALSE),
                       CUnit7_Programmer) &&
        lWritePortData(pLogicData, lPinPulseModeToData(pLogicData, pData->Modes.nPinPulseMode),
9d003c38:	8fc20010 	lw	v0,16(s8)
9d003c3c:	8c420010 	lw	v0,16(v0)
9d003c40:	8fc40020 	lw	a0,32(s8)
9d003c44:	00402821 	move	a1,v0
9d003c48:	0f400eab 	jal	9d003aac <USBCtrlEPAllowDataStage+0x27dc>
9d003c4c:	00000000 	nop
9d003c50:	8fc40020 	lw	a0,32(s8)
9d003c54:	00402821 	move	a1,v0
9d003c58:	24060006 	li	a2,6
9d003c5c:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d003c60:	00000000 	nop
    if (lWritePortData(pLogicData,
                       MEnableTriggerProgramPulse(FALSE) |
                           MEnableResetProgramPulse(TRUE) |
                           MSelectVccMode(CUtPepLogic5VDCMode) |
                           MEnableVpp(FALSE),
                       CUnit7_Programmer) &&
9d003c64:	10400004 	beqz	v0,9d003c78 <USBCtrlEPAllowDataStage+0x29a8>
9d003c68:	00000000 	nop
#if defined(ENABLE_LOGGING) 
		pLogicData->pLogFunc("lResetProgrammerState leaving.  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif

		return TRUE;
9d003c6c:	24020001 	li	v0,1
9d003c70:	0b400f1f 	j	9d003c7c <USBCtrlEPAllowDataStage+0x29ac>
9d003c74:	00000000 	nop
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("lResetProgrammerState leaving.  (Write failed)  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

    return FALSE;
9d003c78:	00001021 	move	v0,zero
}
9d003c7c:	03c0e821 	move	sp,s8
9d003c80:	8fbf001c 	lw	ra,28(sp)
9d003c84:	8fbe0018 	lw	s8,24(sp)
9d003c88:	27bd0020 	addiu	sp,sp,32
9d003c8c:	03e00008 	jr	ra
9d003c90:	00000000 	nop

_IRQL_requires_max_(PASSIVE_LEVEL)
static BOOLEAN lEnableProgrammerReadMode(
  _In_ TUtPepLogicData* pLogicData)
{
9d003c94:	27bdffe0 	addiu	sp,sp,-32
9d003c98:	afbf001c 	sw	ra,28(sp)
9d003c9c:	afbe0018 	sw	s8,24(sp)
9d003ca0:	03a0f021 	move	s8,sp
9d003ca4:	afc40020 	sw	a0,32(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d003ca8:	8fc20020 	lw	v0,32(s8)
9d003cac:	8c420008 	lw	v0,8(v0)
9d003cb0:	afc20010 	sw	v0,16(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    if (lWritePortData(pLogicData, lPinPulseModeToData(pLogicData, pData->Modes.nPinPulseMode) | CN2,
9d003cb4:	8fc20010 	lw	v0,16(s8)
9d003cb8:	8c420010 	lw	v0,16(v0)
9d003cbc:	8fc40020 	lw	a0,32(s8)
9d003cc0:	00402821 	move	a1,v0
9d003cc4:	0f400eab 	jal	9d003aac <USBCtrlEPAllowDataStage+0x27dc>
9d003cc8:	00000000 	nop
9d003ccc:	34420004 	ori	v0,v0,0x4
9d003cd0:	304200ff 	andi	v0,v0,0xff
9d003cd4:	8fc40020 	lw	a0,32(s8)
9d003cd8:	00402821 	move	a1,v0
9d003cdc:	24060006 	li	a2,6
9d003ce0:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d003ce4:	00000000 	nop
9d003ce8:	1040001d 	beqz	v0,9d003d60 <USBCtrlEPAllowDataStage+0x2a90>
9d003cec:	00000000 	nop
                       CUnit6_LedAndVpp) &&
        lWritePortData(pLogicData,
                       MEnableResetProgramPulse(TRUE) |
                           MSelectVccMode(pData->Modes.nVccMode) |
9d003cf0:	8fc20010 	lw	v0,16(s8)
9d003cf4:	8c43000c 	lw	v1,12(v0)
    PAGED_CODE()
#endif

    if (lWritePortData(pLogicData, lPinPulseModeToData(pLogicData, pData->Modes.nPinPulseMode) | CN2,
                       CUnit6_LedAndVpp) &&
        lWritePortData(pLogicData,
9d003cf8:	24020001 	li	v0,1
9d003cfc:	14620004 	bne	v1,v0,9d003d10 <USBCtrlEPAllowDataStage+0x2a40>
9d003d00:	00000000 	nop
9d003d04:	24020002 	li	v0,2
9d003d08:	0b400f45 	j	9d003d14 <USBCtrlEPAllowDataStage+0x2a44>
9d003d0c:	00000000 	nop
9d003d10:	2402000a 	li	v0,10
9d003d14:	8fc40020 	lw	a0,32(s8)
9d003d18:	00402821 	move	a1,v0
9d003d1c:	24060007 	li	a2,7
9d003d20:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d003d24:	00000000 	nop
#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    if (lWritePortData(pLogicData, lPinPulseModeToData(pLogicData, pData->Modes.nPinPulseMode) | CN2,
                       CUnit6_LedAndVpp) &&
9d003d28:	1040000d 	beqz	v0,9d003d60 <USBCtrlEPAllowDataStage+0x2a90>
9d003d2c:	00000000 	nop
                       MEnableResetProgramPulse(TRUE) |
                           MSelectVccMode(pData->Modes.nVccMode) |
                           MEnableVpp(FALSE),
                       CUnit7_Programmer))
    {
		if (pData->DelaySettings.nChipEnableNanoSeconds > 0)
9d003d30:	8fc20010 	lw	v0,16(s8)
9d003d34:	8c420018 	lw	v0,24(v0)
9d003d38:	10400006 	beqz	v0,9d003d54 <USBCtrlEPAllowDataStage+0x2a84>
9d003d3c:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lEnableProgrammerReadMode - Chip Enable delay detected.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

			if (!UtSleep(pData->DelaySettings.nChipEnableNanoSeconds))
9d003d40:	8fc20010 	lw	v0,16(s8)
9d003d44:	8c420018 	lw	v0,24(v0)
9d003d48:	00402021 	move	a0,v0
9d003d4c:	0f401c68 	jal	9d0071a0 <UtSleep>
9d003d50:	00000000 	nop
#if defined(ENABLE_LOGGING) 
		pLogicData->pLogFunc("lEnableProgrammerReadMode leaving.  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif

        return TRUE;
9d003d54:	24020001 	li	v0,1
9d003d58:	0b400f59 	j	9d003d64 <USBCtrlEPAllowDataStage+0x2a94>
9d003d5c:	00000000 	nop
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("lEnableProgrammerReadMode leaving.  (Write port data failed)  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

    return FALSE;
9d003d60:	00001021 	move	v0,zero
}
9d003d64:	03c0e821 	move	sp,s8
9d003d68:	8fbf001c 	lw	ra,28(sp)
9d003d6c:	8fbe0018 	lw	s8,24(sp)
9d003d70:	27bd0020 	addiu	sp,sp,32
9d003d74:	03e00008 	jr	ra
9d003d78:	00000000 	nop

_IRQL_requires_max_(PASSIVE_LEVEL)
static BOOLEAN lEnableProgrammerWriteMode(
  _In_ TUtPepLogicData* pLogicData)
{
9d003d7c:	27bdffe0 	addiu	sp,sp,-32
9d003d80:	afbf001c 	sw	ra,28(sp)
9d003d84:	afbe0018 	sw	s8,24(sp)
9d003d88:	03a0f021 	move	s8,sp
9d003d8c:	afc40020 	sw	a0,32(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d003d90:	8fc20020 	lw	v0,32(s8)
9d003d94:	8c420008 	lw	v0,8(v0)
9d003d98:	afc20010 	sw	v0,16(s8)
#endif

    if (lWritePortData(pLogicData,
                       MEnableTriggerProgramPulse(FALSE) |
                           MEnableResetProgramPulse(TRUE) |
                           MSelectVccMode(pData->Modes.nVccMode) |
9d003d9c:	8fc20010 	lw	v0,16(s8)
9d003da0:	8c43000c 	lw	v1,12(v0)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    if (lWritePortData(pLogicData,
9d003da4:	24020001 	li	v0,1
9d003da8:	14620004 	bne	v1,v0,9d003dbc <USBCtrlEPAllowDataStage+0x2aec>
9d003dac:	00000000 	nop
9d003db0:	24020006 	li	v0,6
9d003db4:	0b400f70 	j	9d003dc0 <USBCtrlEPAllowDataStage+0x2af0>
9d003db8:	00000000 	nop
9d003dbc:	2402000e 	li	v0,14
9d003dc0:	8fc40020 	lw	a0,32(s8)
9d003dc4:	00402821 	move	a1,v0
9d003dc8:	24060007 	li	a2,7
9d003dcc:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d003dd0:	00000000 	nop
9d003dd4:	1040001c 	beqz	v0,9d003e48 <USBCtrlEPAllowDataStage+0x2b78>
9d003dd8:	00000000 	nop
                           MEnableResetProgramPulse(TRUE) |
                           MSelectVccMode(pData->Modes.nVccMode) |
                           MEnableVpp(TRUE),
                       CUnit7_Programmer) &&
        lWritePortData(pLogicData,
                       lPinPulseModeToData(pLogicData, pData->Modes.nPinPulseMode) | CN2 | CN3,
9d003ddc:	8fc20010 	lw	v0,16(s8)
9d003de0:	8c420010 	lw	v0,16(v0)
9d003de4:	8fc40020 	lw	a0,32(s8)
9d003de8:	00402821 	move	a1,v0
9d003dec:	0f400eab 	jal	9d003aac <USBCtrlEPAllowDataStage+0x27dc>
9d003df0:	00000000 	nop
                       MEnableTriggerProgramPulse(FALSE) |
                           MEnableResetProgramPulse(TRUE) |
                           MSelectVccMode(pData->Modes.nVccMode) |
                           MEnableVpp(TRUE),
                       CUnit7_Programmer) &&
        lWritePortData(pLogicData,
9d003df4:	3442000c 	ori	v0,v0,0xc
9d003df8:	304200ff 	andi	v0,v0,0xff
9d003dfc:	8fc40020 	lw	a0,32(s8)
9d003e00:	00402821 	move	a1,v0
9d003e04:	24060006 	li	a2,6
9d003e08:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d003e0c:	00000000 	nop
    if (lWritePortData(pLogicData,
                       MEnableTriggerProgramPulse(FALSE) |
                           MEnableResetProgramPulse(TRUE) |
                           MSelectVccMode(pData->Modes.nVccMode) |
                           MEnableVpp(TRUE),
                       CUnit7_Programmer) &&
9d003e10:	1040000d 	beqz	v0,9d003e48 <USBCtrlEPAllowDataStage+0x2b78>
9d003e14:	00000000 	nop
        lWritePortData(pLogicData,
                       lPinPulseModeToData(pLogicData, pData->Modes.nPinPulseMode) | CN2 | CN3,
                       CUnit6_LedAndVpp))
    {
		if (pData->DelaySettings.nChipEnableNanoSeconds > 0)
9d003e18:	8fc20010 	lw	v0,16(s8)
9d003e1c:	8c420018 	lw	v0,24(v0)
9d003e20:	10400006 	beqz	v0,9d003e3c <USBCtrlEPAllowDataStage+0x2b6c>
9d003e24:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lEnableProgrammerWriteMode - Chip Enable delay detected.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

			if (!UtSleep(pData->DelaySettings.nChipEnableNanoSeconds))
9d003e28:	8fc20010 	lw	v0,16(s8)
9d003e2c:	8c420018 	lw	v0,24(v0)
9d003e30:	00402021 	move	a0,v0
9d003e34:	0f401c68 	jal	9d0071a0 <UtSleep>
9d003e38:	00000000 	nop
#if defined(ENABLE_LOGGING) 
		pLogicData->pLogFunc("lEnableProgrammerWriteMode leaving.  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif

		return TRUE;
9d003e3c:	24020001 	li	v0,1
9d003e40:	0b400f93 	j	9d003e4c <USBCtrlEPAllowDataStage+0x2b7c>
9d003e44:	00000000 	nop
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("lEnableProgrammerWriteMode leaving.  (Write port data failed)  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

    return FALSE;
9d003e48:	00001021 	move	v0,zero
}
9d003e4c:	03c0e821 	move	sp,s8
9d003e50:	8fbf001c 	lw	ra,28(sp)
9d003e54:	8fbe0018 	lw	s8,24(sp)
9d003e58:	27bd0020 	addiu	sp,sp,32
9d003e5c:	03e00008 	jr	ra
9d003e60:	00000000 	nop

_IRQL_requires_max_(PASSIVE_LEVEL)
static BOOLEAN lWaitForProgramPulse(
  _In_ TUtPepLogicData* pLogicData)
{
9d003e64:	27bdffd8 	addiu	sp,sp,-40
9d003e68:	afbf0024 	sw	ra,36(sp)
9d003e6c:	afbe0020 	sw	s8,32(sp)
9d003e70:	03a0f021 	move	s8,sp
9d003e74:	afc40028 	sw	a0,40(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d003e78:	8fc20028 	lw	v0,40(s8)
9d003e7c:	8c420008 	lw	v0,8(v0)
9d003e80:	afc20014 	sw	v0,20(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

	switch (pData->Modes.nPinPulseMode)
9d003e84:	8fc20014 	lw	v0,20(s8)
9d003e88:	8c420010 	lw	v0,16(v0)
9d003e8c:	24030001 	li	v1,1
9d003e90:	10430009 	beq	v0,v1,9d003eb8 <USBCtrlEPAllowDataStage+0x2be8>
9d003e94:	00000000 	nop
9d003e98:	2c430001 	sltiu	v1,v0,1
9d003e9c:	14600010 	bnez	v1,9d003ee0 <USBCtrlEPAllowDataStage+0x2c10>
9d003ea0:	00000000 	nop
9d003ea4:	2c420005 	sltiu	v0,v0,5
9d003ea8:	1040000d 	beqz	v0,9d003ee0 <USBCtrlEPAllowDataStage+0x2c10>
9d003eac:	00000000 	nop
9d003eb0:	0b400fb3 	j	9d003ecc <USBCtrlEPAllowDataStage+0x2bfc>
9d003eb4:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lWaitForProgramPulse - Using a 1.1 msecs pulse.  (Thread: 0x%p)\n",
                                 MCurrentThreadId());
#endif

			nIntervalNanoseconds = (UINT32)MMilliToNanoseconds(1.1); /* 1.1 msec */
9d003eb8:	3c020010 	lui	v0,0x10
9d003ebc:	3442c8e0 	ori	v0,v0,0xc8e0
9d003ec0:	afc20010 	sw	v0,16(s8)
			break;
9d003ec4:	0b400fbb 	j	9d003eec <USBCtrlEPAllowDataStage+0x2c1c>
9d003ec8:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lWaitForProgramPulse - Using a 250 us pulse.  (Thread: 0x%p)\n",
                                 MCurrentThreadId());
#endif

			nIntervalNanoseconds = (UINT32)MMicroToNanoseconds(250); /* 250 us */
9d003ecc:	3c020003 	lui	v0,0x3
9d003ed0:	3442d090 	ori	v0,v0,0xd090
9d003ed4:	afc20010 	sw	v0,16(s8)
			break;
9d003ed8:	0b400fbb 	j	9d003eec <USBCtrlEPAllowDataStage+0x2c1c>
9d003edc:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lWaitForProgramPulse leaving.  (Cannot determine sleep delay because of unknown pin pulse mode: 0x%X)  (Thread: 0x%p)\n",
				                 pData->Modes.nPinPulseMode, MCurrentThreadId());
#endif

			return FALSE;
9d003ee0:	00001021 	move	v0,zero
9d003ee4:	0b400ff3 	j	9d003fcc <USBCtrlEPAllowDataStage+0x2cfc>
9d003ee8:	00000000 	nop
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("lWaitForProgramPulse - Putting thread to sleep briefly.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

	if (!UtSleep(nIntervalNanoseconds))
9d003eec:	8fc40010 	lw	a0,16(s8)
9d003ef0:	0f401c68 	jal	9d0071a0 <UtSleep>
9d003ef4:	00000000 	nop
9d003ef8:	14400004 	bnez	v0,9d003f0c <USBCtrlEPAllowDataStage+0x2c3c>
9d003efc:	00000000 	nop
#if defined(ENABLE_LOGGING) 
		pLogicData->pLogFunc("lWaitForProgramPulse leaving.  (Sleep failed)  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif

		return FALSE;
9d003f00:	00001021 	move	v0,zero
9d003f04:	0b400ff3 	j	9d003fcc <USBCtrlEPAllowDataStage+0x2cfc>
9d003f08:	00000000 	nop
	}

    switch (pData->Modes.nPinPulseMode)
9d003f0c:	8fc20014 	lw	v0,20(s8)
9d003f10:	8c420010 	lw	v0,16(v0)
9d003f14:	24030001 	li	v1,1
9d003f18:	10430009 	beq	v0,v1,9d003f40 <USBCtrlEPAllowDataStage+0x2c70>
9d003f1c:	00000000 	nop
9d003f20:	2c430001 	sltiu	v1,v0,1
9d003f24:	1460000d 	bnez	v1,9d003f5c <USBCtrlEPAllowDataStage+0x2c8c>
9d003f28:	00000000 	nop
9d003f2c:	2c420005 	sltiu	v0,v0,5
9d003f30:	1040000a 	beqz	v0,9d003f5c <USBCtrlEPAllowDataStage+0x2c8c>
9d003f34:	00000000 	nop
9d003f38:	0b400fd4 	j	9d003f50 <USBCtrlEPAllowDataStage+0x2c80>
9d003f3c:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lWaitForProgramPulse - Preparing to read the PFIX value.  (Thread: 0x%p)\n",
                                 MCurrentThreadId());
#endif

            nData = MPortData(PFIX, CUnit_DontCare, CUnitOff);
9d003f40:	24020001 	li	v0,1
9d003f44:	a3c20018 	sb	v0,24(s8)
            break;
9d003f48:	0b400fda 	j	9d003f68 <USBCtrlEPAllowDataStage+0x2c98>
9d003f4c:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lWaitForProgramPulse - Preparing to read the PVAR value.  (Thread: 0x%p)\n",
                                 MCurrentThreadId());
#endif
			
			nData = MPortData(PVAR, CUnit_DontCare, CUnitOff);
9d003f50:	a3c00018 	sb	zero,24(s8)
            break;
9d003f54:	0b400fda 	j	9d003f68 <USBCtrlEPAllowDataStage+0x2c98>
9d003f58:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("lWaitForProgramPulse leaving.  (Cannot determine data to write because of unknown pin pulse mode: 0x%X)  (Thread: 0x%p)\n",
				                 pData->Modes.nPinPulseMode, MCurrentThreadId());
#endif

			return FALSE;
9d003f5c:	00001021 	move	v0,zero
9d003f60:	0b400ff3 	j	9d003fcc <USBCtrlEPAllowDataStage+0x2cfc>
9d003f64:	00000000 	nop
#if defined(ENABLE_LOGGING) 
    pLogicData->pLogFunc("lWaitForProgramPulse - Checking if program pulse finished.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

    if (pLogicData->pWritePortFunc(
9d003f68:	8fc20028 	lw	v0,40(s8)
9d003f6c:	8c420004 	lw	v0,4(v0)
9d003f70:	27c30018 	addiu	v1,s8,24
9d003f74:	00602021 	move	a0,v1
9d003f78:	24050001 	li	a1,1
9d003f7c:	2406000a 	li	a2,10
9d003f80:	0040f809 	jalr	v0
9d003f84:	00000000 	nop
9d003f88:	1040000f 	beqz	v0,9d003fc8 <USBCtrlEPAllowDataStage+0x2cf8>
9d003f8c:	00000000 	nop
#if defined(ENABLE_DEVICE_CONTEXT)
            pLogicData->pvDeviceContext,
#endif
            &nData, sizeof(nData), CWaitNanoSeconds) &&
        pLogicData->pReadBitPortFunc(
9d003f90:	8fc20028 	lw	v0,40(s8)
9d003f94:	8c420000 	lw	v0,0(v0)
9d003f98:	27c30019 	addiu	v1,s8,25
9d003f9c:	00602021 	move	a0,v1
9d003fa0:	0040f809 	jalr	v0
9d003fa4:	00000000 	nop

    if (pLogicData->pWritePortFunc(
#if defined(ENABLE_DEVICE_CONTEXT)
            pLogicData->pvDeviceContext,
#endif
            &nData, sizeof(nData), CWaitNanoSeconds) &&
9d003fa8:	10400007 	beqz	v0,9d003fc8 <USBCtrlEPAllowDataStage+0x2cf8>
9d003fac:	00000000 	nop
#if defined(ENABLE_DEVICE_CONTEXT)
            pLogicData->pvDeviceContext,
#endif
            &bValue))
    {
        if (!bValue)
9d003fb0:	93c20019 	lbu	v0,25(s8)
9d003fb4:	14400004 	bnez	v0,9d003fc8 <USBCtrlEPAllowDataStage+0x2cf8>
9d003fb8:	00000000 	nop
				                 MCurrentThreadId());
			pLogicData->pLogFunc("lWaitForProgramPulse leaving.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            return TRUE;
9d003fbc:	24020001 	li	v0,1
9d003fc0:	0b400ff3 	j	9d003fcc <USBCtrlEPAllowDataStage+0x2cfc>
9d003fc4:	00000000 	nop
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("lWaitForProgramPulse leaving.  (Failure occurred)  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

    return FALSE;
9d003fc8:	00001021 	move	v0,zero
}
9d003fcc:	03c0e821 	move	sp,s8
9d003fd0:	8fbf0024 	lw	ra,36(sp)
9d003fd4:	8fbe0020 	lw	s8,32(sp)
9d003fd8:	27bd0028 	addiu	sp,sp,40
9d003fdc:	03e00008 	jr	ra
9d003fe0:	00000000 	nop

_IRQL_requires_max_(PASSIVE_LEVEL)
static BOOLEAN lInitModes(
  _In_ TPepInternalLogicData* pInternalData)
{
9d003fe4:	27bdfff8 	addiu	sp,sp,-8
9d003fe8:	afbe0004 	sw	s8,4(sp)
9d003fec:	03a0f021 	move	s8,sp
9d003ff0:	afc40008 	sw	a0,8(s8)
#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    pInternalData->Modes.nProgrammerMode = CUtPepLogicProgrammerNoneMode;
9d003ff4:	8fc20008 	lw	v0,8(s8)
9d003ff8:	24030001 	li	v1,1
9d003ffc:	ac430008 	sw	v1,8(v0)
    pInternalData->Modes.nVccMode = CUtPepLogic5VDCMode;
9d004000:	8fc20008 	lw	v0,8(s8)
9d004004:	24030001 	li	v1,1
9d004008:	ac43000c 	sw	v1,12(v0)
    pInternalData->Modes.nPinPulseMode = CUtPepLogicPinPulse4Mode;
9d00400c:	8fc20008 	lw	v0,8(s8)
9d004010:	24030004 	li	v1,4
9d004014:	ac430010 	sw	v1,16(v0)
    pInternalData->Modes.nVppMode = CUtPepLogic25VDCVppMode;
9d004018:	8fc20008 	lw	v0,8(s8)
9d00401c:	24030004 	li	v1,4
9d004020:	ac430014 	sw	v1,20(v0)

    return TRUE;
9d004024:	24020001 	li	v0,1
}
9d004028:	03c0e821 	move	sp,s8
9d00402c:	8fbe0004 	lw	s8,4(sp)
9d004030:	27bd0008 	addiu	sp,sp,8
9d004034:	03e00008 	jr	ra
9d004038:	00000000 	nop

_IRQL_requires_max_(PASSIVE_LEVEL)
static BOOLEAN lInitDelaySettings(
  _In_ TPepInternalLogicData* pInternalData)
{
9d00403c:	27bdfff8 	addiu	sp,sp,-8
9d004040:	afbe0004 	sw	s8,4(sp)
9d004044:	03a0f021 	move	s8,sp
9d004048:	afc40008 	sw	a0,8(s8)
#if defined(BUILD_DRIVER_LIB)
	PAGED_CODE()
#endif

	pInternalData->DelaySettings.nChipEnableNanoSeconds = 0;
9d00404c:	8fc20008 	lw	v0,8(s8)
9d004050:	ac400018 	sw	zero,24(v0)
	pInternalData->DelaySettings.nOutputEnableNanoSeconds = 0;
9d004054:	8fc20008 	lw	v0,8(s8)
9d004058:	ac40001c 	sw	zero,28(v0)

	return TRUE;
9d00405c:	24020001 	li	v0,1
}
9d004060:	03c0e821 	move	sp,s8
9d004064:	8fbe0004 	lw	s8,4(sp)
9d004068:	27bd0008 	addiu	sp,sp,8
9d00406c:	03e00008 	jr	ra
9d004070:	00000000 	nop

9d004074 <UtPepLogicAllocLogicContext>:

#pragma region "Public Functions"

_IRQL_requires_max_(PASSIVE_LEVEL)
PVOID TUTPEPLOGICAPI UtPepLogicAllocLogicContext(VOID)
{
9d004074:	27bdffe0 	addiu	sp,sp,-32
9d004078:	afbf001c 	sw	ra,28(sp)
9d00407c:	afbe0018 	sw	s8,24(sp)
9d004080:	03a0f021 	move	s8,sp
#if defined(BUILD_USER_LIB)
    pLogicData = (TPepInternalLogicData*)UtAllocMem(sizeof(TPepInternalLogicData));
#elif defined(BUILD_DRIVER_LIB)
    pLogicData = (TPepInternalLogicData*)UtAllocPagedMem(sizeof(TPepInternalLogicData));
#elif defined(__32MX250F128B__) || (__32MX440F256H__)
    pLogicData = &l_InternalLogicData;
9d004084:	3c02a000 	lui	v0,0xa000
9d004088:	244200e8 	addiu	v0,v0,232
9d00408c:	afc20010 	sw	v0,16(s8)
#else
#error Unknown device configuration
#endif

    pLogicData->nLastAddress = 0xFFFFFFFF;
9d004090:	8fc20010 	lw	v0,16(s8)
9d004094:	2403ffff 	li	v1,-1
9d004098:	ac430000 	sw	v1,0(v0)
	pLogicData->nLastOutputEnable = 0xFFFFFFFF;
9d00409c:	8fc20010 	lw	v0,16(s8)
9d0040a0:	2403ffff 	li	v1,-1
9d0040a4:	ac430004 	sw	v1,4(v0)

    lInitModes(pLogicData);
9d0040a8:	8fc40010 	lw	a0,16(s8)
9d0040ac:	0f400ff9 	jal	9d003fe4 <USBCtrlEPAllowDataStage+0x2d14>
9d0040b0:	00000000 	nop
	lInitDelaySettings(pLogicData);
9d0040b4:	8fc40010 	lw	a0,16(s8)
9d0040b8:	0f40100f 	jal	9d00403c <USBCtrlEPAllowDataStage+0x2d6c>
9d0040bc:	00000000 	nop

    return pLogicData;
9d0040c0:	8fc20010 	lw	v0,16(s8)
}
9d0040c4:	03c0e821 	move	sp,s8
9d0040c8:	8fbf001c 	lw	ra,28(sp)
9d0040cc:	8fbe0018 	lw	s8,24(sp)
9d0040d0:	27bd0020 	addiu	sp,sp,32
9d0040d4:	03e00008 	jr	ra
9d0040d8:	00000000 	nop

9d0040dc <UtPepLogicFreeLogicContext>:

_IRQL_requires_max_(PASSIVE_LEVEL)
VOID TUTPEPLOGICAPI UtPepLogicFreeLogicContext(
  _In_ PVOID pvLogicContext)
{
9d0040dc:	27bdfff8 	addiu	sp,sp,-8
9d0040e0:	afbe0004 	sw	s8,4(sp)
9d0040e4:	03a0f021 	move	s8,sp
9d0040e8:	afc40008 	sw	a0,8(s8)
    UtFreePagedMem(pvLogicContext);
#elif defined(__32MX250F128B__) || defined(__32MX440F256H__)
#else
#error Unsupported configuration
#endif
}
9d0040ec:	03c0e821 	move	sp,s8
9d0040f0:	8fbe0004 	lw	s8,4(sp)
9d0040f4:	27bd0008 	addiu	sp,sp,8
9d0040f8:	03e00008 	jr	ra
9d0040fc:	00000000 	nop

9d004100 <UtPepLogicSetProgrammerMode>:

_IRQL_requires_max_(PASSIVE_LEVEL)
BOOLEAN TUTPEPLOGICAPI UtPepLogicSetProgrammerMode(
  _In_ TUtPepLogicData* pLogicData,
  _In_ UINT32 nProgrammerMode)
{
9d004100:	27bdffe0 	addiu	sp,sp,-32
9d004104:	afbf001c 	sw	ra,28(sp)
9d004108:	afbe0018 	sw	s8,24(sp)
9d00410c:	03a0f021 	move	s8,sp
9d004110:	afc40020 	sw	a0,32(s8)
9d004114:	afc50024 	sw	a1,36(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d004118:	8fc20020 	lw	v0,32(s8)
9d00411c:	8c420008 	lw	v0,8(v0)
9d004120:	afc20014 	sw	v0,20(s8)
    BOOLEAN bResult = FALSE;
9d004124:	a3c00010 	sb	zero,16(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    switch (nProgrammerMode)
9d004128:	8fc20024 	lw	v0,36(s8)
9d00412c:	24030002 	li	v1,2
9d004130:	10430009 	beq	v0,v1,9d004158 <UtPepLogicSetProgrammerMode+0x58>
9d004134:	00000000 	nop
9d004138:	24030004 	li	v1,4
9d00413c:	1043000f 	beq	v0,v1,9d00417c <UtPepLogicSetProgrammerMode+0x7c>
9d004140:	00000000 	nop
9d004144:	24030001 	li	v1,1
9d004148:	10430015 	beq	v0,v1,9d0041a0 <UtPepLogicSetProgrammerMode+0xa0>
9d00414c:	00000000 	nop
        default:
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetProgrammerMode - Invalid programmer mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif
            break;
9d004150:	0b401082 	j	9d004208 <UtPepLogicSetProgrammerMode+0x108>
9d004154:	00000000 	nop
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetProgrammerMode - Setting the programmer to the read mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            pData->Modes.nProgrammerMode = nProgrammerMode;
9d004158:	8fc20014 	lw	v0,20(s8)
9d00415c:	8fc30024 	lw	v1,36(s8)
9d004160:	ac430008 	sw	v1,8(v0)

            bResult = lEnableProgrammerReadMode(pLogicData);
9d004164:	8fc40020 	lw	a0,32(s8)
9d004168:	0f400f25 	jal	9d003c94 <USBCtrlEPAllowDataStage+0x29c4>
9d00416c:	00000000 	nop
9d004170:	a3c20010 	sb	v0,16(s8)
            break;
9d004174:	0b401082 	j	9d004208 <UtPepLogicSetProgrammerMode+0x108>
9d004178:	00000000 	nop
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetProgrammerMode - Setting the programmer to the write mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            pData->Modes.nProgrammerMode = nProgrammerMode;
9d00417c:	8fc20014 	lw	v0,20(s8)
9d004180:	8fc30024 	lw	v1,36(s8)
9d004184:	ac430008 	sw	v1,8(v0)

            bResult = lEnableProgrammerWriteMode(pLogicData);
9d004188:	8fc40020 	lw	a0,32(s8)
9d00418c:	0f400f5f 	jal	9d003d7c <USBCtrlEPAllowDataStage+0x2aac>
9d004190:	00000000 	nop
9d004194:	a3c20010 	sb	v0,16(s8)
            break;
9d004198:	0b401082 	j	9d004208 <UtPepLogicSetProgrammerMode+0x108>
9d00419c:	00000000 	nop
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetProgrammerMode - Setting the programmer to the none mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            bResult = lInitModes(pData) &&
9d0041a0:	8fc40014 	lw	a0,20(s8)
9d0041a4:	0f400ff9 	jal	9d003fe4 <USBCtrlEPAllowDataStage+0x2d14>
9d0041a8:	00000000 	nop
9d0041ac:	10400013 	beqz	v0,9d0041fc <UtPepLogicSetProgrammerMode+0xfc>
9d0041b0:	00000000 	nop
				          lInitDelaySettings(pData) &&
9d0041b4:	8fc40014 	lw	a0,20(s8)
9d0041b8:	0f40100f 	jal	9d00403c <USBCtrlEPAllowDataStage+0x2d6c>
9d0041bc:	00000000 	nop
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetProgrammerMode - Setting the programmer to the none mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            bResult = lInitModes(pData) &&
9d0041c0:	1040000e 	beqz	v0,9d0041fc <UtPepLogicSetProgrammerMode+0xfc>
9d0041c4:	00000000 	nop
				          lInitDelaySettings(pData) &&
                          lResetProgrammerState(pLogicData) &&
9d0041c8:	8fc40020 	lw	a0,32(s8)
9d0041cc:	0f400eff 	jal	9d003bfc <USBCtrlEPAllowDataStage+0x292c>
9d0041d0:	00000000 	nop
            pLogicData->pLogFunc("UtPepLogicSetProgrammerMode - Setting the programmer to the none mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            bResult = lInitModes(pData) &&
				          lInitDelaySettings(pData) &&
9d0041d4:	10400009 	beqz	v0,9d0041fc <UtPepLogicSetProgrammerMode+0xfc>
9d0041d8:	00000000 	nop
                          lResetProgrammerState(pLogicData) &&
                          lSetProgrammerVppMode(pLogicData);
9d0041dc:	8fc40020 	lw	a0,32(s8)
9d0041e0:	0f400e8e 	jal	9d003a38 <USBCtrlEPAllowDataStage+0x2768>
9d0041e4:	00000000 	nop
				                 MCurrentThreadId());
#endif

            bResult = lInitModes(pData) &&
				          lInitDelaySettings(pData) &&
                          lResetProgrammerState(pLogicData) &&
9d0041e8:	10400004 	beqz	v0,9d0041fc <UtPepLogicSetProgrammerMode+0xfc>
9d0041ec:	00000000 	nop
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetProgrammerMode - Setting the programmer to the none mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            bResult = lInitModes(pData) &&
9d0041f0:	24020001 	li	v0,1
9d0041f4:	0b401080 	j	9d004200 <UtPepLogicSetProgrammerMode+0x100>
9d0041f8:	00000000 	nop
9d0041fc:	00001021 	move	v0,zero
9d004200:	a3c20010 	sb	v0,16(s8)
				          lInitDelaySettings(pData) &&
                          lResetProgrammerState(pLogicData) &&
                          lSetProgrammerVppMode(pLogicData);
            break;
9d004204:	00000000 	nop
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("UtPepLogicSetProgrammerMode leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

    return bResult;
9d004208:	93c20010 	lbu	v0,16(s8)
}
9d00420c:	03c0e821 	move	sp,s8
9d004210:	8fbf001c 	lw	ra,28(sp)
9d004214:	8fbe0018 	lw	s8,24(sp)
9d004218:	27bd0020 	addiu	sp,sp,32
9d00421c:	03e00008 	jr	ra
9d004220:	00000000 	nop

9d004224 <UtPepLogicSetVccMode>:

_IRQL_requires_max_(PASSIVE_LEVEL)
BOOLEAN TUTPEPLOGICAPI UtPepLogicSetVccMode(
  _In_ TUtPepLogicData* pLogicData,
  _In_ UINT32 nVccMode)
{
9d004224:	27bdfff0 	addiu	sp,sp,-16
9d004228:	afbe000c 	sw	s8,12(sp)
9d00422c:	03a0f021 	move	s8,sp
9d004230:	afc40010 	sw	a0,16(s8)
9d004234:	afc50014 	sw	a1,20(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d004238:	8fc20010 	lw	v0,16(s8)
9d00423c:	8c420008 	lw	v0,8(v0)
9d004240:	afc20004 	sw	v0,4(s8)
    BOOLEAN bResult = FALSE;
9d004244:	a3c00000 	sb	zero,0(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    switch (nVccMode)
9d004248:	8fc20014 	lw	v0,20(s8)
9d00424c:	24030001 	li	v1,1
9d004250:	10430006 	beq	v0,v1,9d00426c <UtPepLogicSetVccMode+0x48>
9d004254:	00000000 	nop
9d004258:	24030002 	li	v1,2
9d00425c:	1043000f 	beq	v0,v1,9d00429c <UtPepLogicSetVccMode+0x78>
9d004260:	00000000 	nop
        default:
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetVccMode - Invalid VCC mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif
            break;
9d004264:	0b4010b7 	j	9d0042dc <UtPepLogicSetVccMode+0xb8>
9d004268:	00000000 	nop
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetVccMode - Trying to set the programmer to the +5VDC mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            if (pData->Modes.nProgrammerMode == CUtPepLogicProgrammerNoneMode)
9d00426c:	8fc20004 	lw	v0,4(s8)
9d004270:	8c430008 	lw	v1,8(v0)
9d004274:	24020001 	li	v0,1
9d004278:	14620014 	bne	v1,v0,9d0042cc <UtPepLogicSetVccMode+0xa8>
9d00427c:	00000000 	nop
            {
                pData->Modes.nVccMode = nVccMode;
9d004280:	8fc20004 	lw	v0,4(s8)
9d004284:	8fc30014 	lw	v1,20(s8)
9d004288:	ac43000c 	sw	v1,12(v0)

                bResult = TRUE;
9d00428c:	24020001 	li	v0,1
9d004290:	a3c20000 	sb	v0,0(s8)
#if defined(ENABLE_LOGGING) 
                pLogicData->pLogFunc("UtPepLogicSetVccMode - Programmer not in the none mode.  (Thread: 0x%p)\n",
					                 MCurrentThreadId());
#endif
            }
			break;
9d004294:	0b4010b7 	j	9d0042dc <UtPepLogicSetVccMode+0xb8>
9d004298:	00000000 	nop
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetVccMode - Trying to set the programmer to the +6.25VDC mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            if (pData->Modes.nProgrammerMode == CUtPepLogicProgrammerNoneMode)
9d00429c:	8fc20004 	lw	v0,4(s8)
9d0042a0:	8c430008 	lw	v1,8(v0)
9d0042a4:	24020001 	li	v0,1
9d0042a8:	1462000b 	bne	v1,v0,9d0042d8 <UtPepLogicSetVccMode+0xb4>
9d0042ac:	00000000 	nop
            {
                pData->Modes.nVccMode = nVccMode;
9d0042b0:	8fc20004 	lw	v0,4(s8)
9d0042b4:	8fc30014 	lw	v1,20(s8)
9d0042b8:	ac43000c 	sw	v1,12(v0)

                bResult = TRUE;
9d0042bc:	24020001 	li	v0,1
9d0042c0:	a3c20000 	sb	v0,0(s8)
#if defined(ENABLE_LOGGING) 
                pLogicData->pLogFunc("UtPepLogicSetVccMode - Programmer not in the none mode.  (Thread: 0x%p)\n",
					                 MCurrentThreadId());
#endif
            }
			break;
9d0042c4:	0b4010b7 	j	9d0042dc <UtPepLogicSetVccMode+0xb8>
9d0042c8:	00000000 	nop
#if defined(ENABLE_LOGGING) 
                pLogicData->pLogFunc("UtPepLogicSetVccMode - Programmer not in the none mode.  (Thread: 0x%p)\n",
					                 MCurrentThreadId());
#endif
            }
			break;
9d0042cc:	00000000 	nop
9d0042d0:	0b4010b7 	j	9d0042dc <UtPepLogicSetVccMode+0xb8>
9d0042d4:	00000000 	nop
#if defined(ENABLE_LOGGING) 
                pLogicData->pLogFunc("UtPepLogicSetVccMode - Programmer not in the none mode.  (Thread: 0x%p)\n",
					                 MCurrentThreadId());
#endif
            }
			break;
9d0042d8:	00000000 	nop
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("UtPepLogicSetVccMode leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

	return bResult;
9d0042dc:	93c20000 	lbu	v0,0(s8)
}
9d0042e0:	03c0e821 	move	sp,s8
9d0042e4:	8fbe000c 	lw	s8,12(sp)
9d0042e8:	27bd0010 	addiu	sp,sp,16
9d0042ec:	03e00008 	jr	ra
9d0042f0:	00000000 	nop

9d0042f4 <UtPepLogicSetPinPulseMode>:

_IRQL_requires_max_(PASSIVE_LEVEL)
BOOLEAN TUTPEPLOGICAPI UtPepLogicSetPinPulseMode(
  _In_ TUtPepLogicData* pLogicData,
  _In_ UINT32 nPinPulseMode)
{
9d0042f4:	27bdfff0 	addiu	sp,sp,-16
9d0042f8:	afbe000c 	sw	s8,12(sp)
9d0042fc:	03a0f021 	move	s8,sp
9d004300:	afc40010 	sw	a0,16(s8)
9d004304:	afc50014 	sw	a1,20(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d004308:	8fc20010 	lw	v0,16(s8)
9d00430c:	8c420008 	lw	v0,8(v0)
9d004310:	afc20004 	sw	v0,4(s8)
    BOOLEAN bResult = FALSE;
9d004314:	a3c00000 	sb	zero,0(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    switch (nPinPulseMode)
9d004318:	8fc20014 	lw	v0,20(s8)
9d00431c:	24030002 	li	v1,2
9d004320:	1043001d 	beq	v0,v1,9d004398 <UtPepLogicSetPinPulseMode+0xa4>
9d004324:	00000000 	nop
9d004328:	2c430003 	sltiu	v1,v0,3
9d00432c:	10600006 	beqz	v1,9d004348 <UtPepLogicSetPinPulseMode+0x54>
9d004330:	00000000 	nop
9d004334:	24030001 	li	v1,1
9d004338:	1043000b 	beq	v0,v1,9d004368 <UtPepLogicSetPinPulseMode+0x74>
9d00433c:	00000000 	nop
        default:
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetPinPulseMode - Invalid pin mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif
            break;
9d004340:	0b401114 	j	9d004450 <UtPepLogicSetPinPulseMode+0x15c>
9d004344:	00000000 	nop

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    switch (nPinPulseMode)
9d004348:	24030003 	li	v1,3
9d00434c:	1043001e 	beq	v0,v1,9d0043c8 <UtPepLogicSetPinPulseMode+0xd4>
9d004350:	00000000 	nop
9d004354:	24030004 	li	v1,4
9d004358:	10430027 	beq	v0,v1,9d0043f8 <UtPepLogicSetPinPulseMode+0x104>
9d00435c:	00000000 	nop
        default:
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetPinPulseMode - Invalid pin mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif
            break;
9d004360:	0b401114 	j	9d004450 <UtPepLogicSetPinPulseMode+0x15c>
9d004364:	00000000 	nop
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetPinPulseMode - Trying to set the programmer to the VEN08 and WE08 pin mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            if (pData->Modes.nProgrammerMode == CUtPepLogicProgrammerNoneMode)
9d004368:	8fc20004 	lw	v0,4(s8)
9d00436c:	8c430008 	lw	v1,8(v0)
9d004370:	24020001 	li	v0,1
9d004374:	1462002c 	bne	v1,v0,9d004428 <UtPepLogicSetPinPulseMode+0x134>
9d004378:	00000000 	nop
            {
                pData->Modes.nPinPulseMode = nPinPulseMode;
9d00437c:	8fc20004 	lw	v0,4(s8)
9d004380:	8fc30014 	lw	v1,20(s8)
9d004384:	ac430010 	sw	v1,16(v0)

			    bResult = TRUE;
9d004388:	24020001 	li	v0,1
9d00438c:	a3c20000 	sb	v0,0(s8)
#if defined(ENABLE_LOGGING) 
                pLogicData->pLogFunc("UtPepLogicSetPinPulseMode - Programmer not in the none mode.  (Thread: 0x%p)\n",
					                 MCurrentThreadId());
#endif
            }
            break;
9d004390:	0b401114 	j	9d004450 <UtPepLogicSetPinPulseMode+0x15c>
9d004394:	00000000 	nop
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetPinPulseMode - Trying to set the programmer to the ~VP5 and Vpp16 pin mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            if (pData->Modes.nProgrammerMode == CUtPepLogicProgrammerNoneMode)
9d004398:	8fc20004 	lw	v0,4(s8)
9d00439c:	8c430008 	lw	v1,8(v0)
9d0043a0:	24020001 	li	v0,1
9d0043a4:	14620023 	bne	v1,v0,9d004434 <UtPepLogicSetPinPulseMode+0x140>
9d0043a8:	00000000 	nop
            {
                pData->Modes.nPinPulseMode = nPinPulseMode;
9d0043ac:	8fc20004 	lw	v0,4(s8)
9d0043b0:	8fc30014 	lw	v1,20(s8)
9d0043b4:	ac430010 	sw	v1,16(v0)

			    bResult = TRUE;
9d0043b8:	24020001 	li	v0,1
9d0043bc:	a3c20000 	sb	v0,0(s8)
#if defined(ENABLE_LOGGING) 
                pLogicData->pLogFunc("UtPepLogicSetPinPulseMode - Programmer not in the none mode.  (Thread: 0x%p)\n",
					                 MCurrentThreadId());
#endif
            }
            break;
9d0043c0:	0b401114 	j	9d004450 <UtPepLogicSetPinPulseMode+0x15c>
9d0043c4:	00000000 	nop
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetPinPulseMode - Trying to set the programmer to the Vpp32 pin mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            if (pData->Modes.nProgrammerMode == CUtPepLogicProgrammerNoneMode)
9d0043c8:	8fc20004 	lw	v0,4(s8)
9d0043cc:	8c430008 	lw	v1,8(v0)
9d0043d0:	24020001 	li	v0,1
9d0043d4:	1462001a 	bne	v1,v0,9d004440 <UtPepLogicSetPinPulseMode+0x14c>
9d0043d8:	00000000 	nop
            {
                pData->Modes.nPinPulseMode = nPinPulseMode;
9d0043dc:	8fc20004 	lw	v0,4(s8)
9d0043e0:	8fc30014 	lw	v1,20(s8)
9d0043e4:	ac430010 	sw	v1,16(v0)

			    bResult = TRUE;
9d0043e8:	24020001 	li	v0,1
9d0043ec:	a3c20000 	sb	v0,0(s8)
#if defined(ENABLE_LOGGING) 
                pLogicData->pLogFunc("UtPepLogicSetPinPulseMode - Programmer not in the none mode.  (Thread: 0x%p)\n",
					                 MCurrentThreadId());
#endif
            }
            break;
9d0043f0:	0b401114 	j	9d004450 <UtPepLogicSetPinPulseMode+0x15c>
9d0043f4:	00000000 	nop
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetPinPulseMode - Trying to set the programmer to the Vpp64 pin mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            if (pData->Modes.nProgrammerMode == CUtPepLogicProgrammerNoneMode)
9d0043f8:	8fc20004 	lw	v0,4(s8)
9d0043fc:	8c430008 	lw	v1,8(v0)
9d004400:	24020001 	li	v0,1
9d004404:	14620011 	bne	v1,v0,9d00444c <UtPepLogicSetPinPulseMode+0x158>
9d004408:	00000000 	nop
            {
                pData->Modes.nPinPulseMode = nPinPulseMode;
9d00440c:	8fc20004 	lw	v0,4(s8)
9d004410:	8fc30014 	lw	v1,20(s8)
9d004414:	ac430010 	sw	v1,16(v0)

			    bResult = TRUE;
9d004418:	24020001 	li	v0,1
9d00441c:	a3c20000 	sb	v0,0(s8)
#if defined(ENABLE_LOGGING) 
                pLogicData->pLogFunc("UtPepLogicSetPinPulseMode - Programmer not in the none mode.  (Thread: 0x%p)\n",
					                 MCurrentThreadId());
#endif
            }
            break;
9d004420:	0b401114 	j	9d004450 <UtPepLogicSetPinPulseMode+0x15c>
9d004424:	00000000 	nop
#if defined(ENABLE_LOGGING) 
                pLogicData->pLogFunc("UtPepLogicSetPinPulseMode - Programmer not in the none mode.  (Thread: 0x%p)\n",
					                 MCurrentThreadId());
#endif
            }
            break;
9d004428:	00000000 	nop
9d00442c:	0b401114 	j	9d004450 <UtPepLogicSetPinPulseMode+0x15c>
9d004430:	00000000 	nop
#if defined(ENABLE_LOGGING) 
                pLogicData->pLogFunc("UtPepLogicSetPinPulseMode - Programmer not in the none mode.  (Thread: 0x%p)\n",
					                 MCurrentThreadId());
#endif
            }
            break;
9d004434:	00000000 	nop
9d004438:	0b401114 	j	9d004450 <UtPepLogicSetPinPulseMode+0x15c>
9d00443c:	00000000 	nop
#if defined(ENABLE_LOGGING) 
                pLogicData->pLogFunc("UtPepLogicSetPinPulseMode - Programmer not in the none mode.  (Thread: 0x%p)\n",
					                 MCurrentThreadId());
#endif
            }
            break;
9d004440:	00000000 	nop
9d004444:	0b401114 	j	9d004450 <UtPepLogicSetPinPulseMode+0x15c>
9d004448:	00000000 	nop
#if defined(ENABLE_LOGGING) 
                pLogicData->pLogFunc("UtPepLogicSetPinPulseMode - Programmer not in the none mode.  (Thread: 0x%p)\n",
					                 MCurrentThreadId());
#endif
            }
            break;
9d00444c:	00000000 	nop
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("UtPepLogicSetPinPulseMode leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

	return bResult;
9d004450:	93c20000 	lbu	v0,0(s8)
}
9d004454:	03c0e821 	move	sp,s8
9d004458:	8fbe000c 	lw	s8,12(sp)
9d00445c:	27bd0010 	addiu	sp,sp,16
9d004460:	03e00008 	jr	ra
9d004464:	00000000 	nop

9d004468 <UtPepLogicSetVppMode>:

_IRQL_requires_max_(PASSIVE_LEVEL)
BOOLEAN TUTPEPLOGICAPI UtPepLogicSetVppMode(
  _In_ TUtPepLogicData* pLogicData,
  _In_ UINT32 nVppMode)
{
9d004468:	27bdffe0 	addiu	sp,sp,-32
9d00446c:	afbf001c 	sw	ra,28(sp)
9d004470:	afbe0018 	sw	s8,24(sp)
9d004474:	03a0f021 	move	s8,sp
9d004478:	afc40020 	sw	a0,32(s8)
9d00447c:	afc50024 	sw	a1,36(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d004480:	8fc20020 	lw	v0,32(s8)
9d004484:	8c420008 	lw	v0,8(v0)
9d004488:	afc20014 	sw	v0,20(s8)
    BOOLEAN bResult = FALSE;
9d00448c:	a3c00010 	sb	zero,16(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    switch (nVppMode)
9d004490:	8fc20024 	lw	v0,36(s8)
9d004494:	24030002 	li	v1,2
9d004498:	1043000e 	beq	v0,v1,9d0044d4 <UtPepLogicSetVppMode+0x6c>
9d00449c:	00000000 	nop
9d0044a0:	24030004 	li	v1,4
9d0044a4:	10430012 	beq	v0,v1,9d0044f0 <UtPepLogicSetVppMode+0x88>
9d0044a8:	00000000 	nop
9d0044ac:	24030001 	li	v1,1
9d0044b0:	14430016 	bne	v0,v1,9d00450c <UtPepLogicSetVppMode+0xa4>
9d0044b4:	00000000 	nop
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetVppMode - Setting the programmer to the +12VDC Vpp mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            pData->Modes.nVppMode = nVppMode;
9d0044b8:	8fc20014 	lw	v0,20(s8)
9d0044bc:	8fc30024 	lw	v1,36(s8)
9d0044c0:	ac430014 	sw	v1,20(v0)

		    bResult = TRUE;
9d0044c4:	24020001 	li	v0,1
9d0044c8:	a3c20010 	sb	v0,16(s8)
            break;
9d0044cc:	0b401144 	j	9d004510 <UtPepLogicSetVppMode+0xa8>
9d0044d0:	00000000 	nop
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetVppMode - Setting the programmer to the +21VDC Vpp mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            pData->Modes.nVppMode = nVppMode;
9d0044d4:	8fc20014 	lw	v0,20(s8)
9d0044d8:	8fc30024 	lw	v1,36(s8)
9d0044dc:	ac430014 	sw	v1,20(v0)

		    bResult = TRUE;
9d0044e0:	24020001 	li	v0,1
9d0044e4:	a3c20010 	sb	v0,16(s8)
            break;
9d0044e8:	0b401144 	j	9d004510 <UtPepLogicSetVppMode+0xa8>
9d0044ec:	00000000 	nop
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetVppMode - Setting the programmer to the +25VDC Vpp mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            pData->Modes.nVppMode = nVppMode;
9d0044f0:	8fc20014 	lw	v0,20(s8)
9d0044f4:	8fc30024 	lw	v1,36(s8)
9d0044f8:	ac430014 	sw	v1,20(v0)

		    bResult = TRUE;
9d0044fc:	24020001 	li	v0,1
9d004500:	a3c20010 	sb	v0,16(s8)
            break;
9d004504:	0b401144 	j	9d004510 <UtPepLogicSetVppMode+0xa8>
9d004508:	00000000 	nop
        default:
#if defined(ENABLE_LOGGING) 
            pLogicData->pLogFunc("UtPepLogicSetVppMode - Invalid Vpp mode.  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif
            break;
9d00450c:	00000000 	nop
	}

    if (bResult)
9d004510:	93c20010 	lbu	v0,16(s8)
9d004514:	10400004 	beqz	v0,9d004528 <UtPepLogicSetVppMode+0xc0>
9d004518:	00000000 	nop
    {
        lSetProgrammerVppMode(pLogicData);
9d00451c:	8fc40020 	lw	a0,32(s8)
9d004520:	0f400e8e 	jal	9d003a38 <USBCtrlEPAllowDataStage+0x2768>
9d004524:	00000000 	nop
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("UtPepLogicSetVppMode leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

	return bResult;
9d004528:	93c20010 	lbu	v0,16(s8)
}
9d00452c:	03c0e821 	move	sp,s8
9d004530:	8fbf001c 	lw	ra,28(sp)
9d004534:	8fbe0018 	lw	s8,24(sp)
9d004538:	27bd0020 	addiu	sp,sp,32
9d00453c:	03e00008 	jr	ra
9d004540:	00000000 	nop

9d004544 <UtPepLogicSetAddress>:

_IRQL_requires_max_(PASSIVE_LEVEL)
BOOLEAN TUTPEPLOGICAPI UtPepLogicSetAddress(
  _In_ TUtPepLogicData* pLogicData,
  _In_ UINT32 nAddress)
{
9d004544:	27bdffe0 	addiu	sp,sp,-32
9d004548:	afbf001c 	sw	ra,28(sp)
9d00454c:	afbe0018 	sw	s8,24(sp)
9d004550:	03a0f021 	move	s8,sp
9d004554:	afc40020 	sw	a0,32(s8)
9d004558:	afc50024 	sw	a1,36(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

	bResult = lSetProgrammerAddress(pLogicData, nAddress);
9d00455c:	8fc40020 	lw	a0,32(s8)
9d004560:	8fc50024 	lw	a1,36(s8)
9d004564:	0f400dc4 	jal	9d003710 <USBCtrlEPAllowDataStage+0x2440>
9d004568:	00000000 	nop
9d00456c:	a3c20010 	sb	v0,16(s8)
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("UtPepLogicSetAddress leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

	return bResult;
9d004570:	93c20010 	lbu	v0,16(s8)
}
9d004574:	03c0e821 	move	sp,s8
9d004578:	8fbf001c 	lw	ra,28(sp)
9d00457c:	8fbe0018 	lw	s8,24(sp)
9d004580:	27bd0020 	addiu	sp,sp,32
9d004584:	03e00008 	jr	ra
9d004588:	00000000 	nop

9d00458c <UtPepLogicSetAddressWithDelay>:
_IRQL_requires_max_(PASSIVE_LEVEL)
BOOLEAN TUTPEPLOGICAPI UtPepLogicSetAddressWithDelay(
  _In_ TUtPepLogicData* pLogicData,
  _In_ UINT32 nAddress,
  _In_ UINT32 nDelayNanoSeconds)
{
9d00458c:	27bdffe0 	addiu	sp,sp,-32
9d004590:	afbf001c 	sw	ra,28(sp)
9d004594:	afbe0018 	sw	s8,24(sp)
9d004598:	03a0f021 	move	s8,sp
9d00459c:	afc40020 	sw	a0,32(s8)
9d0045a0:	afc50024 	sw	a1,36(s8)
9d0045a4:	afc60028 	sw	a2,40(s8)

#if defined(BUILD_DRIVER_LIB)
	PAGED_CODE()
#endif

	bResult = lSetProgrammerAddress(pLogicData, nAddress);
9d0045a8:	8fc40020 	lw	a0,32(s8)
9d0045ac:	8fc50024 	lw	a1,36(s8)
9d0045b0:	0f400dc4 	jal	9d003710 <USBCtrlEPAllowDataStage+0x2440>
9d0045b4:	00000000 	nop
9d0045b8:	a3c20010 	sb	v0,16(s8)

	if (bResult && nDelayNanoSeconds > 0)
9d0045bc:	93c20010 	lbu	v0,16(s8)
9d0045c0:	10400007 	beqz	v0,9d0045e0 <UtPepLogicSetAddressWithDelay+0x54>
9d0045c4:	00000000 	nop
9d0045c8:	8fc20028 	lw	v0,40(s8)
9d0045cc:	10400004 	beqz	v0,9d0045e0 <UtPepLogicSetAddressWithDelay+0x54>
9d0045d0:	00000000 	nop
#if defined(ENABLE_LOGGING) 
		pLogicData->pLogFunc("UtPepLogicSetAddressWithDelay - Delay detected.  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif

		if (!UtSleep(nDelayNanoSeconds))
9d0045d4:	8fc40028 	lw	a0,40(s8)
9d0045d8:	0f401c68 	jal	9d0071a0 <UtSleep>
9d0045dc:	00000000 	nop
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("UtPepLogicSetAddressWithDelay leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

	return bResult;
9d0045e0:	93c20010 	lbu	v0,16(s8)
}
9d0045e4:	03c0e821 	move	sp,s8
9d0045e8:	8fbf001c 	lw	ra,28(sp)
9d0045ec:	8fbe0018 	lw	s8,24(sp)
9d0045f0:	27bd0020 	addiu	sp,sp,32
9d0045f4:	03e00008 	jr	ra
9d0045f8:	00000000 	nop

9d0045fc <UtPepLogicGetData>:

_IRQL_requires_max_(PASSIVE_LEVEL)
BOOLEAN TUTPEPLOGICAPI UtPepLogicGetData(
  _In_ TUtPepLogicData* pLogicData,
  _Out_ UINT8* pnData)
{
9d0045fc:	27bdffe0 	addiu	sp,sp,-32
9d004600:	afbf001c 	sw	ra,28(sp)
9d004604:	afbe0018 	sw	s8,24(sp)
9d004608:	03a0f021 	move	s8,sp
9d00460c:	afc40020 	sw	a0,32(s8)
9d004610:	afc50024 	sw	a1,36(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d004614:	8fc20020 	lw	v0,32(s8)
9d004618:	8c420008 	lw	v0,8(v0)
9d00461c:	afc20010 	sw	v0,16(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    if (pData->Modes.nProgrammerMode != CUtPepLogicProgrammerReadMode)
9d004620:	8fc20010 	lw	v0,16(s8)
9d004624:	8c430008 	lw	v1,8(v0)
9d004628:	24020002 	li	v0,2
9d00462c:	10620004 	beq	v1,v0,9d004640 <UtPepLogicGetData+0x44>
9d004630:	00000000 	nop
#if defined(ENABLE_LOGGING) 
		pLogicData->pLogFunc("UtPepLogicGetData leaving.  (Not in programmer read mode)  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif

        return FALSE;
9d004634:	00001021 	move	v0,zero
9d004638:	0b401196 	j	9d004658 <UtPepLogicGetData+0x5c>
9d00463c:	00000000 	nop
    }

    bResult = lReadByteFromProgrammer(pLogicData, pnData);
9d004640:	8fc40020 	lw	a0,32(s8)
9d004644:	8fc50024 	lw	a1,36(s8)
9d004648:	0f400d55 	jal	9d003554 <USBCtrlEPAllowDataStage+0x2284>
9d00464c:	00000000 	nop
9d004650:	a3c20014 	sb	v0,20(s8)
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("UtPepLogicGetData leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

	return bResult;
9d004654:	93c20014 	lbu	v0,20(s8)
}
9d004658:	03c0e821 	move	sp,s8
9d00465c:	8fbf001c 	lw	ra,28(sp)
9d004660:	8fbe0018 	lw	s8,24(sp)
9d004664:	27bd0020 	addiu	sp,sp,32
9d004668:	03e00008 	jr	ra
9d00466c:	00000000 	nop

9d004670 <UtPepLogicSetData>:

_IRQL_requires_max_(PASSIVE_LEVEL)
BOOLEAN TUTPEPLOGICAPI UtPepLogicSetData(
  _In_ TUtPepLogicData* pLogicData,
  _In_ UINT8 nData)
{
9d004670:	27bdffe0 	addiu	sp,sp,-32
9d004674:	afbf001c 	sw	ra,28(sp)
9d004678:	afbe0018 	sw	s8,24(sp)
9d00467c:	03a0f021 	move	s8,sp
9d004680:	afc40020 	sw	a0,32(s8)
9d004684:	00a01021 	move	v0,a1
9d004688:	a3c20024 	sb	v0,36(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d00468c:	8fc20020 	lw	v0,32(s8)
9d004690:	8c420008 	lw	v0,8(v0)
9d004694:	afc20010 	sw	v0,16(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    if (pData->Modes.nProgrammerMode != CUtPepLogicProgrammerWriteMode)
9d004698:	8fc20010 	lw	v0,16(s8)
9d00469c:	8c430008 	lw	v1,8(v0)
9d0046a0:	24020004 	li	v0,4
9d0046a4:	10620004 	beq	v1,v0,9d0046b8 <UtPepLogicSetData+0x48>
9d0046a8:	00000000 	nop
#if defined(ENABLE_LOGGING) 
        pLogicData->pLogFunc("UtPepLogicSetData leaving. (Not in programmer write mode)  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif

        return FALSE;
9d0046ac:	00001021 	move	v0,zero
9d0046b0:	0b4011b5 	j	9d0046d4 <UtPepLogicSetData+0x64>
9d0046b4:	00000000 	nop
    }

	bResult = lWriteByteToProgrammer(pLogicData, nData);
9d0046b8:	93c20024 	lbu	v0,36(s8)
9d0046bc:	8fc40020 	lw	a0,32(s8)
9d0046c0:	00402821 	move	a1,v0
9d0046c4:	0f400d9d 	jal	9d003674 <USBCtrlEPAllowDataStage+0x23a4>
9d0046c8:	00000000 	nop
9d0046cc:	a3c20014 	sb	v0,20(s8)
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("UtPepLogicSetData leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

	return bResult;
9d0046d0:	93c20014 	lbu	v0,20(s8)
}
9d0046d4:	03c0e821 	move	sp,s8
9d0046d8:	8fbf001c 	lw	ra,28(sp)
9d0046dc:	8fbe0018 	lw	s8,24(sp)
9d0046e0:	27bd0020 	addiu	sp,sp,32
9d0046e4:	03e00008 	jr	ra
9d0046e8:	00000000 	nop

9d0046ec <UtPepLogicTriggerProgram>:

_IRQL_requires_max_(PASSIVE_LEVEL)
BOOLEAN TUTPEPLOGICAPI UtPepLogicTriggerProgram(
  _In_ TUtPepLogicData* pLogicData,
  _Out_ PBOOLEAN pbSuccess)
{
9d0046ec:	27bdffe0 	addiu	sp,sp,-32
9d0046f0:	afbf001c 	sw	ra,28(sp)
9d0046f4:	afbe0018 	sw	s8,24(sp)
9d0046f8:	03a0f021 	move	s8,sp
9d0046fc:	afc40020 	sw	a0,32(s8)
9d004700:	afc50024 	sw	a1,36(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d004704:	8fc20020 	lw	v0,32(s8)
9d004708:	8c420008 	lw	v0,8(v0)
9d00470c:	afc20014 	sw	v0,20(s8)
    BOOLEAN bResult = FALSE;
9d004710:	a3c00010 	sb	zero,16(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    *pbSuccess = FALSE;
9d004714:	8fc20024 	lw	v0,36(s8)
9d004718:	a0400000 	sb	zero,0(v0)

    if (pData->Modes.nProgrammerMode == CUtPepLogicProgrammerWriteMode)
9d00471c:	8fc20014 	lw	v0,20(s8)
9d004720:	8c430008 	lw	v1,8(v0)
9d004724:	24020004 	li	v0,4
9d004728:	14620055 	bne	v1,v0,9d004880 <UtPepLogicTriggerProgram+0x194>
9d00472c:	00000000 	nop
        /* Disable reset program pulse */

        if (!lWritePortData(pLogicData,
                            MEnableTriggerProgramPulse(FALSE) |
                                MEnableResetProgramPulse(FALSE) |
                                MSelectVccMode(pData->Modes.nVccMode) |
9d004730:	8fc20014 	lw	v0,20(s8)
9d004734:	8c43000c 	lw	v1,12(v0)

    if (pData->Modes.nProgrammerMode == CUtPepLogicProgrammerWriteMode)
    {
        /* Disable reset program pulse */

        if (!lWritePortData(pLogicData,
9d004738:	24020001 	li	v0,1
9d00473c:	14620004 	bne	v1,v0,9d004750 <UtPepLogicTriggerProgram+0x64>
9d004740:	00000000 	nop
9d004744:	24020004 	li	v0,4
9d004748:	0b4011d5 	j	9d004754 <UtPepLogicTriggerProgram+0x68>
9d00474c:	00000000 	nop
9d004750:	2402000c 	li	v0,12
9d004754:	8fc40020 	lw	a0,32(s8)
9d004758:	00402821 	move	a1,v0
9d00475c:	24060007 	li	a2,7
9d004760:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d004764:	00000000 	nop
9d004768:	14400004 	bnez	v0,9d00477c <UtPepLogicTriggerProgram+0x90>
9d00476c:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("UtPepLogicTriggerProgram leaving.  (Failed to disable reset program pulse)  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            return FALSE;
9d004770:	00001021 	move	v0,zero
9d004774:	0b401221 	j	9d004884 <UtPepLogicTriggerProgram+0x198>
9d004778:	00000000 	nop
        /* Enable trigger program pulse */

        if (!lWritePortData(pLogicData,
                            MEnableTriggerProgramPulse(TRUE) |
                                MEnableResetProgramPulse(FALSE) |
                                MSelectVccMode(pData->Modes.nVccMode) |
9d00477c:	8fc20014 	lw	v0,20(s8)
9d004780:	8c43000c 	lw	v1,12(v0)
            return FALSE;
        }

        /* Enable trigger program pulse */

        if (!lWritePortData(pLogicData,
9d004784:	24020001 	li	v0,1
9d004788:	14620004 	bne	v1,v0,9d00479c <UtPepLogicTriggerProgram+0xb0>
9d00478c:	00000000 	nop
9d004790:	24020005 	li	v0,5
9d004794:	0b4011e8 	j	9d0047a0 <UtPepLogicTriggerProgram+0xb4>
9d004798:	00000000 	nop
9d00479c:	2402000d 	li	v0,13
9d0047a0:	8fc40020 	lw	a0,32(s8)
9d0047a4:	00402821 	move	a1,v0
9d0047a8:	24060007 	li	a2,7
9d0047ac:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d0047b0:	00000000 	nop
9d0047b4:	14400004 	bnez	v0,9d0047c8 <UtPepLogicTriggerProgram+0xdc>
9d0047b8:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("UtPepLogicTriggerProgram leaving.  (Failed to enable trigger program pulse)  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            return FALSE;
9d0047bc:	00001021 	move	v0,zero
9d0047c0:	0b401221 	j	9d004884 <UtPepLogicTriggerProgram+0x198>
9d0047c4:	00000000 	nop
        /* Disable trigger program pulse */

        if (!lWritePortData(pLogicData,
                            MEnableTriggerProgramPulse(FALSE) |
                                MEnableResetProgramPulse(FALSE) |
                                MSelectVccMode(pData->Modes.nVccMode) |
9d0047c8:	8fc20014 	lw	v0,20(s8)
9d0047cc:	8c43000c 	lw	v1,12(v0)
            return FALSE;
        }

        /* Disable trigger program pulse */

        if (!lWritePortData(pLogicData,
9d0047d0:	24020001 	li	v0,1
9d0047d4:	14620004 	bne	v1,v0,9d0047e8 <UtPepLogicTriggerProgram+0xfc>
9d0047d8:	00000000 	nop
9d0047dc:	24020004 	li	v0,4
9d0047e0:	0b4011fb 	j	9d0047ec <UtPepLogicTriggerProgram+0x100>
9d0047e4:	00000000 	nop
9d0047e8:	2402000c 	li	v0,12
9d0047ec:	8fc40020 	lw	a0,32(s8)
9d0047f0:	00402821 	move	a1,v0
9d0047f4:	24060007 	li	a2,7
9d0047f8:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d0047fc:	00000000 	nop
9d004800:	14400004 	bnez	v0,9d004814 <UtPepLogicTriggerProgram+0x128>
9d004804:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("UtPepLogicTriggerProgram leaving.  (Failed to disable trigger program pulse)  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            return FALSE;
9d004808:	00001021 	move	v0,zero
9d00480c:	0b401221 	j	9d004884 <UtPepLogicTriggerProgram+0x198>
9d004810:	00000000 	nop
        }

        *pbSuccess = lWaitForProgramPulse(pLogicData);
9d004814:	8fc40020 	lw	a0,32(s8)
9d004818:	0f400f99 	jal	9d003e64 <USBCtrlEPAllowDataStage+0x2b94>
9d00481c:	00000000 	nop
9d004820:	00401821 	move	v1,v0
9d004824:	8fc20024 	lw	v0,36(s8)
9d004828:	a0430000 	sb	v1,0(v0)
        /* Disable reset program pulse */

        if (!lWritePortData(pLogicData,
                            MEnableTriggerProgramPulse(FALSE) |
                                MEnableResetProgramPulse(TRUE) |
                                MSelectVccMode(pData->Modes.nVccMode) |
9d00482c:	8fc20014 	lw	v0,20(s8)
9d004830:	8c43000c 	lw	v1,12(v0)

        *pbSuccess = lWaitForProgramPulse(pLogicData);

        /* Disable reset program pulse */

        if (!lWritePortData(pLogicData,
9d004834:	24020001 	li	v0,1
9d004838:	14620004 	bne	v1,v0,9d00484c <UtPepLogicTriggerProgram+0x160>
9d00483c:	00000000 	nop
9d004840:	24020006 	li	v0,6
9d004844:	0b401214 	j	9d004850 <UtPepLogicTriggerProgram+0x164>
9d004848:	00000000 	nop
9d00484c:	2402000e 	li	v0,14
9d004850:	8fc40020 	lw	a0,32(s8)
9d004854:	00402821 	move	a1,v0
9d004858:	24060007 	li	a2,7
9d00485c:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d004860:	00000000 	nop
9d004864:	14400004 	bnez	v0,9d004878 <UtPepLogicTriggerProgram+0x18c>
9d004868:	00000000 	nop
#if defined(ENABLE_LOGGING) 
			pLogicData->pLogFunc("UtPepLogicTriggerProgram leaving.  (Failed to disable reset program pulse)  (Thread: 0x%p)\n",
				                 MCurrentThreadId());
#endif

            return FALSE;
9d00486c:	00001021 	move	v0,zero
9d004870:	0b401221 	j	9d004884 <UtPepLogicTriggerProgram+0x198>
9d004874:	00000000 	nop
        }

        bResult = TRUE;
9d004878:	24020001 	li	v0,1
9d00487c:	a3c20010 	sb	v0,16(s8)
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("UtPepLogicTriggerProgram leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

    return bResult;
9d004880:	93c20010 	lbu	v0,16(s8)
}
9d004884:	03c0e821 	move	sp,s8
9d004888:	8fbf001c 	lw	ra,28(sp)
9d00488c:	8fbe0018 	lw	s8,24(sp)
9d004890:	27bd0020 	addiu	sp,sp,32
9d004894:	03e00008 	jr	ra
9d004898:	00000000 	nop

9d00489c <UtPepLogicSetOutputEnable>:

_IRQL_requires_max_(PASSIVE_LEVEL)
BOOLEAN TUTPEPLOGICAPI UtPepLogicSetOutputEnable(
  _In_ TUtPepLogicData* pLogicData,
  _In_ UINT32 nOutputEnable)
{
9d00489c:	27bdffe0 	addiu	sp,sp,-32
9d0048a0:	afbf001c 	sw	ra,28(sp)
9d0048a4:	afbe0018 	sw	s8,24(sp)
9d0048a8:	03a0f021 	move	s8,sp
9d0048ac:	afc40020 	sw	a0,32(s8)
9d0048b0:	afc50024 	sw	a1,36(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d0048b4:	8fc20020 	lw	v0,32(s8)
9d0048b8:	8c420008 	lw	v0,8(v0)
9d0048bc:	afc20010 	sw	v0,16(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    if (pData->Modes.nProgrammerMode != CUtPepLogicProgrammerReadMode)
9d0048c0:	8fc20010 	lw	v0,16(s8)
9d0048c4:	8c430008 	lw	v1,8(v0)
9d0048c8:	24020002 	li	v0,2
9d0048cc:	10620004 	beq	v1,v0,9d0048e0 <UtPepLogicSetOutputEnable+0x44>
9d0048d0:	00000000 	nop
#if defined(ENABLE_LOGGING) 
        pLogicData->pLogFunc("UtPepLogicSetOutputEnable leaving.  (Not in programmer read mode)  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif

        return FALSE;
9d0048d4:	00001021 	move	v0,zero
9d0048d8:	0b40126d 	j	9d0049b4 <UtPepLogicSetOutputEnable+0x118>
9d0048dc:	00000000 	nop
    }

	bOutputEnableChanged = (pData->nLastOutputEnable != nOutputEnable);
9d0048e0:	8fc20010 	lw	v0,16(s8)
9d0048e4:	8c430004 	lw	v1,4(v0)
9d0048e8:	8fc20024 	lw	v0,36(s8)
9d0048ec:	00621026 	xor	v0,v1,v0
9d0048f0:	0002102b 	sltu	v0,zero,v0
9d0048f4:	a3c20014 	sb	v0,20(s8)
		pLogicData->pLogFunc("UtPepLogicSetOutputEnable - Output Enable state not being changed.  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif
	}

	bResult = lWritePortData(pLogicData,
9d0048f8:	8fc20024 	lw	v0,36(s8)
9d0048fc:	10400004 	beqz	v0,9d004910 <UtPepLogicSetOutputEnable+0x74>
9d004900:	00000000 	nop
9d004904:	24030003 	li	v1,3
9d004908:	0b401245 	j	9d004914 <UtPepLogicSetOutputEnable+0x78>
9d00490c:	00000000 	nop
9d004910:	24030002 	li	v1,2
                             MEnableTriggerProgramPulse(nOutputEnable) |
                                 MEnableResetProgramPulse(TRUE) |
                                 MSelectVccMode(pData->Modes.nVccMode) |
9d004914:	8fc20010 	lw	v0,16(s8)
9d004918:	8c44000c 	lw	a0,12(v0)
		pLogicData->pLogFunc("UtPepLogicSetOutputEnable - Output Enable state not being changed.  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif
	}

	bResult = lWritePortData(pLogicData,
9d00491c:	24020001 	li	v0,1
9d004920:	14820004 	bne	a0,v0,9d004934 <UtPepLogicSetOutputEnable+0x98>
9d004924:	00000000 	nop
9d004928:	00001021 	move	v0,zero
9d00492c:	0b40124e 	j	9d004938 <UtPepLogicSetOutputEnable+0x9c>
9d004930:	00000000 	nop
9d004934:	24020008 	li	v0,8
9d004938:	00621025 	or	v0,v1,v0
9d00493c:	7c021420 	seb	v0,v0
9d004940:	304200ff 	andi	v0,v0,0xff
9d004944:	8fc40020 	lw	a0,32(s8)
9d004948:	00402821 	move	a1,v0
9d00494c:	24060007 	li	a2,7
9d004950:	0f400d17 	jal	9d00345c <USBCtrlEPAllowDataStage+0x218c>
9d004954:	00000000 	nop
9d004958:	a3c20015 	sb	v0,21(s8)
                                 MEnableResetProgramPulse(TRUE) |
                                 MSelectVccMode(pData->Modes.nVccMode) |
                                 MEnableVpp(FALSE),
                             CUnit7_Programmer);

	if (bResult)
9d00495c:	93c20015 	lbu	v0,21(s8)
9d004960:	10400004 	beqz	v0,9d004974 <UtPepLogicSetOutputEnable+0xd8>
9d004964:	00000000 	nop
	{
		pData->nLastOutputEnable = nOutputEnable;
9d004968:	8fc20010 	lw	v0,16(s8)
9d00496c:	8fc30024 	lw	v1,36(s8)
9d004970:	ac430004 	sw	v1,4(v0)
	}

	if (bOutputEnableChanged && bResult && pData->DelaySettings.nOutputEnableNanoSeconds > 0)
9d004974:	93c20014 	lbu	v0,20(s8)
9d004978:	1040000d 	beqz	v0,9d0049b0 <UtPepLogicSetOutputEnable+0x114>
9d00497c:	00000000 	nop
9d004980:	93c20015 	lbu	v0,21(s8)
9d004984:	1040000a 	beqz	v0,9d0049b0 <UtPepLogicSetOutputEnable+0x114>
9d004988:	00000000 	nop
9d00498c:	8fc20010 	lw	v0,16(s8)
9d004990:	8c42001c 	lw	v0,28(v0)
9d004994:	10400006 	beqz	v0,9d0049b0 <UtPepLogicSetOutputEnable+0x114>
9d004998:	00000000 	nop
#if defined(ENABLE_LOGGING) 
		pLogicData->pLogFunc("UtPepLogicSetOutputEnable - Output Enable Delay detected.  (Thread: 0x%p)\n",
			                 MCurrentThreadId());
#endif

		if (!UtSleep(pData->DelaySettings.nOutputEnableNanoSeconds))
9d00499c:	8fc20010 	lw	v0,16(s8)
9d0049a0:	8c42001c 	lw	v0,28(v0)
9d0049a4:	00402021 	move	a0,v0
9d0049a8:	0f401c68 	jal	9d0071a0 <UtSleep>
9d0049ac:	00000000 	nop
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("UtPepLogicSetOutputEnable leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

	return bResult;
9d0049b0:	93c20015 	lbu	v0,21(s8)
}
9d0049b4:	03c0e821 	move	sp,s8
9d0049b8:	8fbf001c 	lw	ra,28(sp)
9d0049bc:	8fbe0018 	lw	s8,24(sp)
9d0049c0:	27bd0020 	addiu	sp,sp,32
9d0049c4:	03e00008 	jr	ra
9d0049c8:	00000000 	nop

9d0049cc <UtPepLogicReset>:

_IRQL_requires_max_(PASSIVE_LEVEL)
BOOLEAN TUTPEPLOGICAPI UtPepLogicReset(
  _In_ TUtPepLogicData* pLogicData)
{
9d0049cc:	27bdffe0 	addiu	sp,sp,-32
9d0049d0:	afbf001c 	sw	ra,28(sp)
9d0049d4:	afbe0018 	sw	s8,24(sp)
9d0049d8:	03a0f021 	move	s8,sp
9d0049dc:	afc40020 	sw	a0,32(s8)
    BOOLEAN bResult = FALSE;
9d0049e0:	a3c00010 	sb	zero,16(s8)
    TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d0049e4:	8fc20020 	lw	v0,32(s8)
9d0049e8:	8c420008 	lw	v0,8(v0)
9d0049ec:	afc20014 	sw	v0,20(s8)

#if defined(BUILD_DRIVER_LIB)
    PAGED_CODE()
#endif

    if (pData->Modes.nProgrammerMode != CUtPepLogicProgrammerNoneMode)
9d0049f0:	8fc20014 	lw	v0,20(s8)
9d0049f4:	8c430008 	lw	v1,8(v0)
9d0049f8:	24020001 	li	v0,1
9d0049fc:	1062001f 	beq	v1,v0,9d004a7c <UtPepLogicReset+0xb0>
9d004a00:	00000000 	nop
    {
        if (lInitModes(pData) &&
9d004a04:	8fc40014 	lw	a0,20(s8)
9d004a08:	0f400ff9 	jal	9d003fe4 <USBCtrlEPAllowDataStage+0x2d14>
9d004a0c:	00000000 	nop
9d004a10:	1040001c 	beqz	v0,9d004a84 <UtPepLogicReset+0xb8>
9d004a14:	00000000 	nop
			lInitDelaySettings(pData) &&
9d004a18:	8fc40014 	lw	a0,20(s8)
9d004a1c:	0f40100f 	jal	9d00403c <USBCtrlEPAllowDataStage+0x2d6c>
9d004a20:	00000000 	nop
    PAGED_CODE()
#endif

    if (pData->Modes.nProgrammerMode != CUtPepLogicProgrammerNoneMode)
    {
        if (lInitModes(pData) &&
9d004a24:	10400017 	beqz	v0,9d004a84 <UtPepLogicReset+0xb8>
9d004a28:	00000000 	nop
			lInitDelaySettings(pData) &&
            lResetProgrammerState(pLogicData) &&
9d004a2c:	8fc40020 	lw	a0,32(s8)
9d004a30:	0f400eff 	jal	9d003bfc <USBCtrlEPAllowDataStage+0x292c>
9d004a34:	00000000 	nop
#endif

    if (pData->Modes.nProgrammerMode != CUtPepLogicProgrammerNoneMode)
    {
        if (lInitModes(pData) &&
			lInitDelaySettings(pData) &&
9d004a38:	10400012 	beqz	v0,9d004a84 <UtPepLogicReset+0xb8>
9d004a3c:	00000000 	nop
            lResetProgrammerState(pLogicData) &&
            lSetProgrammerAddress(pLogicData, 0) &&
9d004a40:	8fc40020 	lw	a0,32(s8)
9d004a44:	00002821 	move	a1,zero
9d004a48:	0f400dc4 	jal	9d003710 <USBCtrlEPAllowDataStage+0x2440>
9d004a4c:	00000000 	nop

    if (pData->Modes.nProgrammerMode != CUtPepLogicProgrammerNoneMode)
    {
        if (lInitModes(pData) &&
			lInitDelaySettings(pData) &&
            lResetProgrammerState(pLogicData) &&
9d004a50:	1040000c 	beqz	v0,9d004a84 <UtPepLogicReset+0xb8>
9d004a54:	00000000 	nop
            lSetProgrammerAddress(pLogicData, 0) &&
            lSetProgrammerVppMode(pLogicData))
9d004a58:	8fc40020 	lw	a0,32(s8)
9d004a5c:	0f400e8e 	jal	9d003a38 <USBCtrlEPAllowDataStage+0x2768>
9d004a60:	00000000 	nop
    if (pData->Modes.nProgrammerMode != CUtPepLogicProgrammerNoneMode)
    {
        if (lInitModes(pData) &&
			lInitDelaySettings(pData) &&
            lResetProgrammerState(pLogicData) &&
            lSetProgrammerAddress(pLogicData, 0) &&
9d004a64:	10400007 	beqz	v0,9d004a84 <UtPepLogicReset+0xb8>
9d004a68:	00000000 	nop
            lSetProgrammerVppMode(pLogicData))
        {
            bResult = TRUE;
9d004a6c:	24020001 	li	v0,1
9d004a70:	a3c20010 	sb	v0,16(s8)
9d004a74:	0b4012a1 	j	9d004a84 <UtPepLogicReset+0xb8>
9d004a78:	00000000 	nop
        }
    }
    else
    {
        bResult = TRUE;
9d004a7c:	24020001 	li	v0,1
9d004a80:	a3c20010 	sb	v0,16(s8)
    }

    if (bResult)
9d004a84:	93c20010 	lbu	v0,16(s8)
9d004a88:	10400004 	beqz	v0,9d004a9c <UtPepLogicReset+0xd0>
9d004a8c:	00000000 	nop
    {
        pData->nLastAddress = 0xFFFFFFFF;
9d004a90:	8fc20014 	lw	v0,20(s8)
9d004a94:	2403ffff 	li	v1,-1
9d004a98:	ac430000 	sw	v1,0(v0)
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("UtPepLogicReset leaving.  (Thread: 0x%p)\n",
		                 MCurrentThreadId());
#endif

    return bResult;
9d004a9c:	93c20010 	lbu	v0,16(s8)
}
9d004aa0:	03c0e821 	move	sp,s8
9d004aa4:	8fbf001c 	lw	ra,28(sp)
9d004aa8:	8fbe0018 	lw	s8,24(sp)
9d004aac:	27bd0020 	addiu	sp,sp,32
9d004ab0:	03e00008 	jr	ra
9d004ab4:	00000000 	nop

9d004ab8 <UtPepLogicSetDelays>:
_IRQL_requires_max_(PASSIVE_LEVEL)
BOOLEAN TUTPEPLOGICAPI UtPepLogicSetDelays(
  _In_ TUtPepLogicData* pLogicData,
  _In_ UINT32 nChipEnableNanoSeconds,
  _In_ UINT32 nOutputEnableNanoSeconds)
{
9d004ab8:	27bdfff0 	addiu	sp,sp,-16
9d004abc:	afbe000c 	sw	s8,12(sp)
9d004ac0:	03a0f021 	move	s8,sp
9d004ac4:	afc40010 	sw	a0,16(s8)
9d004ac8:	afc50014 	sw	a1,20(s8)
9d004acc:	afc60018 	sw	a2,24(s8)
	BOOLEAN bResult = FALSE;
9d004ad0:	a3c00000 	sb	zero,0(s8)
	TPepInternalLogicData* pData = (TPepInternalLogicData*)pLogicData->pvLogicContext;
9d004ad4:	8fc20010 	lw	v0,16(s8)
9d004ad8:	8c420008 	lw	v0,8(v0)
9d004adc:	afc20004 	sw	v0,4(s8)

#if defined(BUILD_DRIVER_LIB)
	PAGED_CODE()
#endif

	if (pData->Modes.nProgrammerMode == CUtPepLogicProgrammerNoneMode)
9d004ae0:	8fc20004 	lw	v0,4(s8)
9d004ae4:	8c430008 	lw	v1,8(v0)
9d004ae8:	24020001 	li	v0,1
9d004aec:	14620009 	bne	v1,v0,9d004b14 <UtPepLogicSetDelays+0x5c>
9d004af0:	00000000 	nop
	{
		pData->DelaySettings.nChipEnableNanoSeconds = nChipEnableNanoSeconds;
9d004af4:	8fc20004 	lw	v0,4(s8)
9d004af8:	8fc30014 	lw	v1,20(s8)
9d004afc:	ac430018 	sw	v1,24(v0)
		pData->DelaySettings.nOutputEnableNanoSeconds = nOutputEnableNanoSeconds;
9d004b00:	8fc20004 	lw	v0,4(s8)
9d004b04:	8fc30018 	lw	v1,24(s8)
9d004b08:	ac43001c 	sw	v1,28(v0)

		bResult = TRUE;
9d004b0c:	24020001 	li	v0,1
9d004b10:	a3c20000 	sb	v0,0(s8)
#if defined(ENABLE_LOGGING) 
	pLogicData->pLogFunc("UtPepLogicSetDelays leaving  (Thread: 0x%p).\n",
		                 MCurrentThreadId());
#endif

	return bResult;
9d004b14:	93c20000 	lbu	v0,0(s8)
}
9d004b18:	03c0e821 	move	sp,s8
9d004b1c:	8fbe000c 	lw	s8,12(sp)
9d004b20:	27bd0010 	addiu	sp,sp,16
9d004b24:	03e00008 	jr	ra
9d004b28:	00000000 	nop

/* Local Functions */

static BOOLEAN TUTPEPLOGICAPI lPepLogicReadBitPort(
  _Out_ PBOOLEAN pbValue)
{
9d004b2c:	27bdfff8 	addiu	sp,sp,-8
9d004b30:	afbe0004 	sw	s8,4(sp)
9d004b34:	03a0f021 	move	s8,sp
9d004b38:	afc40008 	sw	a0,8(s8)
    // Must invert the bit to match how the Busy bit of the parallel port works

#if defined(__32MX250F128B__)
    *pbValue = PORTBbits.RB4 ? FALSE : TRUE;
9d004b3c:	3c02bf88 	lui	v0,0xbf88
9d004b40:	8c426120 	lw	v0,24864(v0)
9d004b44:	30420010 	andi	v0,v0,0x10
9d004b48:	2c420001 	sltiu	v0,v0,1
9d004b4c:	304300ff 	andi	v1,v0,0xff
9d004b50:	8fc20008 	lw	v0,8(s8)
9d004b54:	a0430000 	sb	v1,0(v0)
    *pbValue = PORTBbits.RB4 ? FALSE : TRUE;
#else
#error Unknown device configuration
#endif

    return TRUE;
9d004b58:	24020001 	li	v0,1
}
9d004b5c:	03c0e821 	move	sp,s8
9d004b60:	8fbe0004 	lw	s8,4(sp)
9d004b64:	27bd0008 	addiu	sp,sp,8
9d004b68:	03e00008 	jr	ra
9d004b6c:	00000000 	nop
    
static BOOLEAN TUTPEPLOGICAPI lPepLogicWritePort(
  _In_ PUINT8 pnData,
  _In_ UINT32 nDataLen,
  _In_ UINT32 nWaitNanoSeconds)
{
9d004b70:	27bdffe0 	addiu	sp,sp,-32
9d004b74:	afbf001c 	sw	ra,28(sp)
9d004b78:	afbe0018 	sw	s8,24(sp)
9d004b7c:	03a0f021 	move	s8,sp
9d004b80:	afc40020 	sw	a0,32(s8)
9d004b84:	afc50024 	sw	a1,36(s8)
9d004b88:	afc60028 	sw	a2,40(s8)
    UINT8 nDataIndex;
   
    for (nDataIndex = 0; nDataIndex < nDataLen; ++nDataIndex)
9d004b8c:	0b401341 	j	9d004d04 <UtPepLogicSetDelays+0x24c>
9d004b90:	a3c00010 	sb	zero,16(s8)
    {
#if defined(__32MX250F128B__)
#if defined(DISABLE_PARALLEL_PORT)
        LATA = 0x00;
9d004b94:	3c02bf88 	lui	v0,0xbf88
9d004b98:	ac406030 	sw	zero,24624(v0)
        LATB = 0x00;
9d004b9c:	3c02bf88 	lui	v0,0xbf88
9d004ba0:	ac406130 	sw	zero,24880(v0)
        
        // D0 - D2
        LATB = pnData[nDataIndex] & 0x0007;
9d004ba4:	93c20010 	lbu	v0,16(s8)
9d004ba8:	8fc30020 	lw	v1,32(s8)
9d004bac:	00621021 	addu	v0,v1,v0
9d004bb0:	90420000 	lbu	v0,0(v0)
9d004bb4:	30430007 	andi	v1,v0,0x7
9d004bb8:	3c02bf88 	lui	v0,0xbf88
9d004bbc:	ac436130 	sw	v1,24880(v0)
        
        // D3 
        if (pnData[nDataIndex] & 0x0008)
9d004bc0:	93c20010 	lbu	v0,16(s8)
9d004bc4:	8fc30020 	lw	v1,32(s8)
9d004bc8:	00621021 	addu	v0,v1,v0
9d004bcc:	90420000 	lbu	v0,0(v0)
9d004bd0:	30420008 	andi	v0,v0,0x8
9d004bd4:	10400006 	beqz	v0,9d004bf0 <UtPepLogicSetDelays+0x138>
9d004bd8:	00000000 	nop
        {
            LATBbits.LATB9 = 0x01;
9d004bdc:	3c03bf88 	lui	v1,0xbf88
9d004be0:	8c626130 	lw	v0,24880(v1)
9d004be4:	24040001 	li	a0,1
9d004be8:	7c824a44 	ins	v0,a0,0x9,0x1
9d004bec:	ac626130 	sw	v0,24880(v1)
        }

        // D4
        if (pnData[nDataIndex] & 0x0010)
9d004bf0:	93c20010 	lbu	v0,16(s8)
9d004bf4:	8fc30020 	lw	v1,32(s8)
9d004bf8:	00621021 	addu	v0,v1,v0
9d004bfc:	90420000 	lbu	v0,0(v0)
9d004c00:	30420010 	andi	v0,v0,0x10
9d004c04:	10400006 	beqz	v0,9d004c20 <UtPepLogicSetDelays+0x168>
9d004c08:	00000000 	nop
        {
            LATBbits.LATB8 = 0x01;
9d004c0c:	3c03bf88 	lui	v1,0xbf88
9d004c10:	8c626130 	lw	v0,24880(v1)
9d004c14:	24040001 	li	a0,1
9d004c18:	7c824204 	ins	v0,a0,0x8,0x1
9d004c1c:	ac626130 	sw	v0,24880(v1)
        }

        // D5
        if (pnData[nDataIndex] & 0x0020)
9d004c20:	93c20010 	lbu	v0,16(s8)
9d004c24:	8fc30020 	lw	v1,32(s8)
9d004c28:	00621021 	addu	v0,v1,v0
9d004c2c:	90420000 	lbu	v0,0(v0)
9d004c30:	30420020 	andi	v0,v0,0x20
9d004c34:	10400006 	beqz	v0,9d004c50 <UtPepLogicSetDelays+0x198>
9d004c38:	00000000 	nop
        {
            LATBbits.LATB7 = 0x01;
9d004c3c:	3c03bf88 	lui	v1,0xbf88
9d004c40:	8c626130 	lw	v0,24880(v1)
9d004c44:	24040001 	li	a0,1
9d004c48:	7c8239c4 	ins	v0,a0,0x7,0x1
9d004c4c:	ac626130 	sw	v0,24880(v1)
        }
        
        // D6
        if (pnData[nDataIndex] & 0x0040) {
9d004c50:	93c20010 	lbu	v0,16(s8)
9d004c54:	8fc30020 	lw	v1,32(s8)
9d004c58:	00621021 	addu	v0,v1,v0
9d004c5c:	90420000 	lbu	v0,0(v0)
9d004c60:	30420040 	andi	v0,v0,0x40
9d004c64:	10400006 	beqz	v0,9d004c80 <UtPepLogicSetDelays+0x1c8>
9d004c68:	00000000 	nop
            LATAbits.LATA1 = 0x01;
9d004c6c:	3c03bf88 	lui	v1,0xbf88
9d004c70:	8c626030 	lw	v0,24624(v1)
9d004c74:	24040001 	li	a0,1
9d004c78:	7c820844 	ins	v0,a0,0x1,0x1
9d004c7c:	ac626030 	sw	v0,24624(v1)
        }
        
        // D7
        if (pnData[nDataIndex] & 0x0080) {
9d004c80:	93c20010 	lbu	v0,16(s8)
9d004c84:	8fc30020 	lw	v1,32(s8)
9d004c88:	00621021 	addu	v0,v1,v0
9d004c8c:	90420000 	lbu	v0,0(v0)
9d004c90:	7c021420 	seb	v0,v0
9d004c94:	04410006 	bgez	v0,9d004cb0 <UtPepLogicSetDelays+0x1f8>
9d004c98:	00000000 	nop
            LATAbits.LATA0 = 0x01;
9d004c9c:	3c03bf88 	lui	v1,0xbf88
9d004ca0:	8c626030 	lw	v0,24624(v1)
9d004ca4:	24040001 	li	a0,1
9d004ca8:	7c820004 	ins	v0,a0,0x0,0x1
9d004cac:	ac626030 	sw	v0,24624(v1)
        }
        
        // PMWR (Strobe clock pin of 74LS374, data loaded on the rising edge of the clock)
        Nop();
9d004cb0:	00000040 	ssnop
        Nop();
9d004cb4:	00000040 	ssnop
        Nop();
9d004cb8:	00000040 	ssnop
        Nop();
9d004cbc:	00000040 	ssnop

        LATBbits.LATB3 = 0x01;
9d004cc0:	3c03bf88 	lui	v1,0xbf88
9d004cc4:	8c626130 	lw	v0,24880(v1)
9d004cc8:	24040001 	li	a0,1
9d004ccc:	7c8218c4 	ins	v0,a0,0x3,0x1
9d004cd0:	ac626130 	sw	v0,24880(v1)

        // Need a max of 28 ns for the data to be loaded into the LS374
        
        Nop();
9d004cd4:	00000040 	ssnop
        Nop();
9d004cd8:	00000040 	ssnop
        Nop();
9d004cdc:	00000040 	ssnop

        LATBbits.LATB3 = 0x00;
9d004ce0:	3c03bf88 	lui	v1,0xbf88
9d004ce4:	8c626130 	lw	v0,24880(v1)
9d004ce8:	7c0218c4 	ins	v0,zero,0x3,0x1
9d004cec:	ac626130 	sw	v0,24880(v1)
#endif
#else
#error Unknown device configuration
#endif

        UtSleep(CDeviceStateUpdatedNanoSeconds);
9d004cf0:	0f401c68 	jal	9d0071a0 <UtSleep>
9d004cf4:	24040096 	li	a0,150
  _In_ UINT32 nDataLen,
  _In_ UINT32 nWaitNanoSeconds)
{
    UINT8 nDataIndex;
   
    for (nDataIndex = 0; nDataIndex < nDataLen; ++nDataIndex)
9d004cf8:	93c20010 	lbu	v0,16(s8)
9d004cfc:	24420001 	addiu	v0,v0,1
9d004d00:	a3c20010 	sb	v0,16(s8)
9d004d04:	93c30010 	lbu	v1,16(s8)
9d004d08:	8fc20024 	lw	v0,36(s8)
9d004d0c:	0062102b 	sltu	v0,v1,v0
9d004d10:	1440ffa0 	bnez	v0,9d004b94 <UtPepLogicSetDelays+0xdc>
9d004d14:	00000000 	nop
#endif

        UtSleep(CDeviceStateUpdatedNanoSeconds);
    }
            
    return TRUE;
9d004d18:	24020001 	li	v0,1
}
9d004d1c:	03c0e821 	move	sp,s8
9d004d20:	8fbf001c 	lw	ra,28(sp)
9d004d24:	8fbe0018 	lw	s8,24(sp)
9d004d28:	03e00008 	jr	ra
9d004d2c:	27bd0020 	addiu	sp,sp,32
 
static void lProcessVersionCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d004d30:	27bdffe0 	addiu	sp,sp,-32
9d004d34:	afbf001c 	sw	ra,28(sp)
9d004d38:	afbe0018 	sw	s8,24(sp)
9d004d3c:	03a0f021 	move	s8,sp
9d004d40:	afc40020 	sw	a0,32(s8)
9d004d44:	afc50024 	sw	a1,36(s8)
    UINT8 nIndex;

    memset(pResponseData->Data.Version, 0x00, sizeof(pResponseData->Data.Version));
9d004d48:	8fc20024 	lw	v0,36(s8)
9d004d4c:	24420002 	addiu	v0,v0,2
9d004d50:	00402021 	move	a0,v0
9d004d54:	00002821 	move	a1,zero
9d004d58:	2406003e 	li	a2,62
9d004d5c:	0f401c3e 	jal	9d0070f8 <memset>
9d004d60:	00000000 	nop
 
    for (nIndex = 0; nIndex < MArrayLen(l_nVersion); ++nIndex)
9d004d64:	a3c00010 	sb	zero,16(s8)
9d004d68:	0b401377 	j	9d004ddc <UtPepLogicSetDelays+0x324>
9d004d6c:	00000000 	nop
    {
        if (nIndex < MArrayLen(pResponseData->Data.Version))
9d004d70:	93c20010 	lbu	v0,16(s8)
9d004d74:	2c42001f 	sltiu	v0,v0,31
9d004d78:	10400015 	beqz	v0,9d004dd0 <UtPepLogicSetDelays+0x318>
9d004d7c:	00000000 	nop
        {
            pResponseData->Data.Version[nIndex] = l_nVersion[nIndex];
9d004d80:	93c20010 	lbu	v0,16(s8)
9d004d84:	93c40010 	lbu	a0,16(s8)
9d004d88:	3c03a000 	lui	v1,0xa000
9d004d8c:	24630108 	addiu	v1,v1,264
9d004d90:	00831821 	addu	v1,a0,v1
9d004d94:	90630000 	lbu	v1,0(v1)
9d004d98:	8fc40024 	lw	a0,36(s8)
9d004d9c:	00021040 	sll	v0,v0,0x1
9d004da0:	00821021 	addu	v0,a0,v0
9d004da4:	306400ff 	andi	a0,v1,0xff
9d004da8:	90450002 	lbu	a1,2(v0)
9d004dac:	30a50000 	andi	a1,a1,0x0
9d004db0:	00a42025 	or	a0,a1,a0
9d004db4:	a0440002 	sb	a0,2(v0)
9d004db8:	00031a02 	srl	v1,v1,0x8
9d004dbc:	3063ffff 	andi	v1,v1,0xffff
9d004dc0:	90440003 	lbu	a0,3(v0)
9d004dc4:	30840000 	andi	a0,a0,0x0
9d004dc8:	00831825 	or	v1,a0,v1
9d004dcc:	a0430003 	sb	v1,3(v0)
{
    UINT8 nIndex;

    memset(pResponseData->Data.Version, 0x00, sizeof(pResponseData->Data.Version));
 
    for (nIndex = 0; nIndex < MArrayLen(l_nVersion); ++nIndex)
9d004dd0:	93c20010 	lbu	v0,16(s8)
9d004dd4:	24420001 	addiu	v0,v0,1
9d004dd8:	a3c20010 	sb	v0,16(s8)
9d004ddc:	93c20010 	lbu	v0,16(s8)
9d004de0:	2c420012 	sltiu	v0,v0,18
9d004de4:	1440ffe2 	bnez	v0,9d004d70 <UtPepLogicSetDelays+0x2b8>
9d004de8:	00000000 	nop
        {
            pResponseData->Data.Version[nIndex] = l_nVersion[nIndex];
        }
    }

    pResponseData->ErrorCode = CPepErrorSuccess;
9d004dec:	8fc20024 	lw	v0,36(s8)
9d004df0:	a0400001 	sb	zero,1(v0)
}
9d004df4:	03c0e821 	move	sp,s8
9d004df8:	8fbf001c 	lw	ra,28(sp)
9d004dfc:	8fbe0018 	lw	s8,24(sp)
9d004e00:	27bd0020 	addiu	sp,sp,32
9d004e04:	03e00008 	jr	ra
9d004e08:	00000000 	nop

static void lProcessResetCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d004e0c:	27bdffe8 	addiu	sp,sp,-24
9d004e10:	afbf0014 	sw	ra,20(sp)
9d004e14:	afbe0010 	sw	s8,16(sp)
9d004e18:	03a0f021 	move	s8,sp
9d004e1c:	afc40018 	sw	a0,24(s8)
9d004e20:	afc5001c 	sw	a1,28(s8)
    pResponseData->ErrorCode = UtPepLogicReset(&l_PepLogicData) ? CPepErrorSuccess : CPepErrorFailed;
9d004e24:	3c02a000 	lui	v0,0xa000
9d004e28:	2444011c 	addiu	a0,v0,284
9d004e2c:	0f401273 	jal	9d0049cc <UtPepLogicReset>
9d004e30:	00000000 	nop
9d004e34:	10400004 	beqz	v0,9d004e48 <UtPepLogicSetDelays+0x390>
9d004e38:	00000000 	nop
9d004e3c:	00001021 	move	v0,zero
9d004e40:	0b401393 	j	9d004e4c <UtPepLogicSetDelays+0x394>
9d004e44:	00000000 	nop
9d004e48:	24020002 	li	v0,2
9d004e4c:	8fc3001c 	lw	v1,28(s8)
9d004e50:	a0620001 	sb	v0,1(v1)
}
9d004e54:	03c0e821 	move	sp,s8
9d004e58:	8fbf0014 	lw	ra,20(sp)
9d004e5c:	8fbe0010 	lw	s8,16(sp)
9d004e60:	27bd0018 	addiu	sp,sp,24
9d004e64:	03e00008 	jr	ra
9d004e68:	00000000 	nop

static void lProcessSetProgrammerModeCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d004e6c:	27bdffe8 	addiu	sp,sp,-24
9d004e70:	afbf0014 	sw	ra,20(sp)
9d004e74:	afbe0010 	sw	s8,16(sp)
9d004e78:	03a0f021 	move	s8,sp
9d004e7c:	afc40018 	sw	a0,24(s8)
9d004e80:	afc5001c 	sw	a1,28(s8)
    pResponseData->ErrorCode = UtPepLogicSetProgrammerMode(&l_PepLogicData,
                                                           pCommandData->Data.nProgrammerMode) ? CPepErrorSuccess : CPepErrorFailed;
9d004e84:	8fc20018 	lw	v0,24(s8)

static void lProcessSetProgrammerModeCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
    pResponseData->ErrorCode = UtPepLogicSetProgrammerMode(&l_PepLogicData,
9d004e88:	88430004 	lwl	v1,4(v0)
9d004e8c:	00602021 	move	a0,v1
9d004e90:	98440001 	lwr	a0,1(v0)
9d004e94:	00801021 	move	v0,a0
9d004e98:	3c03a000 	lui	v1,0xa000
9d004e9c:	2464011c 	addiu	a0,v1,284
9d004ea0:	00402821 	move	a1,v0
9d004ea4:	0f401040 	jal	9d004100 <UtPepLogicSetProgrammerMode>
9d004ea8:	00000000 	nop
9d004eac:	10400004 	beqz	v0,9d004ec0 <UtPepLogicSetDelays+0x408>
9d004eb0:	00000000 	nop
9d004eb4:	00001021 	move	v0,zero
9d004eb8:	0b4013b1 	j	9d004ec4 <UtPepLogicSetDelays+0x40c>
9d004ebc:	00000000 	nop
9d004ec0:	24020002 	li	v0,2
9d004ec4:	8fc3001c 	lw	v1,28(s8)
9d004ec8:	a0620001 	sb	v0,1(v1)
                                                           pCommandData->Data.nProgrammerMode) ? CPepErrorSuccess : CPepErrorFailed;
}
9d004ecc:	03c0e821 	move	sp,s8
9d004ed0:	8fbf0014 	lw	ra,20(sp)
9d004ed4:	8fbe0010 	lw	s8,16(sp)
9d004ed8:	27bd0018 	addiu	sp,sp,24
9d004edc:	03e00008 	jr	ra
9d004ee0:	00000000 	nop

static void lProcessSetVccModeCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d004ee4:	27bdffe8 	addiu	sp,sp,-24
9d004ee8:	afbf0014 	sw	ra,20(sp)
9d004eec:	afbe0010 	sw	s8,16(sp)
9d004ef0:	03a0f021 	move	s8,sp
9d004ef4:	afc40018 	sw	a0,24(s8)
9d004ef8:	afc5001c 	sw	a1,28(s8)
    pResponseData->ErrorCode = UtPepLogicSetVccMode(&l_PepLogicData,
                                                    pCommandData->Data.nVccMode) ? CPepErrorSuccess : CPepErrorFailed;
9d004efc:	8fc20018 	lw	v0,24(s8)

static void lProcessSetVccModeCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
    pResponseData->ErrorCode = UtPepLogicSetVccMode(&l_PepLogicData,
9d004f00:	88430004 	lwl	v1,4(v0)
9d004f04:	00602021 	move	a0,v1
9d004f08:	98440001 	lwr	a0,1(v0)
9d004f0c:	00801021 	move	v0,a0
9d004f10:	3c03a000 	lui	v1,0xa000
9d004f14:	2464011c 	addiu	a0,v1,284
9d004f18:	00402821 	move	a1,v0
9d004f1c:	0f401089 	jal	9d004224 <UtPepLogicSetVccMode>
9d004f20:	00000000 	nop
9d004f24:	10400004 	beqz	v0,9d004f38 <UtPepLogicSetDelays+0x480>
9d004f28:	00000000 	nop
9d004f2c:	00001021 	move	v0,zero
9d004f30:	0b4013cf 	j	9d004f3c <UtPepLogicSetDelays+0x484>
9d004f34:	00000000 	nop
9d004f38:	24020002 	li	v0,2
9d004f3c:	8fc3001c 	lw	v1,28(s8)
9d004f40:	a0620001 	sb	v0,1(v1)
                                                    pCommandData->Data.nVccMode) ? CPepErrorSuccess : CPepErrorFailed;
}
9d004f44:	03c0e821 	move	sp,s8
9d004f48:	8fbf0014 	lw	ra,20(sp)
9d004f4c:	8fbe0010 	lw	s8,16(sp)
9d004f50:	27bd0018 	addiu	sp,sp,24
9d004f54:	03e00008 	jr	ra
9d004f58:	00000000 	nop

static void lProcessSetPinPulseModeCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d004f5c:	27bdffe8 	addiu	sp,sp,-24
9d004f60:	afbf0014 	sw	ra,20(sp)
9d004f64:	afbe0010 	sw	s8,16(sp)
9d004f68:	03a0f021 	move	s8,sp
9d004f6c:	afc40018 	sw	a0,24(s8)
9d004f70:	afc5001c 	sw	a1,28(s8)
    pResponseData->ErrorCode = UtPepLogicSetPinPulseMode(&l_PepLogicData,
                                                         pCommandData->Data.nPinPulseMode) ? CPepErrorSuccess : CPepErrorFailed;
9d004f74:	8fc20018 	lw	v0,24(s8)

static void lProcessSetPinPulseModeCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
    pResponseData->ErrorCode = UtPepLogicSetPinPulseMode(&l_PepLogicData,
9d004f78:	88430004 	lwl	v1,4(v0)
9d004f7c:	00602021 	move	a0,v1
9d004f80:	98440001 	lwr	a0,1(v0)
9d004f84:	00801021 	move	v0,a0
9d004f88:	3c03a000 	lui	v1,0xa000
9d004f8c:	2464011c 	addiu	a0,v1,284
9d004f90:	00402821 	move	a1,v0
9d004f94:	0f4010bd 	jal	9d0042f4 <UtPepLogicSetPinPulseMode>
9d004f98:	00000000 	nop
9d004f9c:	10400004 	beqz	v0,9d004fb0 <UtPepLogicSetDelays+0x4f8>
9d004fa0:	00000000 	nop
9d004fa4:	00001021 	move	v0,zero
9d004fa8:	0b4013ed 	j	9d004fb4 <UtPepLogicSetDelays+0x4fc>
9d004fac:	00000000 	nop
9d004fb0:	24020002 	li	v0,2
9d004fb4:	8fc3001c 	lw	v1,28(s8)
9d004fb8:	a0620001 	sb	v0,1(v1)
                                                         pCommandData->Data.nPinPulseMode) ? CPepErrorSuccess : CPepErrorFailed;
}
9d004fbc:	03c0e821 	move	sp,s8
9d004fc0:	8fbf0014 	lw	ra,20(sp)
9d004fc4:	8fbe0010 	lw	s8,16(sp)
9d004fc8:	27bd0018 	addiu	sp,sp,24
9d004fcc:	03e00008 	jr	ra
9d004fd0:	00000000 	nop

static void lProcessSetVppModeCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d004fd4:	27bdffe8 	addiu	sp,sp,-24
9d004fd8:	afbf0014 	sw	ra,20(sp)
9d004fdc:	afbe0010 	sw	s8,16(sp)
9d004fe0:	03a0f021 	move	s8,sp
9d004fe4:	afc40018 	sw	a0,24(s8)
9d004fe8:	afc5001c 	sw	a1,28(s8)
    pResponseData->ErrorCode = UtPepLogicSetVppMode(&l_PepLogicData,
                                                    pCommandData->Data.nVppMode) ? CPepErrorSuccess : CPepErrorFailed;
9d004fec:	8fc20018 	lw	v0,24(s8)

static void lProcessSetVppModeCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
    pResponseData->ErrorCode = UtPepLogicSetVppMode(&l_PepLogicData,
9d004ff0:	88430004 	lwl	v1,4(v0)
9d004ff4:	00602021 	move	a0,v1
9d004ff8:	98440001 	lwr	a0,1(v0)
9d004ffc:	00801021 	move	v0,a0
9d005000:	3c03a000 	lui	v1,0xa000
9d005004:	2464011c 	addiu	a0,v1,284
9d005008:	00402821 	move	a1,v0
9d00500c:	0f40111a 	jal	9d004468 <UtPepLogicSetVppMode>
9d005010:	00000000 	nop
9d005014:	10400004 	beqz	v0,9d005028 <UtPepLogicSetDelays+0x570>
9d005018:	00000000 	nop
9d00501c:	00001021 	move	v0,zero
9d005020:	0b40140b 	j	9d00502c <UtPepLogicSetDelays+0x574>
9d005024:	00000000 	nop
9d005028:	24020002 	li	v0,2
9d00502c:	8fc3001c 	lw	v1,28(s8)
9d005030:	a0620001 	sb	v0,1(v1)
                                                    pCommandData->Data.nVppMode) ? CPepErrorSuccess : CPepErrorFailed;
}
9d005034:	03c0e821 	move	sp,s8
9d005038:	8fbf0014 	lw	ra,20(sp)
9d00503c:	8fbe0010 	lw	s8,16(sp)
9d005040:	27bd0018 	addiu	sp,sp,24
9d005044:	03e00008 	jr	ra
9d005048:	00000000 	nop

static void lProcessReadDataCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d00504c:	27bdffe0 	addiu	sp,sp,-32
9d005050:	afbf001c 	sw	ra,28(sp)
9d005054:	afbe0018 	sw	s8,24(sp)
9d005058:	03a0f021 	move	s8,sp
9d00505c:	afc40020 	sw	a0,32(s8)
9d005060:	afc50024 	sw	a1,36(s8)
    UINT8 nIndex;

    if (pCommandData->Data.ReadData.nDataLen > MArrayLen(pResponseData->Data.nData))
9d005064:	8fc20020 	lw	v0,32(s8)
9d005068:	90420005 	lbu	v0,5(v0)
9d00506c:	2c42003f 	sltiu	v0,v0,63
9d005070:	14400006 	bnez	v0,9d00508c <UtPepLogicSetDelays+0x5d4>
9d005074:	00000000 	nop
    {
        pResponseData->ErrorCode = CPepErrorInvalidLength;
9d005078:	8fc20024 	lw	v0,36(s8)
9d00507c:	24030003 	li	v1,3
9d005080:	a0430001 	sb	v1,1(v0)
        
        return;
9d005084:	0b40145b 	j	9d00516c <UtPepLogicSetDelays+0x6b4>
9d005088:	00000000 	nop
    }
  
    for (nIndex = 0; nIndex < pCommandData->Data.ReadData.nDataLen; ++nIndex)
9d00508c:	a3c00010 	sb	zero,16(s8)
9d005090:	0b401453 	j	9d00514c <UtPepLogicSetDelays+0x694>
9d005094:	00000000 	nop
    {
        if (!UtPepLogicSetOutputEnable(&l_PepLogicData, FALSE) ||
9d005098:	3c02a000 	lui	v0,0xa000
9d00509c:	2444011c 	addiu	a0,v0,284
9d0050a0:	00002821 	move	a1,zero
9d0050a4:	0f401227 	jal	9d00489c <UtPepLogicSetOutputEnable>
9d0050a8:	00000000 	nop
9d0050ac:	1040001f 	beqz	v0,9d00512c <UtPepLogicSetDelays+0x674>
9d0050b0:	00000000 	nop
            !UtPepLogicSetAddress(&l_PepLogicData,
                                  pCommandData->Data.ReadData.nAddress + nIndex) ||
9d0050b4:	8fc20020 	lw	v0,32(s8)
9d0050b8:	88430004 	lwl	v1,4(v0)
9d0050bc:	98430001 	lwr	v1,1(v0)
    }
  
    for (nIndex = 0; nIndex < pCommandData->Data.ReadData.nDataLen; ++nIndex)
    {
        if (!UtPepLogicSetOutputEnable(&l_PepLogicData, FALSE) ||
            !UtPepLogicSetAddress(&l_PepLogicData,
9d0050c0:	93c20010 	lbu	v0,16(s8)
9d0050c4:	00621021 	addu	v0,v1,v0
9d0050c8:	3c03a000 	lui	v1,0xa000
9d0050cc:	2464011c 	addiu	a0,v1,284
9d0050d0:	00402821 	move	a1,v0
9d0050d4:	0f401151 	jal	9d004544 <UtPepLogicSetAddress>
9d0050d8:	00000000 	nop
        return;
    }
  
    for (nIndex = 0; nIndex < pCommandData->Data.ReadData.nDataLen; ++nIndex)
    {
        if (!UtPepLogicSetOutputEnable(&l_PepLogicData, FALSE) ||
9d0050dc:	10400013 	beqz	v0,9d00512c <UtPepLogicSetDelays+0x674>
9d0050e0:	00000000 	nop
            !UtPepLogicSetAddress(&l_PepLogicData,
                                  pCommandData->Data.ReadData.nAddress + nIndex) ||
            !UtPepLogicSetOutputEnable(&l_PepLogicData, TRUE) ||
9d0050e4:	3c02a000 	lui	v0,0xa000
9d0050e8:	2444011c 	addiu	a0,v0,284
9d0050ec:	24050001 	li	a1,1
9d0050f0:	0f401227 	jal	9d00489c <UtPepLogicSetOutputEnable>
9d0050f4:	00000000 	nop
  
    for (nIndex = 0; nIndex < pCommandData->Data.ReadData.nDataLen; ++nIndex)
    {
        if (!UtPepLogicSetOutputEnable(&l_PepLogicData, FALSE) ||
            !UtPepLogicSetAddress(&l_PepLogicData,
                                  pCommandData->Data.ReadData.nAddress + nIndex) ||
9d0050f8:	1040000c 	beqz	v0,9d00512c <UtPepLogicSetDelays+0x674>
9d0050fc:	00000000 	nop
            !UtPepLogicSetOutputEnable(&l_PepLogicData, TRUE) ||
            !UtPepLogicGetData(&l_PepLogicData,
                               &pResponseData->Data.nData[nIndex]))
9d005100:	8fc20024 	lw	v0,36(s8)
9d005104:	24430002 	addiu	v1,v0,2
    {
        if (!UtPepLogicSetOutputEnable(&l_PepLogicData, FALSE) ||
            !UtPepLogicSetAddress(&l_PepLogicData,
                                  pCommandData->Data.ReadData.nAddress + nIndex) ||
            !UtPepLogicSetOutputEnable(&l_PepLogicData, TRUE) ||
            !UtPepLogicGetData(&l_PepLogicData,
9d005108:	93c20010 	lbu	v0,16(s8)
9d00510c:	00621021 	addu	v0,v1,v0
9d005110:	3c03a000 	lui	v1,0xa000
9d005114:	2464011c 	addiu	a0,v1,284
9d005118:	00402821 	move	a1,v0
9d00511c:	0f40117f 	jal	9d0045fc <UtPepLogicGetData>
9d005120:	00000000 	nop
    for (nIndex = 0; nIndex < pCommandData->Data.ReadData.nDataLen; ++nIndex)
    {
        if (!UtPepLogicSetOutputEnable(&l_PepLogicData, FALSE) ||
            !UtPepLogicSetAddress(&l_PepLogicData,
                                  pCommandData->Data.ReadData.nAddress + nIndex) ||
            !UtPepLogicSetOutputEnable(&l_PepLogicData, TRUE) ||
9d005124:	14400006 	bnez	v0,9d005140 <UtPepLogicSetDelays+0x688>
9d005128:	00000000 	nop
            !UtPepLogicGetData(&l_PepLogicData,
                               &pResponseData->Data.nData[nIndex]))
        {
            pResponseData->ErrorCode = CPepErrorFailed;
9d00512c:	8fc20024 	lw	v0,36(s8)
9d005130:	24030002 	li	v1,2
9d005134:	a0430001 	sb	v1,1(v0)
        
            return;
9d005138:	0b40145b 	j	9d00516c <UtPepLogicSetDelays+0x6b4>
9d00513c:	00000000 	nop
        pResponseData->ErrorCode = CPepErrorInvalidLength;
        
        return;
    }
  
    for (nIndex = 0; nIndex < pCommandData->Data.ReadData.nDataLen; ++nIndex)
9d005140:	93c20010 	lbu	v0,16(s8)
9d005144:	24420001 	addiu	v0,v0,1
9d005148:	a3c20010 	sb	v0,16(s8)
9d00514c:	8fc20020 	lw	v0,32(s8)
9d005150:	90420005 	lbu	v0,5(v0)
9d005154:	93c30010 	lbu	v1,16(s8)
9d005158:	0062102b 	sltu	v0,v1,v0
9d00515c:	1440ffce 	bnez	v0,9d005098 <UtPepLogicSetDelays+0x5e0>
9d005160:	00000000 	nop
        
            return;
        }
    }

    pResponseData->ErrorCode = CPepErrorSuccess;
9d005164:	8fc20024 	lw	v0,36(s8)
9d005168:	a0400001 	sb	zero,1(v0)
}
9d00516c:	03c0e821 	move	sp,s8
9d005170:	8fbf001c 	lw	ra,28(sp)
9d005174:	8fbe0018 	lw	s8,24(sp)
9d005178:	27bd0020 	addiu	sp,sp,32
9d00517c:	03e00008 	jr	ra
9d005180:	00000000 	nop

static void lProcessReadUserDataCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d005184:	27bdffe0 	addiu	sp,sp,-32
9d005188:	afbf001c 	sw	ra,28(sp)
9d00518c:	afbe0018 	sw	s8,24(sp)
9d005190:	03a0f021 	move	s8,sp
9d005194:	afc40020 	sw	a0,32(s8)
9d005198:	afc50024 	sw	a1,36(s8)
    UINT8 nIndex;

    if (pCommandData->Data.ReadUserData.nDataLen > MArrayLen(pCommandData->Data.ReadUserData.Data))
9d00519c:	8fc20020 	lw	v0,32(s8)
9d0051a0:	9042003d 	lbu	v0,61(v0)
9d0051a4:	2c42000b 	sltiu	v0,v0,11
9d0051a8:	14400006 	bnez	v0,9d0051c4 <UtPepLogicSetDelays+0x70c>
9d0051ac:	00000000 	nop
    {
        pResponseData->ErrorCode = CPepErrorInvalidLength;
9d0051b0:	8fc20024 	lw	v0,36(s8)
9d0051b4:	24030003 	li	v1,3
9d0051b8:	a0430001 	sb	v1,1(v0)
        
        return;
9d0051bc:	0b4014bc 	j	9d0052f0 <UtPepLogicSetDelays+0x838>
9d0051c0:	00000000 	nop
    }

    for (nIndex = 0; nIndex < pCommandData->Data.ReadUserData.nDataLen; ++nIndex)
9d0051c4:	a3c00010 	sb	zero,16(s8)
9d0051c8:	0b4014b4 	j	9d0052d0 <UtPepLogicSetDelays+0x818>
9d0051cc:	00000000 	nop
    {
        if (!UtPepLogicSetAddress(&l_PepLogicData,
9d0051d0:	93c20010 	lbu	v0,16(s8)
                                  pCommandData->Data.ReadUserData.Data[nIndex].nAddress) ||
9d0051d4:	8fc40020 	lw	a0,32(s8)
        return;
    }

    for (nIndex = 0; nIndex < pCommandData->Data.ReadUserData.nDataLen; ++nIndex)
    {
        if (!UtPepLogicSetAddress(&l_PepLogicData,
9d0051d8:	00021840 	sll	v1,v0,0x1
9d0051dc:	00031080 	sll	v0,v1,0x2
9d0051e0:	00431023 	subu	v0,v0,v1
9d0051e4:	00821021 	addu	v0,a0,v0
9d0051e8:	88430004 	lwl	v1,4(v0)
9d0051ec:	00602021 	move	a0,v1
9d0051f0:	98440001 	lwr	a0,1(v0)
9d0051f4:	00801021 	move	v0,a0
9d0051f8:	3c03a000 	lui	v1,0xa000
9d0051fc:	2464011c 	addiu	a0,v1,284
9d005200:	00402821 	move	a1,v0
9d005204:	0f401151 	jal	9d004544 <UtPepLogicSetAddress>
9d005208:	00000000 	nop
9d00520c:	1040000f 	beqz	v0,9d00524c <UtPepLogicSetDelays+0x794>
9d005210:	00000000 	nop
                                  pCommandData->Data.ReadUserData.Data[nIndex].nAddress) ||
            !UtPepLogicSetOutputEnable(&l_PepLogicData,
                                       pCommandData->Data.ReadUserData.Data[nIndex].nEnableOutputEnable))
9d005214:	93c20010 	lbu	v0,16(s8)
9d005218:	8fc30020 	lw	v1,32(s8)
9d00521c:	00021040 	sll	v0,v0,0x1
9d005220:	00022080 	sll	a0,v0,0x2
9d005224:	00821023 	subu	v0,a0,v0
9d005228:	00621021 	addu	v0,v1,v0
9d00522c:	90420005 	lbu	v0,5(v0)

    for (nIndex = 0; nIndex < pCommandData->Data.ReadUserData.nDataLen; ++nIndex)
    {
        if (!UtPepLogicSetAddress(&l_PepLogicData,
                                  pCommandData->Data.ReadUserData.Data[nIndex].nAddress) ||
            !UtPepLogicSetOutputEnable(&l_PepLogicData,
9d005230:	3c03a000 	lui	v1,0xa000
9d005234:	2464011c 	addiu	a0,v1,284
9d005238:	00402821 	move	a1,v0
9d00523c:	0f401227 	jal	9d00489c <UtPepLogicSetOutputEnable>
9d005240:	00000000 	nop
    }

    for (nIndex = 0; nIndex < pCommandData->Data.ReadUserData.nDataLen; ++nIndex)
    {
        if (!UtPepLogicSetAddress(&l_PepLogicData,
                                  pCommandData->Data.ReadUserData.Data[nIndex].nAddress) ||
9d005244:	14400006 	bnez	v0,9d005260 <UtPepLogicSetDelays+0x7a8>
9d005248:	00000000 	nop
            !UtPepLogicSetOutputEnable(&l_PepLogicData,
                                       pCommandData->Data.ReadUserData.Data[nIndex].nEnableOutputEnable))
        {
            pResponseData->ErrorCode = CPepErrorFailed;
9d00524c:	8fc20024 	lw	v0,36(s8)
9d005250:	24030002 	li	v1,2
9d005254:	a0430001 	sb	v1,1(v0)
        
            return;
9d005258:	0b4014bc 	j	9d0052f0 <UtPepLogicSetDelays+0x838>
9d00525c:	00000000 	nop
        }
        
        if (pCommandData->Data.ReadUserData.Data[nIndex].nPerformRead)
9d005260:	93c20010 	lbu	v0,16(s8)
9d005264:	8fc30020 	lw	v1,32(s8)
9d005268:	00021040 	sll	v0,v0,0x1
9d00526c:	00022080 	sll	a0,v0,0x2
9d005270:	00821023 	subu	v0,a0,v0
9d005274:	00621021 	addu	v0,v1,v0
9d005278:	90420006 	lbu	v0,6(v0)
9d00527c:	10400011 	beqz	v0,9d0052c4 <UtPepLogicSetDelays+0x80c>
9d005280:	00000000 	nop
        {
            if (!UtPepLogicGetData(&l_PepLogicData,
                                   &pResponseData->Data.nData[nIndex]))
9d005284:	8fc20024 	lw	v0,36(s8)
9d005288:	24430002 	addiu	v1,v0,2
            return;
        }
        
        if (pCommandData->Data.ReadUserData.Data[nIndex].nPerformRead)
        {
            if (!UtPepLogicGetData(&l_PepLogicData,
9d00528c:	93c20010 	lbu	v0,16(s8)
9d005290:	00621021 	addu	v0,v1,v0
9d005294:	3c03a000 	lui	v1,0xa000
9d005298:	2464011c 	addiu	a0,v1,284
9d00529c:	00402821 	move	a1,v0
9d0052a0:	0f40117f 	jal	9d0045fc <UtPepLogicGetData>
9d0052a4:	00000000 	nop
9d0052a8:	14400006 	bnez	v0,9d0052c4 <UtPepLogicSetDelays+0x80c>
9d0052ac:	00000000 	nop
                                   &pResponseData->Data.nData[nIndex]))
            {
                pResponseData->ErrorCode = CPepErrorFailed;
9d0052b0:	8fc20024 	lw	v0,36(s8)
9d0052b4:	24030002 	li	v1,2
9d0052b8:	a0430001 	sb	v1,1(v0)
        
                return;
9d0052bc:	0b4014bc 	j	9d0052f0 <UtPepLogicSetDelays+0x838>
9d0052c0:	00000000 	nop
        pResponseData->ErrorCode = CPepErrorInvalidLength;
        
        return;
    }

    for (nIndex = 0; nIndex < pCommandData->Data.ReadUserData.nDataLen; ++nIndex)
9d0052c4:	93c20010 	lbu	v0,16(s8)
9d0052c8:	24420001 	addiu	v0,v0,1
9d0052cc:	a3c20010 	sb	v0,16(s8)
9d0052d0:	8fc20020 	lw	v0,32(s8)
9d0052d4:	9042003d 	lbu	v0,61(v0)
9d0052d8:	93c30010 	lbu	v1,16(s8)
9d0052dc:	0062102b 	sltu	v0,v1,v0
9d0052e0:	1440ffbb 	bnez	v0,9d0051d0 <UtPepLogicSetDelays+0x718>
9d0052e4:	00000000 	nop
                return;
            }
        }
    }    

    pResponseData->ErrorCode = CPepErrorSuccess;
9d0052e8:	8fc20024 	lw	v0,36(s8)
9d0052ec:	a0400001 	sb	zero,1(v0)
}
9d0052f0:	03c0e821 	move	sp,s8
9d0052f4:	8fbf001c 	lw	ra,28(sp)
9d0052f8:	8fbe0018 	lw	s8,24(sp)
9d0052fc:	27bd0020 	addiu	sp,sp,32
9d005300:	03e00008 	jr	ra
9d005304:	00000000 	nop

static void lProcessReadUserDataWithDelayCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d005308:	27bdffe0 	addiu	sp,sp,-32
9d00530c:	afbf001c 	sw	ra,28(sp)
9d005310:	afbe0018 	sw	s8,24(sp)
9d005314:	03a0f021 	move	s8,sp
9d005318:	afc40020 	sw	a0,32(s8)
9d00531c:	afc50024 	sw	a1,36(s8)
    UINT8 nIndex;
    
    if (pCommandData->Data.ReadUserDataWithDelay.nDataLen > MArrayLen(pCommandData->Data.ReadUserDataWithDelay.Data))
9d005320:	8fc20020 	lw	v0,32(s8)
9d005324:	90420037 	lbu	v0,55(v0)
9d005328:	2c420007 	sltiu	v0,v0,7
9d00532c:	14400006 	bnez	v0,9d005348 <UtPepLogicSetDelays+0x890>
9d005330:	00000000 	nop
    {
        pResponseData->ErrorCode = CPepErrorInvalidLength;
9d005334:	8fc20024 	lw	v0,36(s8)
9d005338:	24030003 	li	v1,3
9d00533c:	a0430001 	sb	v1,1(v0)
        
        return;
9d005340:	0b401518 	j	9d005460 <UtPepLogicSetDelays+0x9a8>
9d005344:	00000000 	nop
    }

    for (nIndex = 0; nIndex < pCommandData->Data.ReadUserDataWithDelay.nDataLen; ++nIndex)
9d005348:	a3c00010 	sb	zero,16(s8)
9d00534c:	0b401510 	j	9d005440 <UtPepLogicSetDelays+0x988>
9d005350:	00000000 	nop
    {
        if (!UtPepLogicSetAddressWithDelay(&l_PepLogicData,
9d005354:	93c30010 	lbu	v1,16(s8)
                                           pCommandData->Data.ReadUserDataWithDelay.Data[nIndex].nAddress,
9d005358:	8fc40020 	lw	a0,32(s8)
        return;
    }

    for (nIndex = 0; nIndex < pCommandData->Data.ReadUserDataWithDelay.nDataLen; ++nIndex)
    {
        if (!UtPepLogicSetAddressWithDelay(&l_PepLogicData,
9d00535c:	00601021 	move	v0,v1
9d005360:	000210c0 	sll	v0,v0,0x3
9d005364:	00431021 	addu	v0,v0,v1
9d005368:	00821021 	addu	v0,a0,v0
9d00536c:	88430004 	lwl	v1,4(v0)
9d005370:	00602821 	move	a1,v1
9d005374:	98450001 	lwr	a1,1(v0)
9d005378:	93c30010 	lbu	v1,16(s8)
                                           pCommandData->Data.ReadUserDataWithDelay.Data[nIndex].nAddress,
                                           pCommandData->Data.ReadUserDataWithDelay.Data[nIndex].nDelayNanoSeconds))
9d00537c:	8fc40020 	lw	a0,32(s8)
        return;
    }

    for (nIndex = 0; nIndex < pCommandData->Data.ReadUserDataWithDelay.nDataLen; ++nIndex)
    {
        if (!UtPepLogicSetAddressWithDelay(&l_PepLogicData,
9d005380:	00601021 	move	v0,v1
9d005384:	000210c0 	sll	v0,v0,0x3
9d005388:	00431021 	addu	v0,v0,v1
9d00538c:	00821021 	addu	v0,a0,v0
9d005390:	88430008 	lwl	v1,8(v0)
9d005394:	00602021 	move	a0,v1
9d005398:	98440005 	lwr	a0,5(v0)
9d00539c:	00801021 	move	v0,a0
9d0053a0:	3c03a000 	lui	v1,0xa000
9d0053a4:	2464011c 	addiu	a0,v1,284
9d0053a8:	00403021 	move	a2,v0
9d0053ac:	0f401163 	jal	9d00458c <UtPepLogicSetAddressWithDelay>
9d0053b0:	00000000 	nop
9d0053b4:	14400006 	bnez	v0,9d0053d0 <UtPepLogicSetDelays+0x918>
9d0053b8:	00000000 	nop
                                           pCommandData->Data.ReadUserDataWithDelay.Data[nIndex].nAddress,
                                           pCommandData->Data.ReadUserDataWithDelay.Data[nIndex].nDelayNanoSeconds))
        {
            pResponseData->ErrorCode = CPepErrorFailed;
9d0053bc:	8fc20024 	lw	v0,36(s8)
9d0053c0:	24030002 	li	v1,2
9d0053c4:	a0430001 	sb	v1,1(v0)
        
            return;
9d0053c8:	0b401518 	j	9d005460 <UtPepLogicSetDelays+0x9a8>
9d0053cc:	00000000 	nop
        }

        if (pCommandData->Data.ReadUserDataWithDelay.Data[nIndex].nPerformRead)
9d0053d0:	93c20010 	lbu	v0,16(s8)
9d0053d4:	8fc30020 	lw	v1,32(s8)
9d0053d8:	00402021 	move	a0,v0
9d0053dc:	000420c0 	sll	a0,a0,0x3
9d0053e0:	00821021 	addu	v0,a0,v0
9d0053e4:	00621021 	addu	v0,v1,v0
9d0053e8:	90420009 	lbu	v0,9(v0)
9d0053ec:	10400011 	beqz	v0,9d005434 <UtPepLogicSetDelays+0x97c>
9d0053f0:	00000000 	nop
        {
            if (!UtPepLogicGetData(&l_PepLogicData,
                                   &pResponseData->Data.nData[nIndex]))
9d0053f4:	8fc20024 	lw	v0,36(s8)
9d0053f8:	24430002 	addiu	v1,v0,2
            return;
        }

        if (pCommandData->Data.ReadUserDataWithDelay.Data[nIndex].nPerformRead)
        {
            if (!UtPepLogicGetData(&l_PepLogicData,
9d0053fc:	93c20010 	lbu	v0,16(s8)
9d005400:	00621021 	addu	v0,v1,v0
9d005404:	3c03a000 	lui	v1,0xa000
9d005408:	2464011c 	addiu	a0,v1,284
9d00540c:	00402821 	move	a1,v0
9d005410:	0f40117f 	jal	9d0045fc <UtPepLogicGetData>
9d005414:	00000000 	nop
9d005418:	14400006 	bnez	v0,9d005434 <UtPepLogicSetDelays+0x97c>
9d00541c:	00000000 	nop
                                   &pResponseData->Data.nData[nIndex]))
            {
                pResponseData->ErrorCode = CPepErrorFailed;
9d005420:	8fc20024 	lw	v0,36(s8)
9d005424:	24030002 	li	v1,2
9d005428:	a0430001 	sb	v1,1(v0)
        
                return;
9d00542c:	0b401518 	j	9d005460 <UtPepLogicSetDelays+0x9a8>
9d005430:	00000000 	nop
        pResponseData->ErrorCode = CPepErrorInvalidLength;
        
        return;
    }

    for (nIndex = 0; nIndex < pCommandData->Data.ReadUserDataWithDelay.nDataLen; ++nIndex)
9d005434:	93c20010 	lbu	v0,16(s8)
9d005438:	24420001 	addiu	v0,v0,1
9d00543c:	a3c20010 	sb	v0,16(s8)
9d005440:	8fc20020 	lw	v0,32(s8)
9d005444:	90420037 	lbu	v0,55(v0)
9d005448:	93c30010 	lbu	v1,16(s8)
9d00544c:	0062102b 	sltu	v0,v1,v0
9d005450:	1440ffc0 	bnez	v0,9d005354 <UtPepLogicSetDelays+0x89c>
9d005454:	00000000 	nop
                return;
            }
        }
    }    

    pResponseData->ErrorCode = CPepErrorSuccess;
9d005458:	8fc20024 	lw	v0,36(s8)
9d00545c:	a0400001 	sb	zero,1(v0)
}
9d005460:	03c0e821 	move	sp,s8
9d005464:	8fbf001c 	lw	ra,28(sp)
9d005468:	8fbe0018 	lw	s8,24(sp)
9d00546c:	27bd0020 	addiu	sp,sp,32
9d005470:	03e00008 	jr	ra
9d005474:	00000000 	nop

static void lProcessProgramDataCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d005478:	27bdffe0 	addiu	sp,sp,-32
9d00547c:	afbf001c 	sw	ra,28(sp)
9d005480:	afbe0018 	sw	s8,24(sp)
9d005484:	03a0f021 	move	s8,sp
9d005488:	afc40020 	sw	a0,32(s8)
9d00548c:	afc50024 	sw	a1,36(s8)
    UINT8 nIndex;
    BOOLEAN bSuccess;

    if (pCommandData->Data.ProgramData.nDataLen > MArrayLen(pCommandData->Data.ProgramData.nData))
9d005490:	8fc20020 	lw	v0,32(s8)
9d005494:	9042003f 	lbu	v0,63(v0)
9d005498:	2c42003b 	sltiu	v0,v0,59
9d00549c:	14400006 	bnez	v0,9d0054b8 <UtPepLogicSetDelays+0xa00>
9d0054a0:	00000000 	nop
    {
        pResponseData->ErrorCode = CPepErrorInvalidLength;
9d0054a4:	8fc20024 	lw	v0,36(s8)
9d0054a8:	24030003 	li	v1,3
9d0054ac:	a0430001 	sb	v1,1(v0)
        
        return;
9d0054b0:	0b401563 	j	9d00558c <UtPepLogicSetDelays+0xad4>
9d0054b4:	00000000 	nop
    }
    
    for (nIndex = 0; nIndex < pCommandData->Data.ProgramData.nDataLen; ++nIndex)
9d0054b8:	a3c00010 	sb	zero,16(s8)
9d0054bc:	0b40155b 	j	9d00556c <UtPepLogicSetDelays+0xab4>
9d0054c0:	00000000 	nop
    {
        if (!UtPepLogicSetAddress(&l_PepLogicData,
                                  pCommandData->Data.ProgramData.nAddress + nIndex) ||
9d0054c4:	8fc20020 	lw	v0,32(s8)
9d0054c8:	88430004 	lwl	v1,4(v0)
9d0054cc:	98430001 	lwr	v1,1(v0)
        return;
    }
    
    for (nIndex = 0; nIndex < pCommandData->Data.ProgramData.nDataLen; ++nIndex)
    {
        if (!UtPepLogicSetAddress(&l_PepLogicData,
9d0054d0:	93c20010 	lbu	v0,16(s8)
9d0054d4:	00621021 	addu	v0,v1,v0
9d0054d8:	3c03a000 	lui	v1,0xa000
9d0054dc:	2464011c 	addiu	a0,v1,284
9d0054e0:	00402821 	move	a1,v0
9d0054e4:	0f401151 	jal	9d004544 <UtPepLogicSetAddress>
9d0054e8:	00000000 	nop
9d0054ec:	10400017 	beqz	v0,9d00554c <UtPepLogicSetDelays+0xa94>
9d0054f0:	00000000 	nop
                                  pCommandData->Data.ProgramData.nAddress + nIndex) ||
            !UtPepLogicSetData(&l_PepLogicData,
                               pCommandData->Data.ProgramData.nData[nIndex]) ||
9d0054f4:	93c20010 	lbu	v0,16(s8)
9d0054f8:	8fc30020 	lw	v1,32(s8)
9d0054fc:	00621021 	addu	v0,v1,v0
9d005500:	90420005 	lbu	v0,5(v0)
    
    for (nIndex = 0; nIndex < pCommandData->Data.ProgramData.nDataLen; ++nIndex)
    {
        if (!UtPepLogicSetAddress(&l_PepLogicData,
                                  pCommandData->Data.ProgramData.nAddress + nIndex) ||
            !UtPepLogicSetData(&l_PepLogicData,
9d005504:	3c03a000 	lui	v1,0xa000
9d005508:	2464011c 	addiu	a0,v1,284
9d00550c:	00402821 	move	a1,v0
9d005510:	0f40119c 	jal	9d004670 <UtPepLogicSetData>
9d005514:	00000000 	nop
    }
    
    for (nIndex = 0; nIndex < pCommandData->Data.ProgramData.nDataLen; ++nIndex)
    {
        if (!UtPepLogicSetAddress(&l_PepLogicData,
                                  pCommandData->Data.ProgramData.nAddress + nIndex) ||
9d005518:	1040000c 	beqz	v0,9d00554c <UtPepLogicSetDelays+0xa94>
9d00551c:	00000000 	nop
            !UtPepLogicSetData(&l_PepLogicData,
                               pCommandData->Data.ProgramData.nData[nIndex]) ||
            !UtPepLogicTriggerProgram(&l_PepLogicData,
9d005520:	27c20011 	addiu	v0,s8,17
9d005524:	3c03a000 	lui	v1,0xa000
9d005528:	2464011c 	addiu	a0,v1,284
9d00552c:	00402821 	move	a1,v0
9d005530:	0f4011bb 	jal	9d0046ec <UtPepLogicTriggerProgram>
9d005534:	00000000 	nop
    for (nIndex = 0; nIndex < pCommandData->Data.ProgramData.nDataLen; ++nIndex)
    {
        if (!UtPepLogicSetAddress(&l_PepLogicData,
                                  pCommandData->Data.ProgramData.nAddress + nIndex) ||
            !UtPepLogicSetData(&l_PepLogicData,
                               pCommandData->Data.ProgramData.nData[nIndex]) ||
9d005538:	10400004 	beqz	v0,9d00554c <UtPepLogicSetDelays+0xa94>
9d00553c:	00000000 	nop
            !UtPepLogicTriggerProgram(&l_PepLogicData,
                                      &bSuccess) ||
            !bSuccess)
9d005540:	93c20011 	lbu	v0,17(s8)
        if (!UtPepLogicSetAddress(&l_PepLogicData,
                                  pCommandData->Data.ProgramData.nAddress + nIndex) ||
            !UtPepLogicSetData(&l_PepLogicData,
                               pCommandData->Data.ProgramData.nData[nIndex]) ||
            !UtPepLogicTriggerProgram(&l_PepLogicData,
                                      &bSuccess) ||
9d005544:	14400006 	bnez	v0,9d005560 <UtPepLogicSetDelays+0xaa8>
9d005548:	00000000 	nop
            !bSuccess)
        {
            pResponseData->ErrorCode = CPepErrorFailed;
9d00554c:	8fc20024 	lw	v0,36(s8)
9d005550:	24030002 	li	v1,2
9d005554:	a0430001 	sb	v1,1(v0)
        
            return;
9d005558:	0b401563 	j	9d00558c <UtPepLogicSetDelays+0xad4>
9d00555c:	00000000 	nop
        pResponseData->ErrorCode = CPepErrorInvalidLength;
        
        return;
    }
    
    for (nIndex = 0; nIndex < pCommandData->Data.ProgramData.nDataLen; ++nIndex)
9d005560:	93c20010 	lbu	v0,16(s8)
9d005564:	24420001 	addiu	v0,v0,1
9d005568:	a3c20010 	sb	v0,16(s8)
9d00556c:	8fc20020 	lw	v0,32(s8)
9d005570:	9042003f 	lbu	v0,63(v0)
9d005574:	93c30010 	lbu	v1,16(s8)
9d005578:	0062102b 	sltu	v0,v1,v0
9d00557c:	1440ffd1 	bnez	v0,9d0054c4 <UtPepLogicSetDelays+0xa0c>
9d005580:	00000000 	nop
        
            return;
        }
    }

    pResponseData->ErrorCode = CPepErrorSuccess;
9d005584:	8fc20024 	lw	v0,36(s8)
9d005588:	a0400001 	sb	zero,1(v0)
}
9d00558c:	03c0e821 	move	sp,s8
9d005590:	8fbf001c 	lw	ra,28(sp)
9d005594:	8fbe0018 	lw	s8,24(sp)
9d005598:	27bd0020 	addiu	sp,sp,32
9d00559c:	03e00008 	jr	ra
9d0055a0:	00000000 	nop

static void lProcessProgramUserDataCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d0055a4:	27bdffe0 	addiu	sp,sp,-32
9d0055a8:	afbf001c 	sw	ra,28(sp)
9d0055ac:	afbe0018 	sw	s8,24(sp)
9d0055b0:	03a0f021 	move	s8,sp
9d0055b4:	afc40020 	sw	a0,32(s8)
9d0055b8:	afc50024 	sw	a1,36(s8)
    UINT8 nIndex;
    BOOLEAN bSuccess;
    
    if (pCommandData->Data.ProgramUserData.nDataLen > MArrayLen(pCommandData->Data.ProgramUserData.Data))
9d0055bc:	8fc20020 	lw	v0,32(s8)
9d0055c0:	9042003d 	lbu	v0,61(v0)
9d0055c4:	2c42000b 	sltiu	v0,v0,11
9d0055c8:	14400006 	bnez	v0,9d0055e4 <UtPepLogicSetDelays+0xb2c>
9d0055cc:	00000000 	nop
    {
        pResponseData->ErrorCode = CPepErrorInvalidLength;
9d0055d0:	8fc20024 	lw	v0,36(s8)
9d0055d4:	24030003 	li	v1,3
9d0055d8:	a0430001 	sb	v1,1(v0)
        
        return;
9d0055dc:	0b4015c4 	j	9d005710 <UtPepLogicSetDelays+0xc58>
9d0055e0:	00000000 	nop
    }
    
    for (nIndex = 0; nIndex < pCommandData->Data.ProgramUserData.nDataLen; ++nIndex)
9d0055e4:	a3c00010 	sb	zero,16(s8)
9d0055e8:	0b4015bc 	j	9d0056f0 <UtPepLogicSetDelays+0xc38>
9d0055ec:	00000000 	nop
    {
        if (!UtPepLogicSetAddress(&l_PepLogicData,
9d0055f0:	93c20010 	lbu	v0,16(s8)
                                  pCommandData->Data.ProgramUserData.Data[nIndex].nAddress))
9d0055f4:	8fc40020 	lw	a0,32(s8)
        return;
    }
    
    for (nIndex = 0; nIndex < pCommandData->Data.ProgramUserData.nDataLen; ++nIndex)
    {
        if (!UtPepLogicSetAddress(&l_PepLogicData,
9d0055f8:	00021840 	sll	v1,v0,0x1
9d0055fc:	00031080 	sll	v0,v1,0x2
9d005600:	00431023 	subu	v0,v0,v1
9d005604:	00821021 	addu	v0,a0,v0
9d005608:	88430004 	lwl	v1,4(v0)
9d00560c:	00602021 	move	a0,v1
9d005610:	98440001 	lwr	a0,1(v0)
9d005614:	00801021 	move	v0,a0
9d005618:	3c03a000 	lui	v1,0xa000
9d00561c:	2464011c 	addiu	a0,v1,284
9d005620:	00402821 	move	a1,v0
9d005624:	0f401151 	jal	9d004544 <UtPepLogicSetAddress>
9d005628:	00000000 	nop
9d00562c:	14400006 	bnez	v0,9d005648 <UtPepLogicSetDelays+0xb90>
9d005630:	00000000 	nop
                                  pCommandData->Data.ProgramUserData.Data[nIndex].nAddress))
        {
            pResponseData->ErrorCode = CPepErrorFailed;
9d005634:	8fc20024 	lw	v0,36(s8)
9d005638:	24030002 	li	v1,2
9d00563c:	a0430001 	sb	v1,1(v0)
        
            return;
9d005640:	0b4015c4 	j	9d005710 <UtPepLogicSetDelays+0xc58>
9d005644:	00000000 	nop
        }

        if (pCommandData->Data.ProgramUserData.Data[nIndex].nPerformProgram)
9d005648:	93c20010 	lbu	v0,16(s8)
9d00564c:	8fc30020 	lw	v1,32(s8)
9d005650:	00021040 	sll	v0,v0,0x1
9d005654:	00022080 	sll	a0,v0,0x2
9d005658:	00821023 	subu	v0,a0,v0
9d00565c:	00621021 	addu	v0,v1,v0
9d005660:	90420005 	lbu	v0,5(v0)
9d005664:	1040001f 	beqz	v0,9d0056e4 <UtPepLogicSetDelays+0xc2c>
9d005668:	00000000 	nop
        {
            if (!UtPepLogicSetData(&l_PepLogicData,
                                   pCommandData->Data.ProgramUserData.Data[nIndex].nData) ||
9d00566c:	93c20010 	lbu	v0,16(s8)
9d005670:	8fc30020 	lw	v1,32(s8)
9d005674:	00021040 	sll	v0,v0,0x1
9d005678:	00022080 	sll	a0,v0,0x2
9d00567c:	00821023 	subu	v0,a0,v0
9d005680:	00621021 	addu	v0,v1,v0
9d005684:	90420006 	lbu	v0,6(v0)
            return;
        }

        if (pCommandData->Data.ProgramUserData.Data[nIndex].nPerformProgram)
        {
            if (!UtPepLogicSetData(&l_PepLogicData,
9d005688:	3c03a000 	lui	v1,0xa000
9d00568c:	2464011c 	addiu	a0,v1,284
9d005690:	00402821 	move	a1,v0
9d005694:	0f40119c 	jal	9d004670 <UtPepLogicSetData>
9d005698:	00000000 	nop
9d00569c:	1040000c 	beqz	v0,9d0056d0 <UtPepLogicSetDelays+0xc18>
9d0056a0:	00000000 	nop
                                   pCommandData->Data.ProgramUserData.Data[nIndex].nData) ||
                !UtPepLogicTriggerProgram(&l_PepLogicData,
9d0056a4:	27c20011 	addiu	v0,s8,17
9d0056a8:	3c03a000 	lui	v1,0xa000
9d0056ac:	2464011c 	addiu	a0,v1,284
9d0056b0:	00402821 	move	a1,v0
9d0056b4:	0f4011bb 	jal	9d0046ec <UtPepLogicTriggerProgram>
9d0056b8:	00000000 	nop
        }

        if (pCommandData->Data.ProgramUserData.Data[nIndex].nPerformProgram)
        {
            if (!UtPepLogicSetData(&l_PepLogicData,
                                   pCommandData->Data.ProgramUserData.Data[nIndex].nData) ||
9d0056bc:	10400004 	beqz	v0,9d0056d0 <UtPepLogicSetDelays+0xc18>
9d0056c0:	00000000 	nop
                !UtPepLogicTriggerProgram(&l_PepLogicData,
                                          &bSuccess) ||
                !bSuccess)
9d0056c4:	93c20011 	lbu	v0,17(s8)
        if (pCommandData->Data.ProgramUserData.Data[nIndex].nPerformProgram)
        {
            if (!UtPepLogicSetData(&l_PepLogicData,
                                   pCommandData->Data.ProgramUserData.Data[nIndex].nData) ||
                !UtPepLogicTriggerProgram(&l_PepLogicData,
                                          &bSuccess) ||
9d0056c8:	14400006 	bnez	v0,9d0056e4 <UtPepLogicSetDelays+0xc2c>
9d0056cc:	00000000 	nop
                !bSuccess)
            {
                pResponseData->ErrorCode = CPepErrorFailed;
9d0056d0:	8fc20024 	lw	v0,36(s8)
9d0056d4:	24030002 	li	v1,2
9d0056d8:	a0430001 	sb	v1,1(v0)

                return;
9d0056dc:	0b4015c4 	j	9d005710 <UtPepLogicSetDelays+0xc58>
9d0056e0:	00000000 	nop
        pResponseData->ErrorCode = CPepErrorInvalidLength;
        
        return;
    }
    
    for (nIndex = 0; nIndex < pCommandData->Data.ProgramUserData.nDataLen; ++nIndex)
9d0056e4:	93c20010 	lbu	v0,16(s8)
9d0056e8:	24420001 	addiu	v0,v0,1
9d0056ec:	a3c20010 	sb	v0,16(s8)
9d0056f0:	8fc20020 	lw	v0,32(s8)
9d0056f4:	9042003d 	lbu	v0,61(v0)
9d0056f8:	93c30010 	lbu	v1,16(s8)
9d0056fc:	0062102b 	sltu	v0,v1,v0
9d005700:	1440ffbb 	bnez	v0,9d0055f0 <UtPepLogicSetDelays+0xb38>
9d005704:	00000000 	nop
                return;
            }
        }
    }

    pResponseData->ErrorCode = CPepErrorSuccess;
9d005708:	8fc20024 	lw	v0,36(s8)
9d00570c:	a0400001 	sb	zero,1(v0)
}
9d005710:	03c0e821 	move	sp,s8
9d005714:	8fbf001c 	lw	ra,28(sp)
9d005718:	8fbe0018 	lw	s8,24(sp)
9d00571c:	27bd0020 	addiu	sp,sp,32
9d005720:	03e00008 	jr	ra
9d005724:	00000000 	nop

static void lProcessSetDelaysCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d005728:	27bdffe8 	addiu	sp,sp,-24
9d00572c:	afbf0014 	sw	ra,20(sp)
9d005730:	afbe0010 	sw	s8,16(sp)
9d005734:	03a0f021 	move	s8,sp
9d005738:	afc40018 	sw	a0,24(s8)
9d00573c:	afc5001c 	sw	a1,28(s8)
    pResponseData->ErrorCode = UtPepLogicSetDelays(&l_PepLogicData,
                                                   pCommandData->Data.Delays.nChipEnableNanoSeconds,
9d005740:	8fc20018 	lw	v0,24(s8)

static void lProcessSetDelaysCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
    pResponseData->ErrorCode = UtPepLogicSetDelays(&l_PepLogicData,
9d005744:	88430004 	lwl	v1,4(v0)
9d005748:	98430001 	lwr	v1,1(v0)
                                                   pCommandData->Data.Delays.nChipEnableNanoSeconds,
                                                   pCommandData->Data.Delays.nOutputEnableNanoSeconds) ? CPepErrorSuccess : CPepErrorFailed;
9d00574c:	8fc20018 	lw	v0,24(s8)

static void lProcessSetDelaysCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
    pResponseData->ErrorCode = UtPepLogicSetDelays(&l_PepLogicData,
9d005750:	88440008 	lwl	a0,8(v0)
9d005754:	00802821 	move	a1,a0
9d005758:	98450005 	lwr	a1,5(v0)
9d00575c:	00a01021 	move	v0,a1
9d005760:	3c04a000 	lui	a0,0xa000
9d005764:	2484011c 	addiu	a0,a0,284
9d005768:	00602821 	move	a1,v1
9d00576c:	00403021 	move	a2,v0
9d005770:	0f4012ae 	jal	9d004ab8 <UtPepLogicSetDelays>
9d005774:	00000000 	nop
9d005778:	10400004 	beqz	v0,9d00578c <UtPepLogicSetDelays+0xcd4>
9d00577c:	00000000 	nop
9d005780:	00001021 	move	v0,zero
9d005784:	0b4015e4 	j	9d005790 <UtPepLogicSetDelays+0xcd8>
9d005788:	00000000 	nop
9d00578c:	24020002 	li	v0,2
9d005790:	8fc3001c 	lw	v1,28(s8)
9d005794:	a0620001 	sb	v0,1(v1)
                                                   pCommandData->Data.Delays.nChipEnableNanoSeconds,
                                                   pCommandData->Data.Delays.nOutputEnableNanoSeconds) ? CPepErrorSuccess : CPepErrorFailed;
}
9d005798:	03c0e821 	move	sp,s8
9d00579c:	8fbf0014 	lw	ra,20(sp)
9d0057a0:	8fbe0010 	lw	s8,16(sp)
9d0057a4:	27bd0018 	addiu	sp,sp,24
9d0057a8:	03e00008 	jr	ra
9d0057ac:	00000000 	nop

static void lProcessDebugWritePortDataCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d0057b0:	27bdffe0 	addiu	sp,sp,-32
9d0057b4:	afbf001c 	sw	ra,28(sp)
9d0057b8:	afbe0018 	sw	s8,24(sp)
9d0057bc:	03a0f021 	move	s8,sp
9d0057c0:	afc40020 	sw	a0,32(s8)
9d0057c4:	afc50024 	sw	a1,36(s8)
    UINT8 nData[] = {pCommandData->Data.DebugWritePortData.nWritePortData};
9d0057c8:	8fc20020 	lw	v0,32(s8)
9d0057cc:	90420001 	lbu	v0,1(v0)
9d0057d0:	a3c20010 	sb	v0,16(s8)
    
    pResponseData->ErrorCode = lPepLogicWritePort(nData,
9d0057d4:	27c20010 	addiu	v0,s8,16
9d0057d8:	00402021 	move	a0,v0
9d0057dc:	24050001 	li	a1,1
9d0057e0:	00003021 	move	a2,zero
9d0057e4:	0f4012dc 	jal	9d004b70 <UtPepLogicSetDelays+0xb8>
9d0057e8:	00000000 	nop
9d0057ec:	10400004 	beqz	v0,9d005800 <UtPepLogicSetDelays+0xd48>
9d0057f0:	00000000 	nop
9d0057f4:	00001021 	move	v0,zero
9d0057f8:	0b401601 	j	9d005804 <UtPepLogicSetDelays+0xd4c>
9d0057fc:	00000000 	nop
9d005800:	24020002 	li	v0,2
9d005804:	8fc30024 	lw	v1,36(s8)
9d005808:	a0620001 	sb	v0,1(v1)
                                                  MArrayLen(nData),
                                                  0) ? CPepErrorSuccess : CPepErrorFailed;
}
9d00580c:	03c0e821 	move	sp,s8
9d005810:	8fbf001c 	lw	ra,28(sp)
9d005814:	8fbe0018 	lw	s8,24(sp)
9d005818:	27bd0020 	addiu	sp,sp,32
9d00581c:	03e00008 	jr	ra
9d005820:	00000000 	nop

static void lProcessUnknownCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d005824:	27bdfff8 	addiu	sp,sp,-8
9d005828:	afbe0004 	sw	s8,4(sp)
9d00582c:	03a0f021 	move	s8,sp
9d005830:	afc40008 	sw	a0,8(s8)
9d005834:	afc5000c 	sw	a1,12(s8)
    pResponseData->ErrorCode = CPepErrorInvalidCommand;
9d005838:	8fc2000c 	lw	v0,12(s8)
9d00583c:	24030001 	li	v1,1
9d005840:	a0430001 	sb	v1,1(v0)
}
9d005844:	03c0e821 	move	sp,s8
9d005848:	8fbe0004 	lw	s8,4(sp)
9d00584c:	27bd0008 	addiu	sp,sp,8
9d005850:	03e00008 	jr	ra
9d005854:	00000000 	nop

9d005858 <InitProcessCommand>:

void InitProcessCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d005858:	27bdffe8 	addiu	sp,sp,-24
9d00585c:	afbf0014 	sw	ra,20(sp)
9d005860:	afbe0010 	sw	s8,16(sp)
9d005864:	03a0f021 	move	s8,sp
9d005868:	afc40018 	sw	a0,24(s8)
9d00586c:	afc5001c 	sw	a1,28(s8)
#if defined(__32MX250F128B__)
    ANSELA = 0x00; // Disable all analog inputs on Port A
9d005870:	3c02bf88 	lui	v0,0xbf88
9d005874:	ac406000 	sw	zero,24576(v0)
    ANSELB = 0x00; // Disable all analog inputs on Port B
9d005878:	3c02bf88 	lui	v0,0xbf88
9d00587c:	ac406100 	sw	zero,24832(v0)

    ODCA = 0x00; // Disable Open-Drain Output on Port A
9d005880:	3c02bf88 	lui	v0,0xbf88
9d005884:	ac406040 	sw	zero,24640(v0)
    ODCB = 0x00; // Disable Open-Drain Output on POrt B
9d005888:	3c02bf88 	lui	v0,0xbf88
9d00588c:	ac406140 	sw	zero,24896(v0)

    DMACONbits.ON = 0x00; // Disable DMA Controller
9d005890:	3c03bf88 	lui	v1,0xbf88
9d005894:	8c623000 	lw	v0,12288(v1)
9d005898:	7c027bc4 	ins	v0,zero,0xf,0x1
9d00589c:	ac623000 	sw	v0,12288(v1)

    CNCONAbits.ON = 0x00; // Disable Change Notice on Port A
9d0058a0:	3c03bf88 	lui	v1,0xbf88
9d0058a4:	8c626070 	lw	v0,24688(v1)
9d0058a8:	7c027bc4 	ins	v0,zero,0xf,0x1
9d0058ac:	ac626070 	sw	v0,24688(v1)
    CNCONBbits.ON = 0x00; // Disable Change Notice on Port B
9d0058b0:	3c03bf88 	lui	v1,0xbf88
9d0058b4:	8c626170 	lw	v0,24944(v1)
9d0058b8:	7c027bc4 	ins	v0,zero,0xf,0x1
9d0058bc:	ac626170 	sw	v0,24944(v1)

    CNPDA = 0x00; // Disable Change Notification Pull-Down on Port A
9d0058c0:	3c02bf88 	lui	v0,0xbf88
9d0058c4:	ac406060 	sw	zero,24672(v0)
    CNPDB = 0x00; // Disable Change Notification Pull-Down on Port B
9d0058c8:	3c02bf88 	lui	v0,0xbf88
9d0058cc:	ac406160 	sw	zero,24928(v0)

    CNPUA = 0x00; // Disable Change Notification Pull-Up on Port A
9d0058d0:	3c02bf88 	lui	v0,0xbf88
9d0058d4:	ac406050 	sw	zero,24656(v0)
    CNPUB = 0x00; // Disable Change Notification Pull-Up on Port B
9d0058d8:	3c02bf88 	lui	v0,0xbf88
9d0058dc:	ac406150 	sw	zero,24912(v0)

    CNENA = 0x00; // Disable Change Notification Interrupt on Port A
9d0058e0:	3c02bf88 	lui	v0,0xbf88
9d0058e4:	ac406080 	sw	zero,24704(v0)
    CNENB = 0x00; // Disable Change Notification Interrupt on Port B
9d0058e8:	3c02bf88 	lui	v0,0xbf88
9d0058ec:	ac406180 	sw	zero,24960(v0)
    
    I2C1CONbits.ON = 0x00; // Turn off I2C1 module
9d0058f0:	3c03bf80 	lui	v1,0xbf80
9d0058f4:	8c625000 	lw	v0,20480(v1)
9d0058f8:	7c027bc4 	ins	v0,zero,0xf,0x1
9d0058fc:	ac625000 	sw	v0,20480(v1)
    I2C2CONbits.ON = 0x00; // Turn off I2C2 module
9d005900:	3c03bf80 	lui	v1,0xbf80
9d005904:	8c625100 	lw	v0,20736(v1)
9d005908:	7c027bc4 	ins	v0,zero,0xf,0x1
9d00590c:	ac625100 	sw	v0,20736(v1)
    
    T1CONbits.ON = 0x00; // Turn off Timer 1
9d005910:	3c03bf80 	lui	v1,0xbf80
9d005914:	8c620600 	lw	v0,1536(v1)
9d005918:	7c027bc4 	ins	v0,zero,0xf,0x1
9d00591c:	ac620600 	sw	v0,1536(v1)
    T2CONbits.ON = 0x00; // Turn off Timer 2
9d005920:	3c03bf80 	lui	v1,0xbf80
9d005924:	8c620800 	lw	v0,2048(v1)
9d005928:	7c027bc4 	ins	v0,zero,0xf,0x1
9d00592c:	ac620800 	sw	v0,2048(v1)
    T3CONbits.ON = 0x00; // Turn off Timer 3
9d005930:	3c03bf80 	lui	v1,0xbf80
9d005934:	8c620a00 	lw	v0,2560(v1)
9d005938:	7c027bc4 	ins	v0,zero,0xf,0x1
9d00593c:	ac620a00 	sw	v0,2560(v1)
    T4CONbits.ON = 0x00; // Turn off Timer 4
9d005940:	3c03bf80 	lui	v1,0xbf80
9d005944:	8c620c00 	lw	v0,3072(v1)
9d005948:	7c027bc4 	ins	v0,zero,0xf,0x1
9d00594c:	ac620c00 	sw	v0,3072(v1)
    T5CONbits.ON = 0x00; // Turn off Timer 5
9d005950:	3c03bf80 	lui	v1,0xbf80
9d005954:	8c620e00 	lw	v0,3584(v1)
9d005958:	7c027bc4 	ins	v0,zero,0xf,0x1
9d00595c:	ac620e00 	sw	v0,3584(v1)
    
    OC1CONbits.ON = 0x00; // Turn off Output Compare Peripheral
9d005960:	3c03bf80 	lui	v1,0xbf80
9d005964:	8c623000 	lw	v0,12288(v1)
9d005968:	7c027bc4 	ins	v0,zero,0xf,0x1
9d00596c:	ac623000 	sw	v0,12288(v1)
    OC2CONbits.ON = 0x00; // Turn off Output Compare Peripheral
9d005970:	3c03bf80 	lui	v1,0xbf80
9d005974:	8c623200 	lw	v0,12800(v1)
9d005978:	7c027bc4 	ins	v0,zero,0xf,0x1
9d00597c:	ac623200 	sw	v0,12800(v1)
    OC3CONbits.ON = 0x00; // Turn off Output Compare Peripheral
9d005980:	3c03bf80 	lui	v1,0xbf80
9d005984:	8c623400 	lw	v0,13312(v1)
9d005988:	7c027bc4 	ins	v0,zero,0xf,0x1
9d00598c:	ac623400 	sw	v0,13312(v1)
    OC4CONbits.ON = 0x00; // Turn off Output Compare Peripheral
9d005990:	3c03bf80 	lui	v1,0xbf80
9d005994:	8c623600 	lw	v0,13824(v1)
9d005998:	7c027bc4 	ins	v0,zero,0xf,0x1
9d00599c:	ac623600 	sw	v0,13824(v1)
    OC5CONbits.ON = 0x00; // Turn off Output Compare Peripheral
9d0059a0:	3c03bf80 	lui	v1,0xbf80
9d0059a4:	8c623800 	lw	v0,14336(v1)
9d0059a8:	7c027bc4 	ins	v0,zero,0xf,0x1
9d0059ac:	ac623800 	sw	v0,14336(v1)

    SPI1CONbits.ON = 0x00; // Turn off Framed SPI 1 support
9d0059b0:	3c03bf80 	lui	v1,0xbf80
9d0059b4:	8c625800 	lw	v0,22528(v1)
9d0059b8:	7c027bc4 	ins	v0,zero,0xf,0x1
9d0059bc:	ac625800 	sw	v0,22528(v1)
    SPI2CONbits.ON = 0x00; // Turn off Framed SPI 2 support
9d0059c0:	3c03bf80 	lui	v1,0xbf80
9d0059c4:	8c625a00 	lw	v0,23040(v1)
9d0059c8:	7c027bc4 	ins	v0,zero,0xf,0x1
9d0059cc:	ac625a00 	sw	v0,23040(v1)
    
    U1MODEbits.ON = 0x00; // Turn off UART1
9d0059d0:	3c03bf80 	lui	v1,0xbf80
9d0059d4:	8c626000 	lw	v0,24576(v1)
9d0059d8:	7c027bc4 	ins	v0,zero,0xf,0x1
9d0059dc:	ac626000 	sw	v0,24576(v1)
    U2MODEbits.ON = 0x00; // Turn off UART2
9d0059e0:	3c03bf80 	lui	v1,0xbf80
9d0059e4:	8c626200 	lw	v0,25088(v1)
9d0059e8:	7c027bc4 	ins	v0,zero,0xf,0x1
9d0059ec:	ac626200 	sw	v0,25088(v1)

    RTCCONbits.ON = 0x00; // Turn off RTC module
9d0059f0:	3c03bf80 	lui	v1,0xbf80
9d0059f4:	8c620200 	lw	v0,512(v1)
9d0059f8:	7c027bc4 	ins	v0,zero,0xf,0x1
9d0059fc:	ac620200 	sw	v0,512(v1)

    RTCALRMbits.ALRMEN = 0x00; // Turn off RTC alarm
9d005a00:	3c03bf80 	lui	v1,0xbf80
9d005a04:	8c620210 	lw	v0,528(v1)
9d005a08:	7c027bc4 	ins	v0,zero,0xf,0x1
9d005a0c:	ac620210 	sw	v0,528(v1)
    
    AD1CON1bits.ON = 0x00; // Turn off ADC
9d005a10:	3c03bf81 	lui	v1,0xbf81
9d005a14:	8c629000 	lw	v0,-28672(v1)
9d005a18:	7c027bc4 	ins	v0,zero,0xf,0x1
9d005a1c:	ac629000 	sw	v0,-28672(v1)
 
    CM1CONbits.ON = 0x00; // Turn off Comparator 1
9d005a20:	3c03bf81 	lui	v1,0xbf81
9d005a24:	8c62a000 	lw	v0,-24576(v1)
9d005a28:	7c027bc4 	ins	v0,zero,0xf,0x1
9d005a2c:	ac62a000 	sw	v0,-24576(v1)
    CM2CONbits.ON = 0x00; // Turn off Comparator 2
9d005a30:	3c03bf81 	lui	v1,0xbf81
9d005a34:	8c62a010 	lw	v0,-24560(v1)
9d005a38:	7c027bc4 	ins	v0,zero,0xf,0x1
9d005a3c:	ac62a010 	sw	v0,-24560(v1)
    CM3CONbits.ON = 0x00; // Turn off Comparator 3
9d005a40:	3c03bf81 	lui	v1,0xbf81
9d005a44:	8c62a020 	lw	v0,-24544(v1)
9d005a48:	7c027bc4 	ins	v0,zero,0xf,0x1
9d005a4c:	ac62a020 	sw	v0,-24544(v1)
    
    CVRCONbits.ON = 0x00; // Turn off Comparator Voltage Reference
9d005a50:	3c03bf81 	lui	v1,0xbf81
9d005a54:	8c629800 	lw	v0,-26624(v1)
9d005a58:	7c027bc4 	ins	v0,zero,0xf,0x1
9d005a5c:	ac629800 	sw	v0,-26624(v1)

    CTMUCONbits.ON = 0x00; // Turn off CTMU
9d005a60:	3c03bf81 	lui	v1,0xbf81
9d005a64:	8c62a200 	lw	v0,-24064(v1)
9d005a68:	7c027bc4 	ins	v0,zero,0xf,0x1
9d005a6c:	ac62a200 	sw	v0,-24064(v1)
   
    // Pin 11 - SOSCI/RPB4/RB4

    TRISBbits.TRISB4 = 0x01; // Set Port B, bit 4 as input
9d005a70:	3c03bf88 	lui	v1,0xbf88
9d005a74:	8c626110 	lw	v0,24848(v1)
9d005a78:	24040001 	li	a0,1
9d005a7c:	7c822104 	ins	v0,a0,0x4,0x1
9d005a80:	ac626110 	sw	v0,24848(v1)

#if defined(DISABLE_PARALLEL_PORT)
    IEC1bits.PMPIE = 0x00; // disable PMP interrupts
9d005a84:	3c03bf88 	lui	v1,0xbf88
9d005a88:	8c621070 	lw	v0,4208(v1)
9d005a8c:	7c028404 	ins	v0,zero,0x10,0x1
9d005a90:	ac621070 	sw	v0,4208(v1)
    PMCONbits.ON = 0x00; // Turn off Parallel Master Port
9d005a94:	3c03bf80 	lui	v1,0xbf80
9d005a98:	8c627000 	lw	v0,28672(v1)
9d005a9c:	7c027bc4 	ins	v0,zero,0xf,0x1
9d005aa0:	ac627000 	sw	v0,28672(v1)
    
    // Pin 4 PGED1/AN2/C1IND/C2INB/C3IND/RPB0/PMD0/RB0

    TRISBbits.TRISB0 = 0x00; // Set Port B, bit 0 as output
9d005aa4:	3c03bf88 	lui	v1,0xbf88
9d005aa8:	8c626110 	lw	v0,24848(v1)
9d005aac:	7c020004 	ins	v0,zero,0x0,0x1
9d005ab0:	ac626110 	sw	v0,24848(v1)
    
    // Pin 5 - PGEC1/AN1/C1INC/C2INA/RPB1/CTED12/PMD1/RB1

    TRISBbits.TRISB1 = 0x00; // Set Port B, bit 1 as output
9d005ab4:	3c03bf88 	lui	v1,0xbf88
9d005ab8:	8c626110 	lw	v0,24848(v1)
9d005abc:	7c020844 	ins	v0,zero,0x1,0x1
9d005ac0:	ac626110 	sw	v0,24848(v1)

    // Pin 6 - AN4/C1INB/C2IND/RPB2/SDA2/CTED13/PMD2/RB2

    TRISBbits.TRISB2 = 0x00; // Set Port B, bit 2 as output
9d005ac4:	3c03bf88 	lui	v1,0xbf88
9d005ac8:	8c626110 	lw	v0,24848(v1)
9d005acc:	7c021084 	ins	v0,zero,0x2,0x1
9d005ad0:	ac626110 	sw	v0,24848(v1)
    
    // Pin 18 - TDO/RPB9/SDA1/CTED4/PMD3/RB9

    TRISBbits.TRISB9 = 0x00; // Set Port B, bit 9 as output
9d005ad4:	3c03bf88 	lui	v1,0xbf88
9d005ad8:	8c626110 	lw	v0,24848(v1)
9d005adc:	7c024a44 	ins	v0,zero,0x9,0x1
9d005ae0:	ac626110 	sw	v0,24848(v1)
    
    // Pin 17 - TCK/RPB8/SCL1/CTED10/PMD4/RB8

    TRISBbits.TRISB8 = 0x00; // Set Port B, bit 8 as output
9d005ae4:	3c03bf88 	lui	v1,0xbf88
9d005ae8:	8c626110 	lw	v0,24848(v1)
9d005aec:	7c024204 	ins	v0,zero,0x8,0x1
9d005af0:	ac626110 	sw	v0,24848(v1)
    
    // Pin 16 - TDI/RPB7/CTED3/PMD5/INT0/RB7
    
    TRISBbits.TRISB7 = 0x00; // Set Port B, bit 7 as output
9d005af4:	3c03bf88 	lui	v1,0xbf88
9d005af8:	8c626110 	lw	v0,24848(v1)
9d005afc:	7c0239c4 	ins	v0,zero,0x7,0x1
9d005b00:	ac626110 	sw	v0,24848(v1)
    
    // Pin 3 - PGEC3/VREF-/CVREF-/AN1/RPA1/CTED2/PMD6/RA1

    TRISAbits.TRISA1 = 0x00; // Set Port A, bit 1 as output
9d005b04:	3c03bf88 	lui	v1,0xbf88
9d005b08:	8c626010 	lw	v0,24592(v1)
9d005b0c:	7c020844 	ins	v0,zero,0x1,0x1
9d005b10:	ac626010 	sw	v0,24592(v1)
    
    // Pin 2 - PGED3/VREF+/CVREF+/AN0/C3INC/RPA0/CTED1/PMD7/RA0

    TRISAbits.TRISA0 = 0x00; // Set Port A, bit 0 as output
9d005b14:	3c03bf88 	lui	v1,0xbf88
9d005b18:	8c626010 	lw	v0,24592(v1)
9d005b1c:	7c020004 	ins	v0,zero,0x0,0x1
9d005b20:	ac626010 	sw	v0,24592(v1)

    // Pin 7 - AN5/C1INA/C2INC/RTCC/RPB3/SCL2/PMWR/RB3

    TRISBbits.TRISB3 = 0x00; // Set Port B, bit 3 as output
9d005b24:	3c03bf88 	lui	v1,0xbf88
9d005b28:	8c626110 	lw	v0,24848(v1)
9d005b2c:	7c0218c4 	ins	v0,zero,0x3,0x1
9d005b30:	ac626110 	sw	v0,24848(v1)

    LATA = 0x00;
9d005b34:	3c02bf88 	lui	v0,0xbf88
9d005b38:	ac406030 	sw	zero,24624(v0)
    LATB = 0x00;
9d005b3c:	3c02bf88 	lui	v0,0xbf88
9d005b40:	ac406130 	sw	zero,24880(v0)
#endif
#else
#error Unknown device configuration
#endif
    
    l_PepLogicData.pvLogicContext = UtPepLogicAllocLogicContext();
9d005b44:	0f40101d 	jal	9d004074 <UtPepLogicAllocLogicContext>
9d005b48:	00000000 	nop
9d005b4c:	00401821 	move	v1,v0
9d005b50:	3c02a000 	lui	v0,0xa000
9d005b54:	2442011c 	addiu	v0,v0,284
9d005b58:	ac430008 	sw	v1,8(v0)
    l_PepLogicData.pReadBitPortFunc = lPepLogicReadBitPort;
9d005b5c:	3c02a000 	lui	v0,0xa000
9d005b60:	3c039d00 	lui	v1,0x9d00
9d005b64:	24634b2c 	addiu	v1,v1,19244
9d005b68:	ac43011c 	sw	v1,284(v0)
    l_PepLogicData.pWritePortFunc = lPepLogicWritePort;
9d005b6c:	3c02a000 	lui	v0,0xa000
9d005b70:	2442011c 	addiu	v0,v0,284
9d005b74:	3c039d00 	lui	v1,0x9d00
9d005b78:	24634b70 	addiu	v1,v1,19312
9d005b7c:	ac430004 	sw	v1,4(v0)
    
    memset(pResponseData, CPepErrorInitializeData, sizeof(*pResponseData));
9d005b80:	8fc4001c 	lw	a0,28(s8)
9d005b84:	240500ff 	li	a1,255
9d005b88:	24060040 	li	a2,64
9d005b8c:	0f401c3e 	jal	9d0070f8 <memset>
9d005b90:	00000000 	nop
    memset(pCommandData, CPepErrorInitializeData, sizeof(*pCommandData));
9d005b94:	8fc40018 	lw	a0,24(s8)
9d005b98:	240500ff 	li	a1,255
9d005b9c:	24060041 	li	a2,65
9d005ba0:	0f401c3e 	jal	9d0070f8 <memset>
9d005ba4:	00000000 	nop
    
    // In the future add way to check if the EPROM+ is attached 
    
    UtPepLogicReset(&l_PepLogicData);
9d005ba8:	3c02a000 	lui	v0,0xa000
9d005bac:	2444011c 	addiu	a0,v0,284
9d005bb0:	0f401273 	jal	9d0049cc <UtPepLogicReset>
9d005bb4:	00000000 	nop
}
9d005bb8:	03c0e821 	move	sp,s8
9d005bbc:	8fbf0014 	lw	ra,20(sp)
9d005bc0:	8fbe0010 	lw	s8,16(sp)
9d005bc4:	27bd0018 	addiu	sp,sp,24
9d005bc8:	03e00008 	jr	ra
9d005bcc:	00000000 	nop

9d005bd0 <ProcessCommand>:

void ProcessCommand(
  TUtPepCommandData* pCommandData,
  TUtPepResponseData* pResponseData)
{
9d005bd0:	27bdffe8 	addiu	sp,sp,-24
9d005bd4:	afbf0014 	sw	ra,20(sp)
9d005bd8:	afbe0010 	sw	s8,16(sp)
9d005bdc:	03a0f021 	move	s8,sp
9d005be0:	afc40018 	sw	a0,24(s8)
9d005be4:	afc5001c 	sw	a1,28(s8)
    switch (pCommandData->Command)
9d005be8:	8fc20018 	lw	v0,24(s8)
9d005bec:	90420000 	lbu	v0,0(v0)
9d005bf0:	2c430082 	sltiu	v1,v0,130
9d005bf4:	106000d8 	beqz	v1,9d005f58 <ProcessCommand+0x388>
9d005bf8:	00000000 	nop
9d005bfc:	00021880 	sll	v1,v0,0x2
9d005c00:	3c029d00 	lui	v0,0x9d00
9d005c04:	24425c18 	addiu	v0,v0,23576
9d005c08:	00621021 	addu	v0,v1,v0
9d005c0c:	8c420000 	lw	v0,0(v0)
9d005c10:	00400008 	jr	v0
9d005c14:	00000000 	nop
9d005c18:	9d005f58 	0x9d005f58
9d005c1c:	9d005e20 	0x9d005e20
9d005c20:	9d005e38 	0x9d005e38
9d005c24:	9d005e50 	0x9d005e50
9d005c28:	9d005e68 	0x9d005e68
9d005c2c:	9d005e80 	0x9d005e80
9d005c30:	9d005e98 	0x9d005e98
9d005c34:	9d005eb0 	0x9d005eb0
9d005c38:	9d005ec8 	0x9d005ec8
9d005c3c:	9d005ee0 	0x9d005ee0
9d005c40:	9d005ef8 	0x9d005ef8
9d005c44:	9d005f10 	0x9d005f10
9d005c48:	9d005f28 	0x9d005f28
9d005c4c:	9d005f58 	0x9d005f58
9d005c50:	9d005f58 	0x9d005f58
9d005c54:	9d005f58 	0x9d005f58
9d005c58:	9d005f58 	0x9d005f58
9d005c5c:	9d005f58 	0x9d005f58
9d005c60:	9d005f58 	0x9d005f58
9d005c64:	9d005f58 	0x9d005f58
9d005c68:	9d005f58 	0x9d005f58
9d005c6c:	9d005f58 	0x9d005f58
9d005c70:	9d005f58 	0x9d005f58
9d005c74:	9d005f58 	0x9d005f58
9d005c78:	9d005f58 	0x9d005f58
9d005c7c:	9d005f58 	0x9d005f58
9d005c80:	9d005f58 	0x9d005f58
9d005c84:	9d005f58 	0x9d005f58
9d005c88:	9d005f58 	0x9d005f58
9d005c8c:	9d005f58 	0x9d005f58
9d005c90:	9d005f58 	0x9d005f58
9d005c94:	9d005f58 	0x9d005f58
9d005c98:	9d005f58 	0x9d005f58
9d005c9c:	9d005f58 	0x9d005f58
9d005ca0:	9d005f58 	0x9d005f58
9d005ca4:	9d005f58 	0x9d005f58
9d005ca8:	9d005f58 	0x9d005f58
9d005cac:	9d005f58 	0x9d005f58
9d005cb0:	9d005f58 	0x9d005f58
9d005cb4:	9d005f58 	0x9d005f58
9d005cb8:	9d005f58 	0x9d005f58
9d005cbc:	9d005f58 	0x9d005f58
9d005cc0:	9d005f58 	0x9d005f58
9d005cc4:	9d005f58 	0x9d005f58
9d005cc8:	9d005f58 	0x9d005f58
9d005ccc:	9d005f58 	0x9d005f58
9d005cd0:	9d005f58 	0x9d005f58
9d005cd4:	9d005f58 	0x9d005f58
9d005cd8:	9d005f58 	0x9d005f58
9d005cdc:	9d005f58 	0x9d005f58
9d005ce0:	9d005f58 	0x9d005f58
9d005ce4:	9d005f58 	0x9d005f58
9d005ce8:	9d005f58 	0x9d005f58
9d005cec:	9d005f58 	0x9d005f58
9d005cf0:	9d005f58 	0x9d005f58
9d005cf4:	9d005f58 	0x9d005f58
9d005cf8:	9d005f58 	0x9d005f58
9d005cfc:	9d005f58 	0x9d005f58
9d005d00:	9d005f58 	0x9d005f58
9d005d04:	9d005f58 	0x9d005f58
9d005d08:	9d005f58 	0x9d005f58
9d005d0c:	9d005f58 	0x9d005f58
9d005d10:	9d005f58 	0x9d005f58
9d005d14:	9d005f58 	0x9d005f58
9d005d18:	9d005f58 	0x9d005f58
9d005d1c:	9d005f58 	0x9d005f58
9d005d20:	9d005f58 	0x9d005f58
9d005d24:	9d005f58 	0x9d005f58
9d005d28:	9d005f58 	0x9d005f58
9d005d2c:	9d005f58 	0x9d005f58
9d005d30:	9d005f58 	0x9d005f58
9d005d34:	9d005f58 	0x9d005f58
9d005d38:	9d005f58 	0x9d005f58
9d005d3c:	9d005f58 	0x9d005f58
9d005d40:	9d005f58 	0x9d005f58
9d005d44:	9d005f58 	0x9d005f58
9d005d48:	9d005f58 	0x9d005f58
9d005d4c:	9d005f58 	0x9d005f58
9d005d50:	9d005f58 	0x9d005f58
9d005d54:	9d005f58 	0x9d005f58
9d005d58:	9d005f58 	0x9d005f58
9d005d5c:	9d005f58 	0x9d005f58
9d005d60:	9d005f58 	0x9d005f58
9d005d64:	9d005f58 	0x9d005f58
9d005d68:	9d005f58 	0x9d005f58
9d005d6c:	9d005f58 	0x9d005f58
9d005d70:	9d005f58 	0x9d005f58
9d005d74:	9d005f58 	0x9d005f58
9d005d78:	9d005f58 	0x9d005f58
9d005d7c:	9d005f58 	0x9d005f58
9d005d80:	9d005f58 	0x9d005f58
9d005d84:	9d005f58 	0x9d005f58
9d005d88:	9d005f58 	0x9d005f58
9d005d8c:	9d005f58 	0x9d005f58
9d005d90:	9d005f58 	0x9d005f58
9d005d94:	9d005f58 	0x9d005f58
9d005d98:	9d005f58 	0x9d005f58
9d005d9c:	9d005f58 	0x9d005f58
9d005da0:	9d005f58 	0x9d005f58
9d005da4:	9d005f58 	0x9d005f58
9d005da8:	9d005f58 	0x9d005f58
9d005dac:	9d005f58 	0x9d005f58
9d005db0:	9d005f58 	0x9d005f58
9d005db4:	9d005f58 	0x9d005f58
9d005db8:	9d005f58 	0x9d005f58
9d005dbc:	9d005f58 	0x9d005f58
9d005dc0:	9d005f58 	0x9d005f58
9d005dc4:	9d005f58 	0x9d005f58
9d005dc8:	9d005f58 	0x9d005f58
9d005dcc:	9d005f58 	0x9d005f58
9d005dd0:	9d005f58 	0x9d005f58
9d005dd4:	9d005f58 	0x9d005f58
9d005dd8:	9d005f58 	0x9d005f58
9d005ddc:	9d005f58 	0x9d005f58
9d005de0:	9d005f58 	0x9d005f58
9d005de4:	9d005f58 	0x9d005f58
9d005de8:	9d005f58 	0x9d005f58
9d005dec:	9d005f58 	0x9d005f58
9d005df0:	9d005f58 	0x9d005f58
9d005df4:	9d005f58 	0x9d005f58
9d005df8:	9d005f58 	0x9d005f58
9d005dfc:	9d005f58 	0x9d005f58
9d005e00:	9d005f58 	0x9d005f58
9d005e04:	9d005f58 	0x9d005f58
9d005e08:	9d005f58 	0x9d005f58
9d005e0c:	9d005f58 	0x9d005f58
9d005e10:	9d005f58 	0x9d005f58
9d005e14:	9d005f58 	0x9d005f58
9d005e18:	9d005f58 	0x9d005f58
9d005e1c:	9d005f40 	0x9d005f40
    {
        case CPepVersionCommand:
            lProcessVersionCommand(pCommandData, pResponseData);
9d005e20:	8fc40018 	lw	a0,24(s8)
9d005e24:	8fc5001c 	lw	a1,28(s8)
9d005e28:	0f40134c 	jal	9d004d30 <UtPepLogicSetDelays+0x278>
9d005e2c:	00000000 	nop
            break;
9d005e30:	0b4017db 	j	9d005f6c <ProcessCommand+0x39c>
9d005e34:	00000000 	nop
        case CPepResetCommand:
            lProcessResetCommand(pCommandData, pResponseData);
9d005e38:	8fc40018 	lw	a0,24(s8)
9d005e3c:	8fc5001c 	lw	a1,28(s8)
9d005e40:	0f401383 	jal	9d004e0c <UtPepLogicSetDelays+0x354>
9d005e44:	00000000 	nop
            break;
9d005e48:	0b4017db 	j	9d005f6c <ProcessCommand+0x39c>
9d005e4c:	00000000 	nop
        case CPepSetProgrammerModeCommand:
            lProcessSetProgrammerModeCommand(pCommandData, pResponseData);
9d005e50:	8fc40018 	lw	a0,24(s8)
9d005e54:	8fc5001c 	lw	a1,28(s8)
9d005e58:	0f40139b 	jal	9d004e6c <UtPepLogicSetDelays+0x3b4>
9d005e5c:	00000000 	nop
            break;
9d005e60:	0b4017db 	j	9d005f6c <ProcessCommand+0x39c>
9d005e64:	00000000 	nop
        case CPepSetVccModeCommand:
            lProcessSetVccModeCommand(pCommandData, pResponseData);
9d005e68:	8fc40018 	lw	a0,24(s8)
9d005e6c:	8fc5001c 	lw	a1,28(s8)
9d005e70:	0f4013b9 	jal	9d004ee4 <UtPepLogicSetDelays+0x42c>
9d005e74:	00000000 	nop
            break;
9d005e78:	0b4017db 	j	9d005f6c <ProcessCommand+0x39c>
9d005e7c:	00000000 	nop
        case CPepSetPinPulseModeCommand:
            lProcessSetPinPulseModeCommand(pCommandData, pResponseData);
9d005e80:	8fc40018 	lw	a0,24(s8)
9d005e84:	8fc5001c 	lw	a1,28(s8)
9d005e88:	0f4013d7 	jal	9d004f5c <UtPepLogicSetDelays+0x4a4>
9d005e8c:	00000000 	nop
            break;
9d005e90:	0b4017db 	j	9d005f6c <ProcessCommand+0x39c>
9d005e94:	00000000 	nop
        case CPepSetVppModeCommand:
            lProcessSetVppModeCommand(pCommandData, pResponseData);
9d005e98:	8fc40018 	lw	a0,24(s8)
9d005e9c:	8fc5001c 	lw	a1,28(s8)
9d005ea0:	0f4013f5 	jal	9d004fd4 <UtPepLogicSetDelays+0x51c>
9d005ea4:	00000000 	nop
            break;
9d005ea8:	0b4017db 	j	9d005f6c <ProcessCommand+0x39c>
9d005eac:	00000000 	nop
        case CPepReadDataCommand:
            lProcessReadDataCommand(pCommandData, pResponseData);
9d005eb0:	8fc40018 	lw	a0,24(s8)
9d005eb4:	8fc5001c 	lw	a1,28(s8)
9d005eb8:	0f401413 	jal	9d00504c <UtPepLogicSetDelays+0x594>
9d005ebc:	00000000 	nop
            break;
9d005ec0:	0b4017db 	j	9d005f6c <ProcessCommand+0x39c>
9d005ec4:	00000000 	nop
        case CPepReadUserDataCommand:
            lProcessReadUserDataCommand(pCommandData, pResponseData);
9d005ec8:	8fc40018 	lw	a0,24(s8)
9d005ecc:	8fc5001c 	lw	a1,28(s8)
9d005ed0:	0f401461 	jal	9d005184 <UtPepLogicSetDelays+0x6cc>
9d005ed4:	00000000 	nop
            break;
9d005ed8:	0b4017db 	j	9d005f6c <ProcessCommand+0x39c>
9d005edc:	00000000 	nop
        case CPepReadUserDataWithDelayCommand:
            lProcessReadUserDataWithDelayCommand(pCommandData, pResponseData);
9d005ee0:	8fc40018 	lw	a0,24(s8)
9d005ee4:	8fc5001c 	lw	a1,28(s8)
9d005ee8:	0f4014c2 	jal	9d005308 <UtPepLogicSetDelays+0x850>
9d005eec:	00000000 	nop
            break;
9d005ef0:	0b4017db 	j	9d005f6c <ProcessCommand+0x39c>
9d005ef4:	00000000 	nop
        case CPepProgramDataCommand:
            lProcessProgramDataCommand(pCommandData, pResponseData);
9d005ef8:	8fc40018 	lw	a0,24(s8)
9d005efc:	8fc5001c 	lw	a1,28(s8)
9d005f00:	0f40151e 	jal	9d005478 <UtPepLogicSetDelays+0x9c0>
9d005f04:	00000000 	nop
            break;
9d005f08:	0b4017db 	j	9d005f6c <ProcessCommand+0x39c>
9d005f0c:	00000000 	nop
        case CPepProgramUserDataCommand:
            lProcessProgramUserDataCommand(pCommandData, pResponseData);
9d005f10:	8fc40018 	lw	a0,24(s8)
9d005f14:	8fc5001c 	lw	a1,28(s8)
9d005f18:	0f401569 	jal	9d0055a4 <UtPepLogicSetDelays+0xaec>
9d005f1c:	00000000 	nop
            break;
9d005f20:	0b4017db 	j	9d005f6c <ProcessCommand+0x39c>
9d005f24:	00000000 	nop
        case CPepSetDelaysCommand:
            lProcessSetDelaysCommand(pCommandData, pResponseData);
9d005f28:	8fc40018 	lw	a0,24(s8)
9d005f2c:	8fc5001c 	lw	a1,28(s8)
9d005f30:	0f4015ca 	jal	9d005728 <UtPepLogicSetDelays+0xc70>
9d005f34:	00000000 	nop
            break;
9d005f38:	0b4017db 	j	9d005f6c <ProcessCommand+0x39c>
9d005f3c:	00000000 	nop
        case CPepDebugWritePortDataCommand:
            lProcessDebugWritePortDataCommand(pCommandData, pResponseData);
9d005f40:	8fc40018 	lw	a0,24(s8)
9d005f44:	8fc5001c 	lw	a1,28(s8)
9d005f48:	0f4015ec 	jal	9d0057b0 <UtPepLogicSetDelays+0xcf8>
9d005f4c:	00000000 	nop
            break;
9d005f50:	0b4017db 	j	9d005f6c <ProcessCommand+0x39c>
9d005f54:	00000000 	nop
        default:
            lProcessUnknownCommand(pCommandData, pResponseData);
9d005f58:	8fc40018 	lw	a0,24(s8)
9d005f5c:	8fc5001c 	lw	a1,28(s8)
9d005f60:	0f401609 	jal	9d005824 <UtPepLogicSetDelays+0xd6c>
9d005f64:	00000000 	nop
            break;
9d005f68:	00000000 	nop
    }
}
9d005f6c:	03c0e821 	move	sp,s8
9d005f70:	8fbf0014 	lw	ra,20(sp)
9d005f74:	8fbe0010 	lw	s8,16(sp)
9d005f78:	27bd0018 	addiu	sp,sp,24
9d005f7c:	03e00008 	jr	ra
9d005f80:	00000000 	nop
    UtTimeDelayMs(100); // 1 second
}
#endif

static void lInitializeSystem(void)
{
9d005f84:	27bdffe8 	addiu	sp,sp,-24
9d005f88:	afbf0014 	sw	ra,20(sp)
9d005f8c:	afbe0010 	sw	s8,16(sp)
9d005f90:	03a0f021 	move	s8,sp
    PORTDbits.RD1 = 0; // turn LED2 off
#else
#error Unknown device configuration
#endif

    l_PepDeviceState = PEP_DEVICE_INITIALIZE_STATE;
9d005f94:	a3808014 	sb	zero,-32748(gp)
    
    l_EndPoint1OutHandle = 0;
9d005f98:	af808018 	sw	zero,-32744(gp)
    l_EndPoint1InHandle = 0;
9d005f9c:	af80801c 	sw	zero,-32740(gp)
    
    InitProcessCommand(&l_CommandData, &l_ResponseData);
9d005fa0:	3c02a000 	lui	v0,0xa000
9d005fa4:	24440064 	addiu	a0,v0,100
9d005fa8:	3c02a000 	lui	v0,0xa000
9d005fac:	244500a8 	addiu	a1,v0,168
9d005fb0:	0f401616 	jal	9d005858 <InitProcessCommand>
9d005fb4:	00000000 	nop
    }
#endif
	
    // Initializes the USB module SFRs and firmware variables to known states.
    
    USBDeviceInit();
9d005fb8:	0f400002 	jal	9d000008 <USBDeviceInit>
9d005fbc:	00000000 	nop
}
9d005fc0:	03c0e821 	move	sp,s8
9d005fc4:	8fbf0014 	lw	ra,20(sp)
9d005fc8:	8fbe0010 	lw	s8,16(sp)
9d005fcc:	27bd0018 	addiu	sp,sp,24
9d005fd0:	03e00008 	jr	ra
9d005fd4:	00000000 	nop

static void lProcessIO(void)
{   
9d005fd8:	27bdffe8 	addiu	sp,sp,-24
9d005fdc:	afbf0014 	sw	ra,20(sp)
9d005fe0:	afbe0010 	sw	s8,16(sp)
9d005fe4:	03a0f021 	move	s8,sp
    //User Application USB tasks below.
    //Note: The user application should not begin attempting to read/write over the USB
    //until after the device has been fully enumerated.  After the device is fully
    //enumerated, the USBDeviceState will be set to "CONFIGURED_STATE".

    if ((USBDeviceState < CONFIGURED_STATE) || (USBSuspendControl == 1))
9d005fe8:	8f828030 	lw	v0,-32720(gp)
9d005fec:	2c420020 	sltiu	v0,v0,32
9d005ff0:	1440005a 	bnez	v0,9d00615c <ProcessCommand+0x58c>
9d005ff4:	00000000 	nop
9d005ff8:	3c02bf88 	lui	v0,0xbf88
9d005ffc:	8c425080 	lw	v0,20608(v0)
9d006000:	30420002 	andi	v0,v0,0x2
9d006004:	14400058 	bnez	v0,9d006168 <ProcessCommand+0x598>
9d006008:	00000000 	nop
    {
        return;
    }
    
    switch (l_PepDeviceState)
9d00600c:	93828014 	lbu	v0,-32748(gp)
9d006010:	24030001 	li	v1,1
9d006014:	10430010 	beq	v0,v1,9d006058 <ProcessCommand+0x488>
9d006018:	00000000 	nop
9d00601c:	28430002 	slti	v1,v0,2
9d006020:	10600005 	beqz	v1,9d006038 <ProcessCommand+0x468>
9d006024:	00000000 	nop
9d006028:	10400043 	beqz	v0,9d006138 <ProcessCommand+0x568>
9d00602c:	00000000 	nop
9d006030:	0b401852 	j	9d006148 <ProcessCommand+0x578>
9d006034:	00000000 	nop
9d006038:	24030002 	li	v1,2
9d00603c:	10430015 	beq	v0,v1,9d006094 <ProcessCommand+0x4c4>
9d006040:	00000000 	nop
9d006044:	24030003 	li	v1,3
9d006048:	1043001c 	beq	v0,v1,9d0060bc <ProcessCommand+0x4ec>
9d00604c:	00000000 	nop
9d006050:	0b401852 	j	9d006148 <ProcessCommand+0x578>
9d006054:	00000000 	nop
    {
        case PEP_DEVICE_IDLE_STATE:
            // Check if received a command
            
            if (!USBHandleBusy(l_EndPoint1OutHandle))
9d006058:	8f828018 	lw	v0,-32744(gp)
9d00605c:	10400009 	beqz	v0,9d006084 <ProcessCommand+0x4b4>
9d006060:	00000000 	nop
9d006064:	8f828018 	lw	v0,-32744(gp)
9d006068:	90420000 	lbu	v0,0(v0)
9d00606c:	304300ff 	andi	v1,v0,0xff
9d006070:	2402ff80 	li	v0,-128
9d006074:	00621024 	and	v0,v1,v0
9d006078:	304200ff 	andi	v0,v0,0xff
9d00607c:	1440003d 	bnez	v0,9d006174 <ProcessCommand+0x5a4>
9d006080:	00000000 	nop
            {
                l_PepDeviceState = PEP_DEVICE_DATA_IN_STATE;
9d006084:	24020002 	li	v0,2
9d006088:	a3828014 	sb	v0,-32748(gp)
            }
            break;
9d00608c:	0b401861 	j	9d006184 <ProcessCommand+0x5b4>
9d006090:	00000000 	nop
        case PEP_DEVICE_DATA_IN_STATE:
            ProcessCommand(&l_CommandData, &l_ResponseData);
9d006094:	3c02a000 	lui	v0,0xa000
9d006098:	24440064 	addiu	a0,v0,100
9d00609c:	3c02a000 	lui	v0,0xa000
9d0060a0:	244500a8 	addiu	a1,v0,168
9d0060a4:	0f4016f4 	jal	9d005bd0 <ProcessCommand>
9d0060a8:	00000000 	nop
            
            l_PepDeviceState = PEP_DEVICE_DATA_OUT_STATE;
9d0060ac:	24020003 	li	v0,3
9d0060b0:	a3828014 	sb	v0,-32748(gp)
            break;
9d0060b4:	0b401861 	j	9d006184 <ProcessCommand+0x5b4>
9d0060b8:	00000000 	nop
        case PEP_DEVICE_DATA_OUT_STATE:
            if (!USBHandleBusy(l_EndPoint1InHandle))
9d0060bc:	8f82801c 	lw	v0,-32740(gp)
9d0060c0:	10400009 	beqz	v0,9d0060e8 <ProcessCommand+0x518>
9d0060c4:	00000000 	nop
9d0060c8:	8f82801c 	lw	v0,-32740(gp)
9d0060cc:	90420000 	lbu	v0,0(v0)
9d0060d0:	304300ff 	andi	v1,v0,0xff
9d0060d4:	2402ff80 	li	v0,-128
9d0060d8:	00621024 	and	v0,v1,v0
9d0060dc:	304200ff 	andi	v0,v0,0xff
9d0060e0:	14400027 	bnez	v0,9d006180 <ProcessCommand+0x5b0>
9d0060e4:	00000000 	nop
            {
                l_EndPoint1InHandle = USBTxOnePacket(CPepFirmwareEndPointNumber,
9d0060e8:	24040001 	li	a0,1
9d0060ec:	24050001 	li	a1,1
9d0060f0:	3c02a000 	lui	v0,0xa000
9d0060f4:	244600a8 	addiu	a2,v0,168
9d0060f8:	24070040 	li	a3,64
9d0060fc:	0f400209 	jal	9d000824 <USBTransferOnePacket>
9d006100:	00000000 	nop
9d006104:	af82801c 	sw	v0,-32740(gp)
                                                     (UINT8*)&l_ResponseData,
                                                     sizeof(l_ResponseData));

                l_EndPoint1OutHandle = USBRxOnePacket(CPepFirmwareEndPointNumber,
9d006108:	24040001 	li	a0,1
9d00610c:	00002821 	move	a1,zero
9d006110:	3c02a000 	lui	v0,0xa000
9d006114:	24460064 	addiu	a2,v0,100
9d006118:	24070041 	li	a3,65
9d00611c:	0f400209 	jal	9d000824 <USBTransferOnePacket>
9d006120:	00000000 	nop
9d006124:	af828018 	sw	v0,-32744(gp)
                                                     (UINT8*)&l_CommandData,
                                                     sizeof(l_CommandData));

                l_PepDeviceState = PEP_DEVICE_IDLE_STATE;
9d006128:	24020001 	li	v0,1
9d00612c:	a3828014 	sb	v0,-32748(gp)
            }
            break;
9d006130:	0b401861 	j	9d006184 <ProcessCommand+0x5b4>
9d006134:	00000000 	nop
        case PEP_DEVICE_INITIALIZE_STATE:
            l_PepDeviceState = PEP_DEVICE_IDLE_STATE;
9d006138:	24020001 	li	v0,1
9d00613c:	a3828014 	sb	v0,-32748(gp)
            break;
9d006140:	0b401861 	j	9d006184 <ProcessCommand+0x5b4>
9d006144:	00000000 	nop
            lBlinkLED2OneShot();
            
            goto blink_unknown_state;
#endif

            l_PepDeviceState = PEP_DEVICE_IDLE_STATE;
9d006148:	24020001 	li	v0,1
9d00614c:	a3828014 	sb	v0,-32748(gp)
            break;
9d006150:	00000000 	nop
9d006154:	0b401861 	j	9d006184 <ProcessCommand+0x5b4>
9d006158:	00000000 	nop
    //until after the device has been fully enumerated.  After the device is fully
    //enumerated, the USBDeviceState will be set to "CONFIGURED_STATE".

    if ((USBDeviceState < CONFIGURED_STATE) || (USBSuspendControl == 1))
    {
        return;
9d00615c:	00000000 	nop
9d006160:	0b401861 	j	9d006184 <ProcessCommand+0x5b4>
9d006164:	00000000 	nop
9d006168:	00000000 	nop
9d00616c:	0b401861 	j	9d006184 <ProcessCommand+0x5b4>
9d006170:	00000000 	nop
            
            if (!USBHandleBusy(l_EndPoint1OutHandle))
            {
                l_PepDeviceState = PEP_DEVICE_DATA_IN_STATE;
            }
            break;
9d006174:	00000000 	nop
9d006178:	0b401861 	j	9d006184 <ProcessCommand+0x5b4>
9d00617c:	00000000 	nop
                                                     (UINT8*)&l_CommandData,
                                                     sizeof(l_CommandData));

                l_PepDeviceState = PEP_DEVICE_IDLE_STATE;
            }
            break;
9d006180:	00000000 	nop
#endif

            l_PepDeviceState = PEP_DEVICE_IDLE_STATE;
            break;
    }
}
9d006184:	03c0e821 	move	sp,s8
9d006188:	8fbf0014 	lw	ra,20(sp)
9d00618c:	8fbe0010 	lw	s8,16(sp)
9d006190:	27bd0018 	addiu	sp,sp,24
9d006194:	03e00008 	jr	ra
9d006198:	00000000 	nop

9d00619c <ExecutePepDevice>:

int ExecutePepDevice(void)
{
9d00619c:	27bdffe8 	addiu	sp,sp,-24
9d0061a0:	afbf0014 	sw	ra,20(sp)
9d0061a4:	afbe0010 	sw	s8,16(sp)
9d0061a8:	03a0f021 	move	s8,sp
    lInitializeSystem();
9d0061ac:	0f4017e1 	jal	9d005f84 <ProcessCommand+0x3b4>
9d0061b0:	00000000 	nop
    while(1)
    {
#if defined(USB_POLLING)
		// Check bus status and service USB interrupts.

        USBDeviceTasks(); // Interrupt or polling method.  If using polling, must call
9d0061b4:	0f4000bd 	jal	9d0002f4 <USBDeviceTasks>
9d0061b8:	00000000 	nop
#endif

		// Application-specific tasks.
		// Application related code may be added here, or in the lProcessIO() function.

        lProcessIO();        
9d0061bc:	0f4017f6 	jal	9d005fd8 <ProcessCommand+0x408>
9d0061c0:	00000000 	nop
    }
9d0061c4:	0b40186d 	j	9d0061b4 <ExecutePepDevice+0x18>
9d0061c8:	00000000 	nop

9d0061cc <USBCBSuspend>:
 *
 * Note:            None
 *****************************************************************************/

void USBCBSuspend(void)
{
9d0061cc:	27bdfff8 	addiu	sp,sp,-8
9d0061d0:	afbe0004 	sw	s8,4(sp)
9d0061d4:	03a0f021 	move	s8,sp
	//RestoreIOPinsToNormal();									//Preferably, this should be done in the USBCBWakeFromSuspend() function instead.

	//IMPORTANT NOTE: Do not clear the USBActivityIF (ACTVIF) bit here.  This bit is 
	//cleared inside the usb_device.c file.  Clearing USBActivityIF here will cause 
	//things to not work as intended.	
}
9d0061d8:	03c0e821 	move	sp,s8
9d0061dc:	8fbe0004 	lw	s8,4(sp)
9d0061e0:	27bd0008 	addiu	sp,sp,8
9d0061e4:	03e00008 	jr	ra
9d0061e8:	00000000 	nop

9d0061ec <USBCBWakeFromSuspend>:
 *
 * Note:            None
 *****************************************************************************/

void USBCBWakeFromSuspend(void)
{
9d0061ec:	27bdfff8 	addiu	sp,sp,-8
9d0061f0:	afbe0004 	sw	s8,4(sp)
9d0061f4:	03a0f021 	move	s8,sp
	// packets.  In order to do this, the USB module must receive proper
	// clocking (IE: 48MHz clock must be available to SIE for full speed USB
	// operation).  
	// Make sure the selected oscillator settings are consistent with USB operation 
	// before returning from this function.
}
9d0061f8:	03c0e821 	move	sp,s8
9d0061fc:	8fbe0004 	lw	s8,4(sp)
9d006200:	27bd0008 	addiu	sp,sp,8
9d006204:	03e00008 	jr	ra
9d006208:	00000000 	nop

9d00620c <USBCB_SOF_Handler>:
 *
 * Note:            None
 *******************************************************************/

void USBCB_SOF_Handler(void)
{
9d00620c:	27bdfff8 	addiu	sp,sp,-8
9d006210:	afbe0004 	sw	s8,4(sp)
9d006214:	03a0f021 	move	s8,sp
    // No need to clear UIRbits.SOFIF to 0 here.
    // Callback caller is already doing that.
}
9d006218:	03c0e821 	move	sp,s8
9d00621c:	8fbe0004 	lw	s8,4(sp)
9d006220:	27bd0008 	addiu	sp,sp,8
9d006224:	03e00008 	jr	ra
9d006228:	00000000 	nop

9d00622c <USBCBErrorHandler>:
 *
 * Note:            None
 *******************************************************************/

void USBCBErrorHandler(void)
{
9d00622c:	27bdfff8 	addiu	sp,sp,-8
9d006230:	afbe0004 	sw	s8,4(sp)
9d006234:	03a0f021 	move	s8,sp
	// automatically, without the need for application firmware
	// intervention.
	
	// Nevertheless, this callback function is provided, such as
	// for debugging purposes.
}
9d006238:	03c0e821 	move	sp,s8
9d00623c:	8fbe0004 	lw	s8,4(sp)
9d006240:	27bd0008 	addiu	sp,sp,8
9d006244:	03e00008 	jr	ra
9d006248:	00000000 	nop

9d00624c <USBCBCheckOtherReq>:
 *
 * Note:            None
 *******************************************************************/

void USBCBCheckOtherReq(void)
{
9d00624c:	27bdffe8 	addiu	sp,sp,-24
9d006250:	afbf0014 	sw	ra,20(sp)
9d006254:	afbe0010 	sw	s8,16(sp)
9d006258:	03a0f021 	move	s8,sp
#if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
    //Check for class specific requests, and if necessary, handle it.
    USBCheckVendorRequest();
9d00625c:	0f401b3a 	jal	9d006ce8 <USBCheckVendorRequest>
9d006260:	00000000 	nop
#endif
}
9d006264:	03c0e821 	move	sp,s8
9d006268:	8fbf0014 	lw	ra,20(sp)
9d00626c:	8fbe0010 	lw	s8,16(sp)
9d006270:	27bd0018 	addiu	sp,sp,24
9d006274:	03e00008 	jr	ra
9d006278:	00000000 	nop

9d00627c <USBCBStdSetDscHandler>:
 *
 * Note:            None
 *******************************************************************/

void USBCBStdSetDscHandler(void)
{
9d00627c:	27bdfff8 	addiu	sp,sp,-8
9d006280:	afbe0004 	sw	s8,4(sp)
9d006284:	03a0f021 	move	s8,sp
    // Must claim session ownership if supporting this request
}
9d006288:	03c0e821 	move	sp,s8
9d00628c:	8fbe0004 	lw	s8,4(sp)
9d006290:	27bd0008 	addiu	sp,sp,8
9d006294:	03e00008 	jr	ra
9d006298:	00000000 	nop

9d00629c <USBCBInitEP>:
 *
 * Note:            None
 *******************************************************************/

void USBCBInitEP(void)
{
9d00629c:	27bdffe8 	addiu	sp,sp,-24
9d0062a0:	afbf0014 	sw	ra,20(sp)
9d0062a4:	afbe0010 	sw	s8,16(sp)
9d0062a8:	03a0f021 	move	s8,sp
    USBEnableEndpoint(CPepFirmwareEndPointNumber,
9d0062ac:	24040001 	li	a0,1
9d0062b0:	2405001d 	li	a1,29
9d0062b4:	0f4001e0 	jal	9d000780 <USBEnableEndpoint>
9d0062b8:	00000000 	nop
                      USB_IN_ENABLED | USB_OUT_ENABLED | USB_HANDSHAKE_ENABLED | USB_DISALLOW_SETUP);

    l_EndPoint1OutHandle = USBRxOnePacket(CPepFirmwareEndPointNumber,
9d0062bc:	24040001 	li	a0,1
9d0062c0:	00002821 	move	a1,zero
9d0062c4:	3c02a000 	lui	v0,0xa000
9d0062c8:	24460064 	addiu	a2,v0,100
9d0062cc:	24070041 	li	a3,65
9d0062d0:	0f400209 	jal	9d000824 <USBTransferOnePacket>
9d0062d4:	00000000 	nop
9d0062d8:	af828018 	sw	v0,-32744(gp)
                                          (UINT8*)&l_CommandData,
                                          sizeof(l_CommandData));
}
9d0062dc:	03c0e821 	move	sp,s8
9d0062e0:	8fbf0014 	lw	ra,20(sp)
9d0062e4:	8fbe0010 	lw	s8,16(sp)
9d0062e8:	27bd0018 	addiu	sp,sp,24
9d0062ec:	03e00008 	jr	ra
9d0062f0:	00000000 	nop

9d0062f4 <USBCBSendResume>:
 *                    Make sure to verify using the MPLAB SIM's Stopwatch
 *                    and verify the actual signal on an oscilloscope.
 *******************************************************************/

void USBCBSendResume(void)
{
9d0062f4:	27bdffe8 	addiu	sp,sp,-24
9d0062f8:	afbf0014 	sw	ra,20(sp)
9d0062fc:	afbe0010 	sw	s8,16(sp)
9d006300:	03a0f021 	move	s8,sp
    //the device as remote wakeup capable, AND, if the feature is enabled
    //on the host (ex: on Windows based hosts, in the device manager 
    //properties page for the USB device, power management tab, the 
    //"Allow this device to bring the computer out of standby." checkbox 
    //should be checked).
    if (USBGetRemoteWakeupStatus() == TRUE) 
9d006304:	93838068 	lbu	v1,-32664(gp)
9d006308:	24020001 	li	v0,1
9d00630c:	14620027 	bne	v1,v0,9d0063ac <USBCBSendResume+0xb8>
9d006310:	00000000 	nop
    {
        //Verify that the USB bus is in fact suspended, before we send
        //remote wakeup signaling.
        if (USBIsBusSuspended() == TRUE)
9d006314:	93838054 	lbu	v1,-32684(gp)
9d006318:	24020001 	li	v0,1
9d00631c:	14620023 	bne	v1,v0,9d0063ac <USBCBSendResume+0xb8>
9d006320:	00000000 	nop
#if defined(USB_INTERRUPT)
            MUSBMaskInterrupts();
#endif
            
            //Clock switch to settings consistent with normal USB operation.
            USBCBWakeFromSuspend();
9d006324:	0f40187b 	jal	9d0061ec <USBCBWakeFromSuspend>
9d006328:	00000000 	nop
            
            USBSuspendControl = 0;
9d00632c:	3c03bf88 	lui	v1,0xbf88
9d006330:	8c625080 	lw	v0,20608(v1)
9d006334:	7c020844 	ins	v0,zero,0x1,0x1
9d006338:	ac625080 	sw	v0,20608(v1)
            
            USBBusIsSuspended = FALSE;  //So we don't execute this code again, 
9d00633c:	a3808054 	sb	zero,-32684(gp)
            //device must continuously see 5ms+ of idle on the bus, before it sends
            //remote wakeup signaling.  One way to be certain that this parameter
            //gets met, is to add a 2ms+ blocking delay here (2ms plus at 
            //least 3ms from bus idle to USBIsBusSuspended() == TRUE, yields
            //5ms+ total delay since start of idle).
            delay_count = 3600U;        
9d006340:	24020e10 	li	v0,3600
9d006344:	a7828020 	sh	v0,-32736(gp)

            do
            {
                delay_count--;
9d006348:	97828020 	lhu	v0,-32736(gp)
9d00634c:	2442ffff 	addiu	v0,v0,-1
9d006350:	3042ffff 	andi	v0,v0,0xffff
9d006354:	a7828020 	sh	v0,-32736(gp)
            } while(delay_count);
9d006358:	97828020 	lhu	v0,-32736(gp)
9d00635c:	1440fffa 	bnez	v0,9d006348 <USBCBSendResume+0x54>
9d006360:	00000000 	nop
            
            //Now drive the resume K-state signalling onto the USB bus.
            USBResumeControl = 1;       // Start RESUME signaling
9d006364:	3c03bf88 	lui	v1,0xbf88
9d006368:	8c625250 	lw	v0,21072(v1)
9d00636c:	24040001 	li	a0,1
9d006370:	7c821084 	ins	v0,a0,0x2,0x1
9d006374:	ac625250 	sw	v0,21072(v1)

            delay_count = 1800U;        // Set RESUME line for 1-13 ms
9d006378:	24020708 	li	v0,1800
9d00637c:	a7828020 	sh	v0,-32736(gp)

            do
            {
                delay_count--;
9d006380:	97828020 	lhu	v0,-32736(gp)
9d006384:	2442ffff 	addiu	v0,v0,-1
9d006388:	3042ffff 	andi	v0,v0,0xffff
9d00638c:	a7828020 	sh	v0,-32736(gp)
            } while (delay_count);
9d006390:	97828020 	lhu	v0,-32736(gp)
9d006394:	1440fffa 	bnez	v0,9d006380 <USBCBSendResume+0x8c>
9d006398:	00000000 	nop

            USBResumeControl = 0;       //Finished driving resume signaling
9d00639c:	3c03bf88 	lui	v1,0xbf88
9d0063a0:	8c625250 	lw	v0,21072(v1)
9d0063a4:	7c021084 	ins	v0,zero,0x2,0x1
9d0063a8:	ac625250 	sw	v0,21072(v1)
#if defined(USB_INTERRUPT)
            MUSBUnmaskInterrupts();
#endif
        }
    }
}
9d0063ac:	03c0e821 	move	sp,s8
9d0063b0:	8fbf0014 	lw	ra,20(sp)
9d0063b4:	8fbe0010 	lw	s8,16(sp)
9d0063b8:	27bd0018 	addiu	sp,sp,24
9d0063bc:	03e00008 	jr	ra
9d0063c0:	00000000 	nop

9d0063c4 <USER_USB_CALLBACK_EVENT_HANDLER>:
 *
 * Note:            None
 *******************************************************************/

BOOL USER_USB_CALLBACK_EVENT_HANDLER(int event, void* pdata, UINT16 size)
{
9d0063c4:	27bdffe8 	addiu	sp,sp,-24
9d0063c8:	afbf0014 	sw	ra,20(sp)
9d0063cc:	afbe0010 	sw	s8,16(sp)
9d0063d0:	03a0f021 	move	s8,sp
9d0063d4:	afc40018 	sw	a0,24(s8)
9d0063d8:	afc5001c 	sw	a1,28(s8)
9d0063dc:	00c01021 	move	v0,a2
9d0063e0:	a7c20020 	sh	v0,32(s8)
    switch (event)
9d0063e4:	8fc20018 	lw	v0,24(s8)
9d0063e8:	24030072 	li	v1,114
9d0063ec:	1043003f 	beq	v0,v1,9d0064ec <USER_USB_CALLBACK_EVENT_HANDLER+0x128>
9d0063f0:	00000000 	nop
9d0063f4:	28430073 	slti	v1,v0,115
9d0063f8:	10600011 	beqz	v1,9d006440 <USER_USB_CALLBACK_EVENT_HANDLER+0x7c>
9d0063fc:	00000000 	nop
9d006400:	24030002 	li	v1,2
9d006404:	1043002d 	beq	v0,v1,9d0064bc <USER_USB_CALLBACK_EVENT_HANDLER+0xf8>
9d006408:	00000000 	nop
9d00640c:	28430003 	slti	v1,v0,3
9d006410:	10600006 	beqz	v1,9d00642c <USER_USB_CALLBACK_EVENT_HANDLER+0x68>
9d006414:	00000000 	nop
9d006418:	24030001 	li	v1,1
9d00641c:	10430023 	beq	v0,v1,9d0064ac <USER_USB_CALLBACK_EVENT_HANDLER+0xe8>
9d006420:	00000000 	nop
            //     on, by checking the handle value in the *pdata.
            // 2.  Re-arm the endpoint if desired (typically would be the case for OUT 
            //     endpoints).
            break;
        default:
            break;
9d006424:	0b40193c 	j	9d0064f0 <USER_USB_CALLBACK_EVENT_HANDLER+0x12c>
9d006428:	00000000 	nop
 * Note:            None
 *******************************************************************/

BOOL USER_USB_CALLBACK_EVENT_HANDLER(int event, void* pdata, UINT16 size)
{
    switch (event)
9d00642c:	24030003 	li	v1,3
9d006430:	10430026 	beq	v0,v1,9d0064cc <USER_USB_CALLBACK_EVENT_HANDLER+0x108>
9d006434:	00000000 	nop
            // previously armed (UOWN was = 1).  Here would be a good place to:
            // 1.  Determine which endpoint the transaction that just got terminated was 
            //     on, by checking the handle value in the *pdata.
            // 2.  Re-arm the endpoint if desired (typically would be the case for OUT 
            //     endpoints).
            break;
9d006438:	0b40193c 	j	9d0064f0 <USER_USB_CALLBACK_EVENT_HANDLER+0x12c>
9d00643c:	00000000 	nop
 * Note:            None
 *******************************************************************/

BOOL USER_USB_CALLBACK_EVENT_HANDLER(int event, void* pdata, UINT16 size)
{
    switch (event)
9d006440:	24030074 	li	v1,116
9d006444:	10430015 	beq	v0,v1,9d00649c <USER_USB_CALLBACK_EVENT_HANDLER+0xd8>
9d006448:	00000000 	nop
9d00644c:	28430074 	slti	v1,v0,116
9d006450:	1460000a 	bnez	v1,9d00647c <USER_USB_CALLBACK_EVENT_HANDLER+0xb8>
9d006454:	00000000 	nop
9d006458:	24030075 	li	v1,117
9d00645c:	1043000b 	beq	v0,v1,9d00648c <USER_USB_CALLBACK_EVENT_HANDLER+0xc8>
9d006460:	00000000 	nop
9d006464:	3c037fff 	lui	v1,0x7fff
9d006468:	3463ffff 	ori	v1,v1,0xffff
9d00646c:	1043001b 	beq	v0,v1,9d0064dc <USER_USB_CALLBACK_EVENT_HANDLER+0x118>
9d006470:	00000000 	nop
            //     on, by checking the handle value in the *pdata.
            // 2.  Re-arm the endpoint if desired (typically would be the case for OUT 
            //     endpoints).
            break;
        default:
            break;
9d006474:	0b40193c 	j	9d0064f0 <USER_USB_CALLBACK_EVENT_HANDLER+0x12c>
9d006478:	00000000 	nop
    {
        case EVENT_TRANSFER:
            // Add application specific callback task or callback function here if desired.
            break;
        case EVENT_SOF:
            USBCB_SOF_Handler();
9d00647c:	0f401883 	jal	9d00620c <USBCB_SOF_Handler>
9d006480:	00000000 	nop
            break;
9d006484:	0b40193c 	j	9d0064f0 <USER_USB_CALLBACK_EVENT_HANDLER+0x12c>
9d006488:	00000000 	nop
        case EVENT_SUSPEND:
            USBCBSuspend();
9d00648c:	0f401873 	jal	9d0061cc <USBCBSuspend>
9d006490:	00000000 	nop
            break;
9d006494:	0b40193c 	j	9d0064f0 <USER_USB_CALLBACK_EVENT_HANDLER+0x12c>
9d006498:	00000000 	nop
        case EVENT_RESUME:
            USBCBWakeFromSuspend();
9d00649c:	0f40187b 	jal	9d0061ec <USBCBWakeFromSuspend>
9d0064a0:	00000000 	nop
            break;
9d0064a4:	0b40193c 	j	9d0064f0 <USER_USB_CALLBACK_EVENT_HANDLER+0x12c>
9d0064a8:	00000000 	nop
        case EVENT_CONFIGURED:
            USBCBInitEP();
9d0064ac:	0f4018a7 	jal	9d00629c <USBCBInitEP>
9d0064b0:	00000000 	nop
            break;
9d0064b4:	0b40193c 	j	9d0064f0 <USER_USB_CALLBACK_EVENT_HANDLER+0x12c>
9d0064b8:	00000000 	nop
        case EVENT_SET_DESCRIPTOR:
            USBCBStdSetDscHandler();
9d0064bc:	0f40189f 	jal	9d00627c <USBCBStdSetDscHandler>
9d0064c0:	00000000 	nop
            break;
9d0064c4:	0b40193c 	j	9d0064f0 <USER_USB_CALLBACK_EVENT_HANDLER+0x12c>
9d0064c8:	00000000 	nop
        case EVENT_EP0_REQUEST:
            USBCBCheckOtherReq();
9d0064cc:	0f401893 	jal	9d00624c <USBCBCheckOtherReq>
9d0064d0:	00000000 	nop
            break;
9d0064d4:	0b40193c 	j	9d0064f0 <USER_USB_CALLBACK_EVENT_HANDLER+0x12c>
9d0064d8:	00000000 	nop
        case EVENT_BUS_ERROR:
            USBCBErrorHandler();
9d0064dc:	0f40188b 	jal	9d00622c <USBCBErrorHandler>
9d0064e0:	00000000 	nop
            break;
9d0064e4:	0b40193c 	j	9d0064f0 <USER_USB_CALLBACK_EVENT_HANDLER+0x12c>
9d0064e8:	00000000 	nop
{
    switch (event)
    {
        case EVENT_TRANSFER:
            // Add application specific callback task or callback function here if desired.
            break;
9d0064ec:	00000000 	nop
            break;
        default:
            break;
    }

    return TRUE; 
9d0064f0:	24020001 	li	v0,1
}
9d0064f4:	03c0e821 	move	sp,s8
9d0064f8:	8fbf0014 	lw	ra,20(sp)
9d0064fc:	8fbe0010 	lw	s8,16(sp)
9d006500:	27bd0018 	addiu	sp,sp,24
9d006504:	03e00008 	jr	ra
9d006508:	00000000 	nop

Disassembly of section .rodata:

9d00650c <__IntSrcTbl>:
9d00650c:	bf881030 bf881060 00000001 bf881030     0...`.......0...
9d00651c:	bf881060 00000002 bf881030 bf881060     `.......0...`...
9d00652c:	00000004 bf881030 bf881060 00000008     ....0...`.......
9d00653c:	bf881030 bf881060 00000100 bf881030     0...`.......0...
9d00654c:	bf881060 00002000 bf881030 bf881060     `.... ..0...`...
9d00655c:	00040000 bf881030 bf881060 00800000     ....0...`.......
9d00656c:	bf881030 bf881060 00000010 bf881030     0...`.......0...
9d00657c:	bf881060 00000200 bf881030 bf881060     `.......0...`...
9d00658c:	00004000 bf881030 bf881060 00080000     .@..0...`.......
9d00659c:	bf881030 bf881060 01000000 bf881030     0...`.......0...
9d0065ac:	bf881060 00000020 bf881030 bf881060     `... ...0...`...
9d0065bc:	00000400 bf881030 bf881060 00008000     ....0...`.......
9d0065cc:	bf881030 bf881060 00100000 bf881030     0...`.......0...
9d0065dc:	bf881060 02000000 bf881030 bf881060     `.......0...`...
9d0065ec:	00000040 bf881030 bf881060 00000800     @...0...`.......
9d0065fc:	bf881030 bf881060 00010000 bf881030     0...`.......0...
9d00660c:	bf881060 00200000 bf881030 bf881060     `..... .0...`...
9d00661c:	04000000 bf881030 bf881060 00000080     ....0...`.......
9d00662c:	bf881030 bf881060 00001000 bf881030     0...`.......0...
9d00663c:	bf881060 00020000 bf881030 bf881060     `.......0...`...
9d00664c:	00400000 bf881030 bf881060 08000000     ..@.0...`.......
9d00665c:	bf881040 bf881070 00002000 bf881040     @...p.... ..@...
9d00666c:	bf881070 00004000 bf881040 bf881070     p....@..@...p...
9d00667c:	00008000 bf881040 bf881070 00000070     ....@...p...p...
9d00668c:	bf881040 bf881070 001c0000 bf881040     @...p.......@...
9d00669c:	bf881070 00000010 bf881040 bf881070     p.......@...p...
9d0066ac:	00040000 bf881040 bf881070 00000040     ....@...p...@...
9d0066bc:	bf881040 bf881070 00100000 bf881040     @...p.......@...
9d0066cc:	bf881070 00000020 bf881040 bf881070     p... ...@...p...
9d0066dc:	00080000 bf881040 bf881070 00001c00     ....@...p.......
9d0066ec:	bf881040 bf881070 07000000 bf881040     @...p.......@...
9d0066fc:	bf881070 00000400 bf881040 bf881070     p.......@...p...
9d00670c:	01000000 bf881040 bf881070 00000800     ....@...p.......
9d00671c:	bf881040 bf881070 02000000 bf881040     @...p.......@...
9d00672c:	bf881070 00001000 bf881040 bf881070     p.......@...p...
9d00673c:	04000000 bf881040 bf881070 00000380     ....@...p.......
9d00674c:	bf881040 bf881070 00e00000 bf881040     @...p.......@...
9d00675c:	bf881070 00000080 bf881040 bf881070     p.......@...p...
9d00676c:	00200000 bf881040 bf881070 00000100     .. .@...p.......
9d00677c:	bf881040 bf881070 00400000 bf881040     @...p.....@.@...
9d00678c:	bf881070 00000200 bf881040 bf881070     p.......@...p...
9d00679c:	00800000 bf881030 bf881060 10000000     ....0...`.......
9d0067ac:	bf881040 bf881070 00010000 bf881040     @...p.......@...
9d0067bc:	bf881070 00020000 bf881040 bf881070     p.......@...p...
9d0067cc:	00000001 bf881040 bf881070 00000002     ....@...p.......
9d0067dc:	bf881040 bf881070 00000004 bf881030     @...p.......0...
9d0067ec:	bf881060 20000000 bf881030 bf881060     `...... 0...`...
9d0067fc:	80000000 bf881030 bf881060 40000000     ....0...`......@
9d00680c:	bf881040 bf881070 08000000 bf881040     @...p.......@...
9d00681c:	bf881070 10000000 bf881040 bf881070     p.......@...p...
9d00682c:	20000000 bf881040 bf881070 40000000     ... @...p......@
9d00683c:	bf881040 bf881070 80000000 bf881040     @...p.......@...
9d00684c:	bf881070 00000008                       p.......

9d006854 <__IntVectorTbl>:
9d006854:	bf881090 00000000 00000002 bf881090     ................
9d006864:	00000008 0000000a bf881090 00000010     ................
9d006874:	00000012 bf881090 00000018 0000001a     ................
9d006884:	bf8810a0 00000018 0000001a bf8810b0     ................
9d006894:	00000018 0000001a bf8810c0 00000018     ................
9d0068a4:	0000001a bf8810d0 00000018 0000001a     ................
9d0068b4:	bf8810a0 00000000 00000002 bf8810b0     ................
9d0068c4:	00000000 00000002 bf8810c0 00000000     ................
9d0068d4:	00000002 bf8810d0 00000000 00000002     ................
9d0068e4:	bf8810e0 00000000 00000002 bf8810a0     ................
9d0068f4:	00000008 0000000a bf8810b0 00000008     ................
9d006904:	0000000a bf8810c0 00000008 0000000a     ................
9d006914:	bf8810d0 00000008 0000000a bf8810e0     ................
9d006924:	00000008 0000000a bf8810a0 00000010     ................
9d006934:	00000012 bf8810b0 00000010 00000012     ................
9d006944:	bf8810c0 00000010 00000012 bf8810d0     ................
9d006954:	00000010 00000012 bf8810e0 00000010     ................
9d006964:	00000012 bf881100 00000018 0000001a     ................
9d006974:	bf881100 00000000 00000002 bf881110     ................
9d006984:	00000000 00000002 bf881120 00000008     ........ .......
9d006994:	0000000a bf881110 00000008 0000000a     ................
9d0069a4:	bf881120 00000010 00000012 bf881110      ...............
9d0069b4:	00000010 00000012 bf8810e0 00000018     ................
9d0069c4:	0000001a bf881110 00000018 0000001a     ................
9d0069d4:	bf8810f0 00000018 0000001a bf881100     ................
9d0069e4:	00000000 00000002 bf881100 00000008     ................
9d0069f4:	0000000a bf8810f0 00000000 00000002     ................
9d006a04:	bf8810f0 00000008 0000000a bf881120     ............ ...
9d006a14:	00000018 0000001a bf881130 00000000     ........0.......
9d006a24:	00000002 bf881130 00000008 0000000a     ....0...........
9d006a34:	bf881130 00000010 00000012 bf881130     0...........0...
9d006a44:	00000018 0000001a bf8810f0 00000010     ................
9d006a54:	00000012 bf881100 00000010 00000012     ................

Disassembly of section .text:

9d006a64 <UtTimeDelay10us>:
// Normally GetSystemClock()/4 for PIC18, GetSystemClock()/2 for PIC24/dsPIC, and GetSystemClock()/1 for PIC32.  Divisor may be different if using a PIC32 since it's configurable.
#define GetPeripheralClock() (GetSystemClock() / 1) // FPBDIV = DIV_1

void UtTimeDelay10us(
  UINT32 tenMicroSecondCounter)
{
9d006a64:	27bdfff0 	addiu	sp,sp,-16
9d006a68:	afbe000c 	sw	s8,12(sp)
9d006a6c:	03a0f021 	move	s8,sp
9d006a70:	afc40010 	sw	a0,16(s8)
    else
    {
        //7 cycles burned to this point.
            
        //We want to pre-calculate number of cycles required to delay 10us * tenMicroSecondCounter using a 1 cycle granule.
        cyclesRequiredForEntireDelay = (INT32)(GetInstructionClock() / 100000) * tenMicroSecondCounter;
9d006a74:	8fc20010 	lw	v0,16(s8)
9d006a78:	00021100 	sll	v0,v0,0x4
9d006a7c:	00021880 	sll	v1,v0,0x2
9d006a80:	00431021 	addu	v0,v0,v1
9d006a84:	afc20000 	sw	v0,0(s8)
            
        //We subtract all the cycles used up until we reach the while loop below, where each loop cycle count is subtracted.
        //Also we subtract the 5 cycle function return.
        cyclesRequiredForEntireDelay -= 24; //(19 + 5)
9d006a88:	8fc20000 	lw	v0,0(s8)
9d006a8c:	2442ffe8 	addiu	v0,v0,-24
9d006a90:	afc20000 	sw	v0,0(s8)
            
        if (cyclesRequiredForEntireDelay <= 0)
9d006a94:	8fc20000 	lw	v0,0(s8)
9d006a98:	18400009 	blez	v0,9d006ac0 <UtTimeDelay10us+0x5c>
9d006a9c:	00000000 	nop
        {
            // If we have exceeded the cycle count already, bail!
        }
        else
        {   
            while (cyclesRequiredForEntireDelay > 0) //19 cycles used to this point.
9d006aa0:	0b401aad 	j	9d006ab4 <UtTimeDelay10us+0x50>
9d006aa4:	00000000 	nop
            {
                cyclesRequiredForEntireDelay -= 8; //Subtract cycles burned while doing each delay stage, 8 in this case.
9d006aa8:	8fc20000 	lw	v0,0(s8)
9d006aac:	2442fff8 	addiu	v0,v0,-8
9d006ab0:	afc20000 	sw	v0,0(s8)
        {
            // If we have exceeded the cycle count already, bail!
        }
        else
        {   
            while (cyclesRequiredForEntireDelay > 0) //19 cycles used to this point.
9d006ab4:	8fc20000 	lw	v0,0(s8)
9d006ab8:	1c40fffb 	bgtz	v0,9d006aa8 <UtTimeDelay10us+0x44>
9d006abc:	00000000 	nop
            {
                cyclesRequiredForEntireDelay -= 8; //Subtract cycles burned while doing each delay stage, 8 in this case.
            }
        }
    }
}
9d006ac0:	03c0e821 	move	sp,s8
9d006ac4:	8fbe000c 	lw	s8,12(sp)
9d006ac8:	27bd0010 	addiu	sp,sp,16
9d006acc:	03e00008 	jr	ra
9d006ad0:	00000000 	nop

9d006ad4 <UtTimeDelayMs>:

void UtTimeDelayMs(
  UINT16 ms)
{
9d006ad4:	27bdffe0 	addiu	sp,sp,-32
9d006ad8:	afbf001c 	sw	ra,28(sp)
9d006adc:	afbe0018 	sw	s8,24(sp)
9d006ae0:	03a0f021 	move	s8,sp
9d006ae4:	00801021 	move	v0,a0
9d006ae8:	a7c20020 	sh	v0,32(s8)
    volatile UINT8 i;
        
    while (ms--)
9d006aec:	0b401acd 	j	9d006b34 <UtTimeDelayMs+0x60>
9d006af0:	00000000 	nop
    {
        i = 4;
9d006af4:	24020004 	li	v0,4
9d006af8:	a3c20010 	sb	v0,16(s8)
        
        while (i--)
9d006afc:	0b401ac4 	j	9d006b10 <UtTimeDelayMs+0x3c>
9d006b00:	00000000 	nop
        {
            UtTimeDelay10us(25);
9d006b04:	24040019 	li	a0,25
9d006b08:	0f401a99 	jal	9d006a64 <UtTimeDelay10us>
9d006b0c:	00000000 	nop
        
    while (ms--)
    {
        i = 4;
        
        while (i--)
9d006b10:	93c20010 	lbu	v0,16(s8)
9d006b14:	304200ff 	andi	v0,v0,0xff
9d006b18:	0002182b 	sltu	v1,zero,v0
9d006b1c:	306300ff 	andi	v1,v1,0xff
9d006b20:	2442ffff 	addiu	v0,v0,-1
9d006b24:	304200ff 	andi	v0,v0,0xff
9d006b28:	a3c20010 	sb	v0,16(s8)
9d006b2c:	1460fff5 	bnez	v1,9d006b04 <UtTimeDelayMs+0x30>
9d006b30:	00000000 	nop
void UtTimeDelayMs(
  UINT16 ms)
{
    volatile UINT8 i;
        
    while (ms--)
9d006b34:	97c20020 	lhu	v0,32(s8)
9d006b38:	0002102b 	sltu	v0,zero,v0
9d006b3c:	304200ff 	andi	v0,v0,0xff
9d006b40:	97c30020 	lhu	v1,32(s8)
9d006b44:	2463ffff 	addiu	v1,v1,-1
9d006b48:	a7c30020 	sh	v1,32(s8)
9d006b4c:	1440ffe9 	bnez	v0,9d006af4 <UtTimeDelayMs+0x20>
9d006b50:	00000000 	nop
        while (i--)
        {
            UtTimeDelay10us(25);
        }
    }
}
9d006b54:	03c0e821 	move	sp,s8
9d006b58:	8fbf001c 	lw	ra,28(sp)
9d006b5c:	8fbe0018 	lw	s8,24(sp)
9d006b60:	27bd0020 	addiu	sp,sp,32
9d006b64:	03e00008 	jr	ra
9d006b68:	00000000 	nop

9d006b6c <test>:
#if defined(__32MX250F128B__)

static UINT8 l_CounterExpired = 0;

void test()
{
9d006b6c:	27bdfff8 	addiu	sp,sp,-8
9d006b70:	afbe0004 	sw	s8,4(sp)
9d006b74:	03a0f021 	move	s8,sp
    // 32MX250F128B internally runs @ 40MHz



    
    T2CON = 0;
9d006b78:	3c02bf80 	lui	v0,0xbf80
9d006b7c:	ac400800 	sw	zero,2048(v0)
    T3CON = 0;
9d006b80:	3c02bf80 	lui	v0,0xbf80
9d006b84:	ac400a00 	sw	zero,2560(v0)
    
    T2CONbits.ON = 0; // disable timer
9d006b88:	3c03bf80 	lui	v1,0xbf80
9d006b8c:	8c620800 	lw	v0,2048(v1)
9d006b90:	7c027bc4 	ins	v0,zero,0xf,0x1
9d006b94:	ac620800 	sw	v0,2048(v1)
    T2CONbits.SIDL = 0; // stop in idle mode
9d006b98:	3c03bf80 	lui	v1,0xbf80
9d006b9c:	8c620800 	lw	v0,2048(v1)
9d006ba0:	7c026b44 	ins	v0,zero,0xd,0x1
9d006ba4:	ac620800 	sw	v0,2048(v1)
    T2CONbits.TCKPS = 0; // Timer Input Clock Prescale (1:1))
9d006ba8:	3c03bf80 	lui	v1,0xbf80
9d006bac:	8c620800 	lw	v0,2048(v1)
9d006bb0:	7c023104 	ins	v0,zero,0x4,0x3
9d006bb4:	ac620800 	sw	v0,2048(v1)
    T2CONbits.T32 = 1; // enable 32-bit timer
9d006bb8:	3c03bf80 	lui	v1,0xbf80
9d006bbc:	8c620800 	lw	v0,2048(v1)
9d006bc0:	24040001 	li	a0,1
9d006bc4:	7c8218c4 	ins	v0,a0,0x3,0x1
9d006bc8:	ac620800 	sw	v0,2048(v1)
    T2CONbits.TCS = 0; // Timer Clock Source Select (internal peripheral clock)
9d006bcc:	3c03bf80 	lui	v1,0xbf80
9d006bd0:	8c620800 	lw	v0,2048(v1)
9d006bd4:	7c020844 	ins	v0,zero,0x1,0x1
9d006bd8:	ac620800 	sw	v0,2048(v1)
    
    TMR2 = 0; // clear timer register (lower 16-bits)
9d006bdc:	3c02bf80 	lui	v0,0xbf80
9d006be0:	ac400810 	sw	zero,2064(v0)
    TMR3 = 0; // clear timer register (upper 16-bits)
9d006be4:	3c02bf80 	lui	v0,0xbf80
9d006be8:	ac400a10 	sw	zero,2576(v0)
    
    PR2 = 0xFFFFFFFF; // load period register (PR2 and PR3))
9d006bec:	3c02bf80 	lui	v0,0xbf80
9d006bf0:	2403ffff 	li	v1,-1
9d006bf4:	ac430820 	sw	v1,2080(v0)
    
    IPC2SET = 0x0000000C; // Set priority level = 3
9d006bf8:	3c02bf88 	lui	v0,0xbf88
9d006bfc:	2403000c 	li	v1,12
9d006c00:	ac4310b8 	sw	v1,4280(v0)
    IPC2SET = 0x00000001; // Set subpriority level = 1
9d006c04:	3c02bf88 	lui	v0,0xbf88
9d006c08:	24030001 	li	v1,1
9d006c0c:	ac4310b8 	sw	v1,4280(v0)
                          // Can be done in a single operation by assigning PC2SET = 0x0000000D
    
    IFS0CLR = 0x00000100; // Clear the timer interrupt status flag
9d006c10:	3c02bf88 	lui	v0,0xbf88
9d006c14:	24030100 	li	v1,256
9d006c18:	ac431034 	sw	v1,4148(v0)
    IEC0SET = 0x00000100; // Enable timer interrupts
9d006c1c:	3c02bf88 	lui	v0,0xbf88
9d006c20:	24030100 	li	v1,256
9d006c24:	ac431068 	sw	v1,4200(v0)
    
    l_CounterExpired = 0;
9d006c28:	a3808024 	sb	zero,-32732(gp)
    
    T2CONSET = 0x8000; // start 32-bit timer
9d006c2c:	3c02bf80 	lui	v0,0xbf80
9d006c30:	34038000 	li	v1,0x8000
9d006c34:	ac430808 	sw	v1,2056(v0)
    
    while (!l_CounterExpired)
9d006c38:	00000000 	nop
9d006c3c:	93828024 	lbu	v0,-32732(gp)
9d006c40:	1040fffe 	beqz	v0,9d006c3c <test+0xd0>
9d006c44:	00000000 	nop
    {
    }
}
9d006c48:	03c0e821 	move	sp,s8
9d006c4c:	8fbe0004 	lw	s8,4(sp)
9d006c50:	27bd0008 	addiu	sp,sp,8
9d006c54:	03e00008 	jr	ra
9d006c58:	00000000 	nop

9d006c5c <Timer1Handler>:

void __ISR(_TIMER_2_VECTOR, IPL3SOFT) Timer1Handler(void)
{
9d006c5c:	415de800 	rdpgpr	sp,sp
9d006c60:	401a7000 	mfc0	k0,c0_epc
9d006c64:	401b6000 	mfc0	k1,c0_status
9d006c68:	27bdffe0 	addiu	sp,sp,-32
9d006c6c:	afba001c 	sw	k0,28(sp)
9d006c70:	401a6002 	mfc0	k0,c0_srsctl
9d006c74:	afbb0018 	sw	k1,24(sp)
9d006c78:	afba0014 	sw	k0,20(sp)
9d006c7c:	7c1b7844 	ins	k1,zero,0x1,0xf
9d006c80:	377b0c00 	ori	k1,k1,0xc00
9d006c84:	409b6000 	mtc0	k1,c0_status
9d006c88:	afbe000c 	sw	s8,12(sp)
9d006c8c:	afa30008 	sw	v1,8(sp)
9d006c90:	afa20004 	sw	v0,4(sp)
9d006c94:	03a0f021 	move	s8,sp
    IFS0CLR = 0x00000100; // Be sure to clear the Timer1 interrupt status
9d006c98:	3c02bf88 	lui	v0,0xbf88
9d006c9c:	24030100 	li	v1,256
9d006ca0:	ac431034 	sw	v1,4148(v0)
    
    l_CounterExpired = 1;
9d006ca4:	24020001 	li	v0,1
9d006ca8:	a3828024 	sb	v0,-32732(gp)
}
9d006cac:	03c0e821 	move	sp,s8
9d006cb0:	8fbe000c 	lw	s8,12(sp)
9d006cb4:	8fa30008 	lw	v1,8(sp)
9d006cb8:	8fa20004 	lw	v0,4(sp)
9d006cbc:	41606000 	di
9d006cc0:	000000c0 	ehb
9d006cc4:	8fba001c 	lw	k0,28(sp)
9d006cc8:	8fbb0018 	lw	k1,24(sp)
9d006ccc:	409a7000 	mtc0	k0,c0_epc
9d006cd0:	8fba0014 	lw	k0,20(sp)
9d006cd4:	27bd0020 	addiu	sp,sp,32
9d006cd8:	409a6002 	mtc0	k0,c0_srsctl
9d006cdc:	41dde800 	wrpgpr	sp,sp
9d006ce0:	409b6000 	mtc0	k1,c0_status
9d006ce4:	42000018 	eret

9d006ce8 <USBCheckVendorRequest>:
 
 *******************************************************************/

#if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
void USBCheckVendorRequest(void)
{
9d006ce8:	27bdfff0 	addiu	sp,sp,-16
9d006cec:	afbe000c 	sw	s8,12(sp)
9d006cf0:	03a0f021 	move	s8,sp
    UINT16 wLength;

    //Check if the most recent SETUP request is class specific
    if (SetupPkt.bmRequestType == 0b11000000)    //Class specific, device to host, device level target
9d006cf4:	93828058 	lbu	v0,-32680(gp)
9d006cf8:	304300ff 	andi	v1,v0,0xff
9d006cfc:	240200c0 	li	v0,192
9d006d00:	14620037 	bne	v1,v0,9d006de0 <USBCheckVendorRequest+0xf8>
9d006d04:	00000000 	nop
    {
        //Check if the host is requesting an MS feature descriptor
        if (SetupPkt.bRequest == GET_MS_DESCRIPTOR)
9d006d08:	93828059 	lbu	v0,-32679(gp)
9d006d0c:	304300ff 	andi	v1,v0,0xff
9d006d10:	240200ee 	li	v0,238
9d006d14:	1462006b 	bne	v1,v0,9d006ec4 <USBCheckVendorRequest+0x1dc>
9d006d18:	00000000 	nop
        {
            //Figure out which descriptor is being requested
            if (SetupPkt.wIndex == EXTENDED_COMPAT_ID)
9d006d1c:	9382805c 	lbu	v0,-32676(gp)
9d006d20:	304200ff 	andi	v0,v0,0xff
9d006d24:	9383805d 	lbu	v1,-32675(gp)
9d006d28:	306300ff 	andi	v1,v1,0xff
9d006d2c:	00031a00 	sll	v1,v1,0x8
9d006d30:	00621025 	or	v0,v1,v0
9d006d34:	3043ffff 	andi	v1,v0,0xffff
9d006d38:	24020004 	li	v0,4
9d006d3c:	14620061 	bne	v1,v0,9d006ec4 <USBCheckVendorRequest+0x1dc>
9d006d40:	00000000 	nop
            {
                //Determine number of bytes to send to host
                //Lesser of: requested amount, or total size of the descriptor
                wLength = CompatIDFeatureDescriptor.dwLength;
9d006d44:	3c029d00 	lui	v0,0x9d00
9d006d48:	24436f70 	addiu	v1,v0,28528
9d006d4c:	88630003 	lwl	v1,3(v1)
9d006d50:	00602021 	move	a0,v1
9d006d54:	98446f70 	lwr	a0,28528(v0)
9d006d58:	00801021 	move	v0,a0
9d006d5c:	a7c20000 	sh	v0,0(s8)

                if (SetupPkt.wLength < wLength)
9d006d60:	9382805e 	lbu	v0,-32674(gp)
9d006d64:	304200ff 	andi	v0,v0,0xff
9d006d68:	9383805f 	lbu	v1,-32673(gp)
9d006d6c:	306300ff 	andi	v1,v1,0xff
9d006d70:	00031a00 	sll	v1,v1,0x8
9d006d74:	00621025 	or	v0,v1,v0
9d006d78:	3042ffff 	andi	v0,v0,0xffff
9d006d7c:	97c30000 	lhu	v1,0(s8)
9d006d80:	0043102b 	sltu	v0,v0,v1
9d006d84:	10400008 	beqz	v0,9d006da8 <USBCheckVendorRequest+0xc0>
9d006d88:	00000000 	nop
                {
                    wLength = SetupPkt.wLength;
9d006d8c:	9382805e 	lbu	v0,-32674(gp)
9d006d90:	304200ff 	andi	v0,v0,0xff
9d006d94:	9383805f 	lbu	v1,-32673(gp)
9d006d98:	306300ff 	andi	v1,v1,0xff
9d006d9c:	00031a00 	sll	v1,v1,0x8
9d006da0:	00621025 	or	v0,v1,v0
9d006da4:	a7c20000 	sh	v0,0(s8)
                }

                //Prepare to send the requested descriptor to the host
                USBEP0SendROMPtr((ROM UINT8*)&CompatIDFeatureDescriptor, wLength,
9d006da8:	3c029d00 	lui	v0,0x9d00
9d006dac:	24436f70 	addiu	v1,v0,28528
9d006db0:	3c02a000 	lui	v0,0xa000
9d006db4:	ac430280 	sw	v1,640(v0)
9d006db8:	3c02a000 	lui	v0,0xa000
9d006dbc:	24420280 	addiu	v0,v0,640
9d006dc0:	97c30000 	lhu	v1,0(s8)
9d006dc4:	a4430008 	sh	v1,8(v0)
9d006dc8:	3c02a000 	lui	v0,0xa000
9d006dcc:	24420280 	addiu	v0,v0,640
9d006dd0:	2403ffc0 	li	v1,-64
9d006dd4:	a0430004 	sb	v1,4(v0)
9d006dd8:	0b401bb1 	j	9d006ec4 <USBCheckVendorRequest+0x1dc>
9d006ddc:	00000000 	nop
                                 USB_EP0_ROM | USB_EP0_INCLUDE_ZERO);
            }
        }
    }
    else if (SetupPkt.bmRequestType == 0b11000001)    //Class specific, device to host, interface target
9d006de0:	93828058 	lbu	v0,-32680(gp)
9d006de4:	304300ff 	andi	v1,v0,0xff
9d006de8:	240200c1 	li	v0,193
9d006dec:	14620035 	bne	v1,v0,9d006ec4 <USBCheckVendorRequest+0x1dc>
9d006df0:	00000000 	nop
    {
        //Check if the host is requesting an MS feature descriptor
        if (SetupPkt.bRequest == GET_MS_DESCRIPTOR)
9d006df4:	93828059 	lbu	v0,-32679(gp)
9d006df8:	304300ff 	andi	v1,v0,0xff
9d006dfc:	240200ee 	li	v0,238
9d006e00:	14620030 	bne	v1,v0,9d006ec4 <USBCheckVendorRequest+0x1dc>
9d006e04:	00000000 	nop
        {
            //Figure out which descriptor is being requested
            if (SetupPkt.wIndex == EXTENDED_PROPERTIES)
9d006e08:	9382805c 	lbu	v0,-32676(gp)
9d006e0c:	304200ff 	andi	v0,v0,0xff
9d006e10:	9383805d 	lbu	v1,-32675(gp)
9d006e14:	306300ff 	andi	v1,v1,0xff
9d006e18:	00031a00 	sll	v1,v1,0x8
9d006e1c:	00621025 	or	v0,v1,v0
9d006e20:	3043ffff 	andi	v1,v0,0xffff
9d006e24:	24020005 	li	v0,5
9d006e28:	14620026 	bne	v1,v0,9d006ec4 <USBCheckVendorRequest+0x1dc>
9d006e2c:	00000000 	nop
            {
                //Determine number of bytes to send to host
                //Lesser of: requested amount, or total size of the descriptor
                wLength = ExtPropertyFeatureDescriptor.dwLength;
9d006e30:	3c029d00 	lui	v0,0x9d00
9d006e34:	24436f98 	addiu	v1,v0,28568
9d006e38:	88630003 	lwl	v1,3(v1)
9d006e3c:	00602021 	move	a0,v1
9d006e40:	98446f98 	lwr	a0,28568(v0)
9d006e44:	00801021 	move	v0,a0
9d006e48:	a7c20000 	sh	v0,0(s8)

                if (SetupPkt.wLength < wLength)
9d006e4c:	9382805e 	lbu	v0,-32674(gp)
9d006e50:	304200ff 	andi	v0,v0,0xff
9d006e54:	9383805f 	lbu	v1,-32673(gp)
9d006e58:	306300ff 	andi	v1,v1,0xff
9d006e5c:	00031a00 	sll	v1,v1,0x8
9d006e60:	00621025 	or	v0,v1,v0
9d006e64:	3042ffff 	andi	v0,v0,0xffff
9d006e68:	97c30000 	lhu	v1,0(s8)
9d006e6c:	0043102b 	sltu	v0,v0,v1
9d006e70:	10400008 	beqz	v0,9d006e94 <USBCheckVendorRequest+0x1ac>
9d006e74:	00000000 	nop
                {
                    wLength = SetupPkt.wLength;
9d006e78:	9382805e 	lbu	v0,-32674(gp)
9d006e7c:	304200ff 	andi	v0,v0,0xff
9d006e80:	9383805f 	lbu	v1,-32673(gp)
9d006e84:	306300ff 	andi	v1,v1,0xff
9d006e88:	00031a00 	sll	v1,v1,0x8
9d006e8c:	00621025 	or	v0,v1,v0
9d006e90:	a7c20000 	sh	v0,0(s8)
                }

                //Prepare to send the requested descriptor to the host
                USBEP0SendROMPtr((ROM UINT8*)&ExtPropertyFeatureDescriptor, wLength,
9d006e94:	3c029d00 	lui	v0,0x9d00
9d006e98:	24436f98 	addiu	v1,v0,28568
9d006e9c:	3c02a000 	lui	v0,0xa000
9d006ea0:	ac430280 	sw	v1,640(v0)
9d006ea4:	3c02a000 	lui	v0,0xa000
9d006ea8:	24420280 	addiu	v0,v0,640
9d006eac:	97c30000 	lhu	v1,0(s8)
9d006eb0:	a4430008 	sh	v1,8(v0)
9d006eb4:	3c02a000 	lui	v0,0xa000
9d006eb8:	24420280 	addiu	v0,v0,640
9d006ebc:	2403ffc0 	li	v1,-64
9d006ec0:	a0430004 	sb	v1,4(v0)
                                 USB_EP0_ROM | USB_EP0_INCLUDE_ZERO);
            }
        }
    }
}
9d006ec4:	03c0e821 	move	sp,s8
9d006ec8:	8fbe000c 	lw	s8,12(sp)
9d006ecc:	27bd0010 	addiu	sp,sp,16
9d006ed0:	03e00008 	jr	ra
9d006ed4:	00000000 	nop

Disassembly of section .rodata:

9d006ed8 <g_DeviceDescriptor>:
9d006ed8:	02000112 40000000 005204d8 02010000     .......@..R.....
9d006ee8:	00000100                                ....

9d006eec <l_ConfigDescriptor>:
9d006eec:	00200209 80000101 00040932 ffff0200     .. .....2.......
9d006efc:	050700ff 00400201 81050701 01004002     ......@......@..

9d006f0c <l_StringDescriptorCodePage>:
9d006f0c:	04090304                                ....

9d006f10 <l_StringDescriptorManufacturer>:
9d006f10:	004b031c 00760065 006e0069 00450020     ..K.e.v.i.n. .E.
9d006f20:	00680073 00610062 00680063              s.h.b.a.c.h.

9d006f2c <l_StringDescriptorProduct>:
9d006f2c:	00550320 00420053 00540020 0020006f      .U.S.B. .T.o. .
9d006f3c:	00500045 004f0052 002b004d 00320020     E.P.R.O.M.+. .2.

9d006f4c <USB_CD_Ptr>:
9d006f4c:	9d006eec                                .n..

9d006f50 <USB_SD_Ptr>:
9d006f50:	9d006f0c 9d006f10 9d006f2c              .o...o..,o..

9d006f5c <MSOSDescriptor>:
9d006f5c:	004d0312 00460053 00310054 00300030     ..M.S.F.T.1.0.0.
9d006f6c:	000000ee                                ....

9d006f70 <CompatIDFeatureDescriptor>:
9d006f70:	00000028 00040100 00000001 00000000     (...............
9d006f80:	49570100 4253554e 00000000 00000000     ..WINUSB........
	...

9d006f98 <ExtPropertyFeatureDescriptor>:
9d006f98:	0000008e 00050100 00840001 00010000     ................
9d006fa8:	00280000 00650044 00690076 00650063     ..(.D.e.v.i.c.e.
9d006fb8:	006e0049 00650074 00660072 00630061     I.n.t.e.r.f.a.c.
9d006fc8:	00470065 00490055 00000044 0000004e     e.G.U.I.D...N...
9d006fd8:	0035007b 00440038 00370030 00310032     {.5.8.D.0.7.2.1.
9d006fe8:	002d0030 00370032 00310043 0031002d     0.-.2.7.C.1.-.1.
9d006ff8:	00440031 002d0044 00440042 00420030     1.D.D.-.B.D.0.B.
9d007008:	0030002d 00300038 00320030 00300030     -.0.8.0.0.2.0.0.
9d007018:	00390043 00360041 007d0036 00000000     C.9.A.6.6.}.....

Disassembly of section .text.general_exception:

9d007028 <_general_exception_context>:
9d007028:	27bdffa8 	addiu	sp,sp,-88
9d00702c:	afa10004 	sw	at,4(sp)
9d007030:	afa20008 	sw	v0,8(sp)
9d007034:	afa3000c 	sw	v1,12(sp)
9d007038:	afa40010 	sw	a0,16(sp)
9d00703c:	afa50014 	sw	a1,20(sp)
9d007040:	afa60018 	sw	a2,24(sp)
9d007044:	afa7001c 	sw	a3,28(sp)
9d007048:	afa80020 	sw	t0,32(sp)
9d00704c:	afa90024 	sw	t1,36(sp)
9d007050:	afaa0028 	sw	t2,40(sp)
9d007054:	afab002c 	sw	t3,44(sp)
9d007058:	afac0030 	sw	t4,48(sp)
9d00705c:	afad0034 	sw	t5,52(sp)
9d007060:	afae0038 	sw	t6,56(sp)
9d007064:	afaf003c 	sw	t7,60(sp)
9d007068:	afb80040 	sw	t8,64(sp)
9d00706c:	afb90044 	sw	t9,68(sp)
9d007070:	afbf0048 	sw	ra,72(sp)
9d007074:	00004012 	mflo	t0
9d007078:	afa8004c 	sw	t0,76(sp)
9d00707c:	00004010 	mfhi	t0
9d007080:	afa80050 	sw	t0,80(sp)
9d007084:	40046800 	mfc0	a0,c0_cause
9d007088:	40056000 	mfc0	a1,c0_status
9d00708c:	0f401cc8 	jal	9d007320 <_general_exception_handler>
9d007090:	00000000 	nop
9d007094:	8fa80050 	lw	t0,80(sp)
9d007098:	01000011 	mthi	t0
9d00709c:	8fa8004c 	lw	t0,76(sp)
9d0070a0:	01000013 	mtlo	t0
9d0070a4:	8fa10004 	lw	at,4(sp)
9d0070a8:	8fa20008 	lw	v0,8(sp)
9d0070ac:	8fa3000c 	lw	v1,12(sp)
9d0070b0:	8fa40010 	lw	a0,16(sp)
9d0070b4:	8fa50014 	lw	a1,20(sp)
9d0070b8:	8fa60018 	lw	a2,24(sp)
9d0070bc:	8fa7001c 	lw	a3,28(sp)
9d0070c0:	8fa80020 	lw	t0,32(sp)
9d0070c4:	8fa90024 	lw	t1,36(sp)
9d0070c8:	8faa0028 	lw	t2,40(sp)
9d0070cc:	8fab002c 	lw	t3,44(sp)
9d0070d0:	8fac0030 	lw	t4,48(sp)
9d0070d4:	8fad0034 	lw	t5,52(sp)
9d0070d8:	8fae0038 	lw	t6,56(sp)
9d0070dc:	8faf003c 	lw	t7,60(sp)
9d0070e0:	8fb80040 	lw	t8,64(sp)
9d0070e4:	8fb90044 	lw	t9,68(sp)
9d0070e8:	8fbf0048 	lw	ra,72(sp)
9d0070ec:	27bd0058 	addiu	sp,sp,88
9d0070f0:	000000c0 	ehb
9d0070f4:	42000018 	eret

Disassembly of section .text:

9d0070f8 <memset>:
9d0070f8:	00801021 	move	v0,a0
9d0070fc:	10c00026 	beqz	a2,9d007198 <memset+0xa0>
9d007100:	2cca0010 	sltiu	t2,a2,16
9d007104:	1540001f 	bnez	t2,9d007184 <memset+0x8c>
9d007108:	30a500ff 	andi	a1,a1,0xff
9d00710c:	00055200 	sll	t2,a1,0x8
9d007110:	00aa2825 	or	a1,a1,t2
9d007114:	00055400 	sll	t2,a1,0x10
9d007118:	00aa2825 	or	a1,a1,t2
9d00711c:	30830003 	andi	v1,a0,0x3
9d007120:	10600005 	beqz	v1,9d007138 <memset+0x40>
9d007124:	24070004 	li	a3,4
9d007128:	00e33823 	subu	a3,a3,v1
9d00712c:	00c73023 	subu	a2,a2,a3
9d007130:	b8850000 	swr	a1,0(a0)
9d007134:	00872021 	addu	a0,a0,a3
9d007138:	30c3000f 	andi	v1,a2,0xf
9d00713c:	00c33823 	subu	a3,a2,v1
9d007140:	10e00008 	beqz	a3,9d007164 <memset+0x6c>
9d007144:	00603021 	move	a2,v1
9d007148:	00e43821 	addu	a3,a3,a0
9d00714c:	ac850000 	sw	a1,0(a0)
9d007150:	ac850004 	sw	a1,4(a0)
9d007154:	ac850008 	sw	a1,8(a0)
9d007158:	24840010 	addiu	a0,a0,16
9d00715c:	1487fffb 	bne	a0,a3,9d00714c <memset+0x54>
9d007160:	ac85fffc 	sw	a1,-4(a0)
9d007164:	30c30003 	andi	v1,a2,0x3
9d007168:	00c33823 	subu	a3,a2,v1
9d00716c:	10e00005 	beqz	a3,9d007184 <memset+0x8c>
9d007170:	00603021 	move	a2,v1
9d007174:	00e43821 	addu	a3,a3,a0
9d007178:	24840004 	addiu	a0,a0,4
9d00717c:	1487fffe 	bne	a0,a3,9d007178 <memset+0x80>
9d007180:	ac85fffc 	sw	a1,-4(a0)
9d007184:	10c00004 	beqz	a2,9d007198 <memset+0xa0>
9d007188:	00c43821 	addu	a3,a2,a0
9d00718c:	24840001 	addiu	a0,a0,1
9d007190:	1487fffe 	bne	a0,a3,9d00718c <memset+0x94>
9d007194:	a085ffff 	sb	a1,-1(a0)
9d007198:	03e00008 	jr	ra
9d00719c:	00000000 	nop

9d0071a0 <UtSleep>:
#error Unknown device configuration
#endif

BOOL UtSleep(
  UINT32 nIntervalNanoseconds)
{
9d0071a0:	27bdfff0 	addiu	sp,sp,-16
9d0071a4:	afbe000c 	sw	s8,12(sp)
9d0071a8:	03a0f021 	move	s8,sp
9d0071ac:	afc40010 	sw	a0,16(s8)
#if defined(__32MX250F128B__)
    // 32MX250F128B sys clk runs @ 40MHz
    //    
    // 40 MHz means 1 clock takes 25 nanoseconds
    
    if (nIntervalNanoseconds > 100)
9d0071b0:	8fc20010 	lw	v0,16(s8)
9d0071b4:	2c420065 	sltiu	v0,v0,101
9d0071b8:	14400014 	bnez	v0,9d00720c <UtSleep+0x6c>
9d0071bc:	00000000 	nop
    {
        volatile UINT32 cyclesRequired = nIntervalNanoseconds / 25;
9d0071c0:	8fc30010 	lw	v1,16(s8)
9d0071c4:	3c0251eb 	lui	v0,0x51eb
9d0071c8:	3442851f 	ori	v0,v0,0x851f
9d0071cc:	00620019 	multu	v1,v0
9d0071d0:	00001010 	mfhi	v0
9d0071d4:	000210c2 	srl	v0,v0,0x3
9d0071d8:	afc20000 	sw	v0,0(s8)

        if (cyclesRequired > 20)
9d0071dc:	8fc20000 	lw	v0,0(s8)
9d0071e0:	2c420015 	sltiu	v0,v0,21
9d0071e4:	14400009 	bnez	v0,9d00720c <UtSleep+0x6c>
9d0071e8:	00000000 	nop
        {
            while (cyclesRequired--)
9d0071ec:	00000000 	nop
9d0071f0:	8fc20000 	lw	v0,0(s8)
9d0071f4:	0002182b 	sltu	v1,zero,v0
9d0071f8:	306300ff 	andi	v1,v1,0xff
9d0071fc:	2442ffff 	addiu	v0,v0,-1
9d007200:	afc20000 	sw	v0,0(s8)
9d007204:	1460fffa 	bnez	v1,9d0071f0 <UtSleep+0x50>
9d007208:	00000000 	nop
    }
#else
#error Unknown device configuration
#endif

	return TRUE;
9d00720c:	24020001 	li	v0,1
}
9d007210:	03c0e821 	move	sp,s8
9d007214:	8fbe000c 	lw	s8,12(sp)
9d007218:	27bd0010 	addiu	sp,sp,16
9d00721c:	03e00008 	jr	ra
9d007220:	00000000 	nop

Disassembly of section .dinit:

9d007224 <.dinit>:
9d007224:	a0000000 	sb	zero,0(zero)
9d007228:	00000001 	movf	zero,zero,$fcc0
9d00722c:	00000000 	nop
9d007230:	a0000200 	sb	zero,512(zero)
9d007234:	0000009b 	0x9b
9d007238:	00000000 	nop
9d00723c:	a0000108 	sb	zero,264(zero)
9d007240:	00000014 	0x14
9d007244:	00000001 	movf	zero,zero,$fcc0
9d007248:	584d3233 	0x584d3233
9d00724c:	46303532 	c.eq.d	$fcc5,$f6,$f16
9d007250:	42383231 	c0	0x383231
9d007254:	302e3120 	andi	t6,at,0x3120
9d007258:	00000030 	tge	zero,zero
9d00725c:	a000011c 	sb	zero,284(zero)
9d007260:	0000000c 	syscall
9d007264:	00000000 	nop
9d007268:	a00000e8 	sb	zero,232(zero)
9d00726c:	00000020 	add	zero,zero,zero
9d007270:	00000000 	nop
9d007274:	a0000064 	sb	zero,100(zero)
9d007278:	00000084 	0x84
9d00727c:	00000000 	nop
9d007280:	a0000004 	sb	zero,4(zero)
9d007284:	00000010 	mfhi	zero
9d007288:	00000000 	nop
9d00728c:	a0000014 	sb	zero,20(zero)
9d007290:	00000001 	movf	zero,zero,$fcc0
	...

Disassembly of section .text:

9d00729c <main>:
{
}
*/

int main(void)
{
9d00729c:	27bdffe8 	addiu	sp,sp,-24
9d0072a0:	afbf0014 	sw	ra,20(sp)
9d0072a4:	afbe0010 	sw	s8,16(sp)
9d0072a8:	03a0f021 	move	s8,sp
    return ExecutePepDevice();
9d0072ac:	0f401867 	jal	9d00619c <ExecutePepDevice>
9d0072b0:	00000000 	nop
}
9d0072b4:	03c0e821 	move	sp,s8
9d0072b8:	8fbf0014 	lw	ra,20(sp)
9d0072bc:	8fbe0010 	lw	s8,16(sp)
9d0072c0:	27bd0018 	addiu	sp,sp,24
9d0072c4:	03e00008 	jr	ra
9d0072c8:	00000000 	nop

Disassembly of section .text.INTClearFlag:

9d0072cc <INTClearFlag>:
9d0072cc:	00041080 	sll	v0,a0,0x2
9d0072d0:	00042100 	sll	a0,a0,0x4
9d0072d4:	00822023 	subu	a0,a0,v0
9d0072d8:	3c029d00 	lui	v0,0x9d00
9d0072dc:	2442650c 	addiu	v0,v0,25868
9d0072e0:	00822021 	addu	a0,a0,v0
9d0072e4:	8c820000 	lw	v0,0(a0)
9d0072e8:	8c830008 	lw	v1,8(a0)
9d0072ec:	ac430004 	sw	v1,4(v0)
9d0072f0:	03e00008 	jr	ra
9d0072f4:	00000000 	nop

Disassembly of section .text:

9d0072f8 <_nmi_handler>:
9d0072f8:	401a6000 	mfc0	k0,c0_status
9d0072fc:	3c1bffbf 	lui	k1,0xffbf
9d007300:	377bffff 	ori	k1,k1,0xffff
9d007304:	035bd024 	and	k0,k0,k1
9d007308:	409a6000 	mtc0	k0,c0_status
9d00730c:	42000018 	eret
9d007310:	0f401ca7 	jal	9d00729c <main>
9d007314:	00000000 	nop

9d007318 <__crt0_exit>:
9d007318:	1000ffff 00000000                       ........

9d007320 <_general_exception_handler>:
9d007320:	0b401cc8 	j	9d007320 <_general_exception_handler>
9d007324:	00000000 	nop

9d007328 <_bootstrap_exception_handler>:
9d007328:	0b401cca 	j	9d007328 <_bootstrap_exception_handler>
9d00732c:	00000000 	nop

9d007330 <_on_reset>:
9d007330:	03e00008 	jr	ra
9d007334:	00000000 	nop

9d007338 <_on_bootstrap>:
9d007338:	03e00008 	jr	ra
9d00733c:	00000000 	nop
